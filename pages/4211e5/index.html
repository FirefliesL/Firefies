<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>问题记录 | Fireflies's blog</title><meta name="author" content="Fireflies"><meta name="copyright" content="Fireflies"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="单编Selinux，push后无法Android启动 push进去的文件路径不对，可以先对比一下push进去的是整个selinux文件夹还是selinux文件夹下的子文件 本地的lunch的build type和编译的build type不一致, 需要都是userdebug的  Binder.getCallingPid为0获取调用者的pid时，一直是0，这是因为在client端是异步调用的，在ai">
<meta property="og:type" content="article">
<meta property="og:title" content="问题记录">
<meta property="og:url" content="http://example.com/pages/4211e5/index.html">
<meta property="og:site_name" content="Fireflies&#39;s blog">
<meta property="og:description" content="单编Selinux，push后无法Android启动 push进去的文件路径不对，可以先对比一下push进去的是整个selinux文件夹还是selinux文件夹下的子文件 本地的lunch的build type和编译的build type不一致, 需要都是userdebug的  Binder.getCallingPid为0获取调用者的pid时，一直是0，这是因为在client端是异步调用的，在ai">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-01-11T16:35:16.000Z">
<meta property="article:modified_time" content="2025-01-14T08:14:21.168Z">
<meta property="article:author" content="Fireflies">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/ico.jpg"><link rel="canonical" href="http://example.com/pages/4211e5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '问题记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-14 08:14:21'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #FF8F00)"><nav id="nav"><span id="blog-info"><a href="/" title="Fireflies's blog"><img class="site-icon" src="/img/avatar.jpg"/><span class="site-name">Fireflies's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">问题记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-11T16:35:16.000Z" title="发表于 2023-01-11 16:35:16">2023-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-14T08:14:21.168Z" title="更新于 2025-01-14 08:14:21">2025-01-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="问题记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="单编Selinux，push后无法Android启动"><a href="#单编Selinux，push后无法Android启动" class="headerlink" title="单编Selinux，push后无法Android启动"></a>单编Selinux，push后无法Android启动</h2><ol>
<li>push进去的文件路径不对，可以先对比一下push进去的是整个selinux文件夹还是selinux文件夹下的子文件</li>
<li><strong>本地的lunch的build type和编译的build type不一致, 需要都是userdebug的</strong></li>
</ol>
<h2 id="Binder-getCallingPid为0"><a href="#Binder-getCallingPid为0" class="headerlink" title="Binder.getCallingPid为0"></a>Binder.getCallingPid为0</h2><p>获取调用者的pid时，一直是0，这是因为在client端是异步调用的，在aidl中去掉client端使用的接口的oneway关键字即可。<br>如果想避免Binder调用耗时阻塞线程，可以在回调的接口上加上oneway关键字</p>
<p>如2个AIDL文件：</p>
<p>ITestService.aidl   客户端调用的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.test.localtest;</span><br><span class="line"></span><br><span class="line">import com.test.localtest.IInfoCallback;</span><br><span class="line"></span><br><span class="line">interface ITestService &#123;</span><br><span class="line">    void setInfoListener(IInfoCallback callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IInfoCallback.aidl  回调给客户端的接口，加上oneway关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.test.localtest;</span><br><span class="line"></span><br><span class="line">oneway interface IInfoCallback &#123;</span><br><span class="line">    void onMsg(String msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AOSP下AIDL编译报错couldn’t-find-import-for-class"><a href="#AOSP下AIDL编译报错couldn’t-find-import-for-class" class="headerlink" title="AOSP下AIDL编译报错couldn’t find import for class"></a>AOSP下AIDL编译报错couldn’t find import for class</h2><p>代码如下</p>
<p><strong>IVolumeDataCallback.aidl</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.test.volumecollect;</span><br><span class="line"></span><br><span class="line">interface IVolumeDataCallback &#123;</span><br><span class="line">    void onDataCallback(String data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IVolumeDataInteraction</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.test.volumecollect;</span><br><span class="line"></span><br><span class="line">import com.test.volumecollect.IVolumeDataCallback;</span><br><span class="line"></span><br><span class="line">oneway interface IVolumeDataInteraction &#123;</span><br><span class="line">    void queryData(IVolumeDataCallback callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在IVolumeDataInteraction中是通过import引入了com.test.volumecollect.IVolumeDataCallback这个类</p>
<p>但还是报couldn’t find import for class com.test.volumecollect.IVolumeDataCallback</p>
<p>顾名思义，就是找不到com.test.volumecollect.IVolumeDataCallback，</p>
<p>后面排查后发现，由于是将aidl文件单独封装成文件组，在Android.bp文件中，filegroup标签需要指定一下path，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filegroup &#123;</span><br><span class="line">    name: &quot;volume-collect-aidl&quot;,</span><br><span class="line">    srcs: [&quot;aidl/**/*.aidl&quot;],</span><br><span class="line">    path: &quot;aidl&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，编译的时候，就会以aidl目录为起始目录，去aidl目录下去找对应的文件，这样才能找到com.test.volumecollect这个包路径</p>
<h2 id="多个动态jar包加载同一个so引起崩溃"><a href="#多个动态jar包加载同一个so引起崩溃" class="headerlink" title="多个动态jar包加载同一个so引起崩溃"></a>多个动态jar包加载同一个so引起崩溃</h2><p>同一个.so不能加载到不同的类中，所以抛出了异常，导致崩溃。<br>解决方法，将任意一个jar包静态引用，静态引用的jar包打包在APK中，2个jar包使用的是同一个class</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    --------- beginning of crash</span><br><span class="line">2023-01-18 16:49:59.636 7083-7083/com.omosoft.hudinterface E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.omosoft.hudinterface, PID: 7083</span><br><span class="line">    java.lang.UnsatisfiedLinkError: Shared library &quot;/system/lib64/libjni_tiscservice.so&quot; already opened by ClassLoader 0x293(dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/system/framework/com.chinatsp.iscmanager.jar&quot;],nativeLibraryDirectories=[/data/app/~~Mm3DrXA3I_5atpde1Ky6KA==/com.omosoft.hudinterface-cdAVK1ZxEUxpzOvehmvbyg==/lib/arm64, /system/lib64, /system_ext/lib64]]]); can&#x27;t open in ClassLoader 0x7fff98d5ac(dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/system/framework/com.omosoft.hudmanager.jar&quot;],nativeLibraryDirectories=[/data/app/~~Mm3DrXA3I_5atpde1Ky6KA==/com.omosoft.hudinterface-cdAVK1ZxEUxpzOvehmvbyg==/lib/arm64, /system/lib64, /system_ext/lib64]]])</span><br><span class="line">        at java.lang.Runtime.loadLibrary0(Runtime.java:1087)</span><br><span class="line">        at java.lang.Runtime.loadLibrary0(Runtime.java:1008)</span><br><span class="line">        at java.lang.System.loadLibrary(System.java:1664)</span><br><span class="line">        at com.chinatsp.iscmanager.ISCManager.&lt;clinit&gt;(ISCManager.java:62)</span><br><span class="line">        at com.omosoft.hudmanager.HUDMsgDispatcher.&lt;init&gt;(HUDMsgDispatcher.java:26)</span><br><span class="line">        at com.omosoft.hudmanager.HUDMsgDispatcher.getInstance(HUDMsgDispatcher.java:35)</span><br><span class="line">        at com.omosoft.hudmanager.HUDManager.sendMsg(HUDManager.java:22)</span><br><span class="line">        at com.omosoft.hudmanager.HUDManager.setHUDMode(HUDManager.java:114)</span><br><span class="line">        at com.omosoft.hudinterface.MainActivity.onCreate(MainActivity.java:28)</span><br><span class="line">        at android.app.Activity.performCreate(Activity.java:7994)</span><br><span class="line">        at android.app.Activity.performCreate(Activity.java:7978)</span><br><span class="line">        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1309)</span><br><span class="line">        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3404)</span><br><span class="line">        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3595)</span><br><span class="line">        at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:85)</span><br><span class="line">        at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)</span><br><span class="line">        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2066)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:223)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:7664)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:592)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:947)</span><br><span class="line">2023-01-18 16:49:59.757 7083-7083/com.omosoft.hudinterface I/Process: Sending signal. PID: 7083 SIG: 9</span><br></pre></td></tr></table></figure>

<h2 id="注册native方法失败，so加载失败"><a href="#注册native方法失败，so加载失败" class="headerlink" title="注册native方法失败，so加载失败"></a>注册native方法失败，so加载失败</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">2023-01-18 02:02:54.831 E/ft.hudinterfac: ----- class &#x27;Lcom/chinatsp/iscmanager/ISCManager;&#x27; cl=0x1334aca8 -----</span><br><span class="line">      objectSize=248 (224 from super)</span><br><span class="line">      access=0x8008.0001</span><br><span class="line">      super=&#x27;java.lang.Class&lt;java.lang.Object&gt;&#x27; (cl=0x0)</span><br><span class="line">      vtable (4 entries, 11 in super):</span><br><span class="line">         0: void com.chinatsp.iscmanager.ISCManager.finalize()</span><br><span class="line">         1: int com.chinatsp.iscmanager.ISCManager.openChannel(int)</span><br><span class="line">         2: void com.chinatsp.iscmanager.ISCManager.registerCallback(com.chinatsp.iscmanager.IRecvMsgListener)</span><br><span class="line">         3: int com.chinatsp.iscmanager.ISCManager.sendMessage(int, byte[], int)</span><br><span class="line">      direct methods (9 entries):</span><br><span class="line">         0: void com.chinatsp.iscmanager.ISCManager.&lt;clinit&gt;()</span><br><span class="line">         1: void com.chinatsp.iscmanager.ISCManager.&lt;init&gt;()</span><br><span class="line">         2: void com.chinatsp.iscmanager.ISCManager.HandleReceMsg()</span><br><span class="line">         3: void com.chinatsp.iscmanager.ISCManager.nativeClassInit()</span><br><span class="line">         4: void com.chinatsp.iscmanager.ISCManager.nativeInit()</span><br><span class="line">         5: int com.chinatsp.iscmanager.ISCManager.nativeOpenChannel(int)</span><br><span class="line">         6: void com.chinatsp.iscmanager.ISCManager.nativeRegisterCallback()</span><br><span class="line">         7: void com.chinatsp.iscmanager.ISCManager.nativeRelease()</span><br><span class="line">         8: int com.chinatsp.iscmanager.ISCManager.nativeSendMessage(int, byte[], int)</span><br><span class="line">      instance fields (3 entries):</span><br><span class="line">         0: java.util.concurrent.Semaphore com.chinatsp.iscmanager.ISCManager.mMsgSign</span><br><span class="line">         1: com.chinatsp.iscmanager.IRecvMsgListener com.chinatsp.iscmanager.ISCManager.mRecvListener</span><br><span class="line">         2: java.util.List com.chinatsp.iscmanager.ISCManager.m_messageList</span><br><span class="line">2023-01-18 02:02:54.831 E/ft.hudinterfac: Failed to register native method com.chinatsp.iscmanager.ISCManager.nativeCloseChannel(I)I in /system/app/HUDManagerTest/HUDManagerTest.apk</span><br><span class="line">2023-01-18 02:02:55.057 A/ft.hudinterfac: runtime.cc:655] Runtime aborting...</span><br></pre></td></tr></table></figure>

<p>从log看就是在jni注册方法时，找不到对应方法，但这个类种是有这个方法，并且方法名、参数、返回值都是匹配的。<br>后面反编译对应的apk发现，反编译出来的apk中的class确实没有对应的方法。<br>因为Android.bp进行编译时，APP默认是会优化代码，没有调用的方法都会被移除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimize.enabled bool, If false, disable all optimization. Defaults to true for android_app and android_test modules, false for java_library and java_test modules.</span><br></pre></td></tr></table></figure>

<p>解决方法，在jar包中显示调用未使用的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void avoidOptimize() &#123;</span><br><span class="line">    if (mISCManager == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //显示调用一些unused的方法，避免三方APP编译时优化移除字段和方法，导致jni注册失败</span><br><span class="line">    try &#123;</span><br><span class="line">        //避免三方app编译优化时，移除mNativeContext，导致jni初始化失败</span><br><span class="line">        Field mNativeContextField = ISCManager.class.getDeclaredField(&quot;mNativeContext&quot;);</span><br><span class="line">        mNativeContextField.setAccessible(true);</span><br><span class="line">        Object nativeContext = mNativeContextField.get(mISCManager);</span><br><span class="line">        Log.d(TAG, &quot;nativeContext: &quot; + nativeContext);</span><br><span class="line">    &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    mISCManager.unregisterCallback();</span><br><span class="line">    mISCManager.transmitMsgFromNative(0, null, false);</span><br><span class="line">    mISCManager.closeChannel(CHANNEL_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者APP端禁止代码优化（三方APP无法保证）</p>
<p>另外还可以使用动态jar，避免编译优化代码</p>
<h2 id="Android-Studio-混淆后，类中的私有方法变成了public"><a href="#Android-Studio-混淆后，类中的私有方法变成了public" class="headerlink" title="Android Studio 混淆后，类中的私有方法变成了public"></a>Android Studio 混淆后，类中的私有方法变成了public</h2><p>AS混淆的配置中有一项proguardFiles getDefaultProguardFile(‘proguard-android-optimize.txt’), ‘proguard-rules.pro’，在这里我们会使用android sdk中默认proguard-android-optimize.txt文件。我们可以在Sdk&#x2F;tools&#x2F;proguard路径下找到这个文件。<br>打开该文件可以发现，其中有一项配置“-allowaccessmodification“，这项配置的作用是“是否允许改变作用域“。这也是问题的原因。</p>
<p>方法一：我们可以将proguard-android-optimize.txt文件替换为proguard-android.txt文件，因为在proguard-android.txt中没有-allowaccessmodification配置。</p>
<p>方法二：我们可以去掉getDefaultProguardFile(‘proguard-android-optimize.txt’)，只使用后面自定义的proguard-rules.pro文件。同时，需要在proguard-rules.pro文件中添加自己需要的配置。</p>
<h2 id="记录一次屏保无法退出的现象"><a href="#记录一次屏保无法退出的现象" class="headerlink" title="记录一次屏保无法退出的现象"></a>记录一次屏保无法退出的现象</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>进入屏保页后，点击屏保无响应，无法退出，无法回到桌面，通过adb直接下发指令启动Activity也无法成功（stack 不在栈顶，在栈顶下面一层）</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>后面发现DreamActivity的ActivityType是ACTIVITY_TYPE_DREAM，普通APP的ActivityType是ACTIVITY_TYPE_STANDARD，<br>由于要启动的Activity的栈和顶层栈的类型不同，所以无法打开。</p>
<p>但是DreamService中实现了Window.Callback，并将DreamActivity的Window.Callback设置成了DreamService，<br>而DreamService实现的Window.Callback,对dispatchTouchEvent做了处理，会去调用wakeUp()退出屏保，所以正常情况下，触摸屏幕就会退出屏保。</p>
<p>最后发现有其他进程在打开屏保时，刚好去唤醒屏幕，将DreamService中的mFinished标志置为了true，<br>后续屏保页成功显示后，由于mFinished已经置为true，执行解锁时无法进入解锁逻辑。屏保一直无法退出。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>DreamService中添加字段mActivityCreated记录屏保页是否成功启动，未启动前不执行解锁操作</p>
<p>具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//flag add by LiFeifei to check DreamActivity is created</span><br><span class="line">private boolean mActivityCreated = false;</span><br><span class="line"></span><br><span class="line">public final void finish() &#123;</span><br><span class="line">    if (mDebug) Slog.v(TAG, &quot;finish(): mFinished=&quot; + mFinished);</span><br><span class="line"></span><br><span class="line">    // add by LiFeifei START (if DreamActivity haven&#x27;t created,ignore finish)</span><br><span class="line">    Slog.d(TAG,&quot;finish activity=&quot; + mActivity);</span><br><span class="line">    if (!mActivityCreated) &#123;</span><br><span class="line">        Slog.d(TAG,&quot;activity not created yet, abort finish.&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // add by Lifeifei END</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /** @hide */</span><br><span class="line">    void onActivityCreated(DreamActivity a) &#123;</span><br><span class="line">        mActivity = a;</span><br><span class="line">        onWindowCreated(a.getWindow());</span><br><span class="line"></span><br><span class="line">        //add by Lifeifei START, mark DreamActivity create success</span><br><span class="line">        Slog.d(TAG,&quot;onActivityCreated&quot;);</span><br><span class="line">        mActivityCreated = true;</span><br><span class="line">        //add by Lifeifei END</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="FileObserver"><a href="#FileObserver" class="headerlink" title="FileObserver"></a>FileObserver</h2><p>问题现象：<br>使用FileObserver观察系统中DCIM目录下的一个文件夹中的文件，调用FileObserver.startWatching进行观察后，在目标文件夹中文件被增删后没有回调事件，是个偶现问题，测试在重启车机后恢复，但是升级后首次开机FileObserver没有回调</p>
<p>原因：<br>刷机后观察的目录不存在了，但是相册使用FileObserver前没有判断文件夹是否存在.导致出现了文件更新不回调的问题</p>
<h2 id="Ubuntu下adb报权限问题"><a href="#Ubuntu下adb报权限问题" class="headerlink" title="Ubuntu下adb报权限问题"></a>Ubuntu下adb报权限问题</h2><p>adb devices<br>no permissions (missing udev rules? user is in the plugdev group); see [<a target="_blank" rel="noopener" href="http://developer.android.com/tools/device.html]">http://developer.android.com/tools/device.html]</a></p>
<p>意思是用户在plugdev用户组，但没有设备权限，需要针对这个usb设备配置一下<br>1.查看usb设备的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure>
<p>Bus 001 Device 008: ID 05c6:901d Qualcomm, Inc. SA8155 V2- _SN:<br>其中ID后面是dVendor和idProduct，分别代表厂商号和产品号<br>2.在目录&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;下添加文件70-android.rules，并在文件中添加如下内容：</p>
<p>SUBSYSTEM&#x3D;&#x3D;”usb”, ATTRS{idVendor}&#x3D;&#x3D;”05c6”, ATTRS{idProduct}&#x3D;&#x3D;”901d”,MODE&#x3D;”0666”</p>
<h2 id="记录一下u0-u10进程"><a href="#记录一下u0-u10进程" class="headerlink" title="记录一下u0 u10进程"></a>记录一下u0 u10进程</h2><p>persist 属性 的APP 会被systemserver 拉起来，但是uid是0。</p>
<p>启动u10下的进程，</p>
<ol>
<li>APP可以在u0进程中去指定以u10启动service</li>
<li>APP自己处理，监听开机广播，启动u10下APP进程的service</li>
<li>也可以等其他u10下的进程来启动它的service，这样也可以拉起来</li>
</ol>
<p>只想在u10下自启，需要监听开机广播，收到广播后启动service; 或者等其它u10进程来启动它的service</p>
<h2 id="APP的uid发生变化"><a href="#APP的uid发生变化" class="headerlink" title="APP的uid发生变化"></a>APP的uid发生变化</h2><p>现象：app无法访问sd卡下私有目录的文件</p>
<p>直接原因是，app的uid和对应sd卡私有目录下的文件用户不一致，app的uid发生了变化</p>
<p>移除了原预置APP，重新手动安装，导致APP 的UID发生了变化,</p>
<p>关键log：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System package xxx no longer exists; it&#x27;s data will be wiped</span><br></pre></td></tr></table></figure>

<p>移除system app后重启，开机时PMS会去清除无效的package，删除原来的私有目录，但sd卡还未挂载成功，没有清除。<br>重新手动安装会生成新的uid，<br>但如果覆盖安装就不会。</p>
<h2 id="记录一次Binder通信异常"><a href="#记录一次Binder通信异常" class="headerlink" title="记录一次Binder通信异常"></a>记录一次Binder通信异常</h2><p>log中看到System Server向APP发送广播失败了，然后将APP强杀了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">03-25 14:20:30.976 23014 23044 E JavaBinder: !!! FAILED BINDER TRANSACTION !!!  (parcel size = 612)</span><br><span class="line">03-25 14:20:30.977 23014 23044 W BroadcastQueue: Can&#x27;t deliver broadcast to com.tinnove.aiassistant (pid 27204). Crashing it.</span><br><span class="line">03-25 14:20:30.977 23014 23044 E JavaBinder: !!! FAILED BINDER TRANSACTION !!!  (parcel size = 132)</span><br><span class="line">03-25 14:20:30.977 26121 26134 D VehicleNetworkService.Utils: isNetworkAvailable result:true</span><br><span class="line">03-25 14:20:30.977 23014 23044 I ActivityManagerService: Killing 27204:com.tinnove.aiassistant/u10s1000 (adj 100): scheduleCrash for &#x27;can&#x27;t deliver broadcast&#x27; failed</span><br><span class="line">03-25 14:20:30.977 23014 23044 I ProcessList: note: ProcessRecord&#123;3c83f48 27204:com.tinnove.aiassistant/u10s1000&#125; is being killed, reason: 4, sub-reason: 0, message: scheduleCrash for &#x27;can&#x27;t deliver broadcast&#x27; failed</span><br><span class="line">03-25 14:20:30.978 23014 23044 I am_kill : [10,27204,com.tinnove.aiassistant,100,scheduleCrash for &#x27;can&#x27;t deliver broadcast&#x27; failed]</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: Failure sending broadcast Intent &#123; act=android.net.conn.CONNECTIVITY_CHANGE flg=0x4200010 (has extras) &#125;</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: android.os.DeadObjectException: Transaction failed on small parcel; remote process probably died</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at android.os.BinderProxy.transactNative(Native Method)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at android.os.BinderProxy.transact(BinderProxy.java:550)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at android.app.IApplicationThread$Stub$Proxy.scheduleRegisteredReceiver(IApplicationThread.java:1723)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at com.android.server.am.BroadcastQueue.performReceiveLocked(BroadcastQueue.java:580)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at com.android.server.am.BroadcastQueue.deliverToRegisteredReceiverLocked(BroadcastQueue.java:810)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at com.android.server.am.BroadcastQueue.processNextBroadcastLocked(BroadcastQueue.java:991)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at com.android.server.am.BroadcastQueue.processNextBroadcast(BroadcastQueue.java:950)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at com.android.server.am.BroadcastQueue$BroadcastHandler.handleMessage(BroadcastQueue.java:190)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at android.os.Looper.loop(Looper.java:223)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at android.os.HandlerThread.run(HandlerThread.java:67)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at com.android.server.ServiceThread.run(ServiceThread.java:44)</span><br></pre></td></tr></table></figure>

<p>从log来看就是Binder通信失败了，导致广播无法分发到指定的APP，AMS将APP直接kill掉了。</p>
<p>搜索关键字<code>binder  :</code>或者<code>transaction failed</code>,查看内核打印的binder信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">行 8675 : 03-25 14:20:30.188 0 0 I binder : 23014:23038 transaction failed 29201/-28, size 80-0 line 2879</span><br><span class="line">行 8593 : 03-25 14:20:30.134 0 0 I binder : 23014:23038 transaction failed 29201/-28, size 656-16 line 2879</span><br><span class="line">行 8545 : 03-25 14:20:30.096 0 0 I binder : 23014:23038 transaction failed 29201/-28, size 2284-8 line 2879</span><br><span class="line">行 8542 : 03-25 14:20:30.093 0 0 I binder : 23014:23038 transaction failed 29201/-28, size 2272-8 line 2879</span><br><span class="line">行 8541 : 03-25 14:20:30.083 0 0 I binder : 23014:23038 transaction failed 29201/-28, size 88-0 line 2879</span><br><span class="line">行 8536 : 03-25 14:20:30.081 0 0 I binder : 23014:23038 transaction failed 29201/-28, size 88-0 line 2879</span><br><span class="line">行 8322 : 03-25 14:20:29.774 0 0 I binder : 23014:32027 transaction failed 29201/-28, size 264-8 line 2879</span><br><span class="line"></span><br><span class="line">#log对应源码</span><br><span class="line">binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,</span><br><span class="line">		     &quot;%d:%d transaction failed %d/%d, size %lld-%lld line %d\n&quot;,</span><br><span class="line">		     proc-&gt;pid, thread-&gt;pid, return_error, return_error_param,</span><br><span class="line">		     (u64)tr-&gt;data_size, (u64)tr-&gt;offsets_size,</span><br><span class="line">		     return_error_line);</span><br></pre></td></tr></table></figure>
<p>即 进程pid:线程id 交互失败 错误码，数据大小-数据偏移，报错行。</p>
<p>发现返回的错误码都是29201&#x2F;-28，错误行2879，查看对应binder.c源码的对应行,查看上下逻辑，发现是binder_alloc_new_buf异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;buffer = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size,</span><br><span class="line">	tr-&gt;offsets_size, extra_buffers_size,</span><br><span class="line">	!reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY), current-&gt;tgid);</span><br><span class="line">if (IS_ERR(t-&gt;buffer)) &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * -ESRCH indicates VMA cleared. The target is dying.</span><br><span class="line">	 */</span><br><span class="line">	return_error_param = PTR_ERR(t-&gt;buffer);</span><br><span class="line">	return_error = return_error_param == -ESRCH ?</span><br><span class="line">		BR_DEAD_REPLY : BR_FAILED_REPLY;</span><br><span class="line">	return_error_line = __LINE__;</span><br><span class="line">	t-&gt;buffer = NULL;</span><br><span class="line">	goto err_binder_alloc_buf_failed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续查看binder_alloc_new_buf，调用的binder_alloc.c中的<code>binder_alloc_new_buf_locked</code>,<br>尝试搜索<code>binder_alloc</code>关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">行 36078 : 03-25 14:20:08.307 0 0 I binder_alloc: 27204: pid 22973 spamming oneway? 41 buffers allocated for a total size of 293560</span><br><span class="line">行 36153 : 03-25 14:20:08.425 0 0 I binder_alloc: 27204: pid 22973 spamming oneway? 42 buffers allocated for a total size of 300720</span><br><span class="line">行 36269 : 03-25 14:20:08.627 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 224 buffers allocated for a total size of 122056</span><br><span class="line">行 36276 : 03-25 14:20:08.631 0 0 I binder_alloc: 27204: pid 22973 spamming oneway? 43 buffers allocated for a total size of 307880</span><br><span class="line">行 36316 : 03-25 14:20:08.684 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 225 buffers allocated for a total size of 122240</span><br><span class="line">行 36321 : 03-25 14:20:08.692 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 226 buffers allocated for a total size of 122616</span><br><span class="line">行 36358 : 03-25 14:20:08.791 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 227 buffers allocated for a total size of 123344</span><br><span class="line">行 36359 : 03-25 14:20:08.792 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 228 buffers allocated for a total size of 124072</span><br><span class="line">行 36360 : 03-25 14:20:08.792 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 229 buffers allocated for a total size of 124800</span><br><span class="line">行 36709 : 03-25 14:20:09.694 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 230 buffers allocated for a total size of 125176</span><br><span class="line">行 38795 : 03-25 14:20:13.707 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 234 buffers allocated for a total size of 126680</span><br><span class="line">行 38965 : 03-25 14:20:14.280 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 235 buffers allocated for a total size of 126864</span><br><span class="line">行 38999 : 03-25 14:20:14.294 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 236 buffers allocated for a total size of 127592</span><br><span class="line">行 39000 : 03-25 14:20:14.295 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 237 buffers allocated for a total size of 128320</span><br><span class="line">行 39001 : 03-25 14:20:14.296 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 238 buffers allocated for a total size of 129048</span><br><span class="line">行 39412 : 03-25 14:20:14.710 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 239 buffers allocated for a total size of 129424</span><br><span class="line">行 40175 : 03-25 14:20:15.714 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 240 buffers allocated for a total size of 129800</span><br></pre></td></tr></table></figure>
<p>发现打印了如上的log，找到对应打印log的源码,发现当进程持有的事务超过50或分配的异步空间超过了50%（总空间的25%，大概250K），就会打印这个log：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Warn if this pid has more than 50 transactions, or more than 50% of</span><br><span class="line"> * async space (which is 25% of total buffer size).</span><br><span class="line"> */</span><br><span class="line">if (num_buffers &gt; 50 || total_alloc_size &gt; alloc-&gt;buffer_size / 4) &#123;</span><br><span class="line">	binder_alloc_debug(BINDER_DEBUG_USER_ERROR,</span><br><span class="line">		     &quot;%d: pid %d spamming oneway? %zd buffers allocated for a total size of %zd\n&quot;,</span><br><span class="line">		      alloc-&gt;pid, pid, num_buffers, total_alloc_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从log上看<br>22973进程发给27204的事务有43个，占了307880字节<br>23014进程发给27204的事务有240个，占了129800字节</p>
<p>在这里衍生一个知识点，oneway binder在server端只有一个线程在执行，具体的可以看驱动代码</p>
<p>异步事务最大的空间是总buffer的一半，大概500k,</p>
<p>但是从log中看异步事务一直在增长，也就是binder的server端（27204进程）一直没处理完事务，可能是在某个事务中阻塞了.<br>本地复现:<br>重复注册oneway的callback，在oneway回调的接口做耗时操作。</p>
<p>所以问题原因可能是三方APP同一个接口多个地方注册了多个回调，导致每次binder回调多次分配buffer，<br>并且app在回调中作了耗时操作，buffer没能及时释放，迅速占满缓冲区。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/over_qqqq/article/details/114108877">https://blog.csdn.net/over_qqqq/article/details/114108877</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/liaosongmao1/article/details/124842622">https://blog.csdn.net/liaosongmao1/article/details/124842622</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weiqifa0/article/details/100570446">https://blog.csdn.net/weiqifa0/article/details/100570446</a></p>
<h2 id="SQL-error-code-10-disk-I-O-error-extendcode-6410"><a href="#SQL-error-code-10-disk-I-O-error-extendcode-6410" class="headerlink" title="SQL error,code[10]: disk I&#x2F;O error,extendcode[6410]"></a>SQL error,code[10]: disk I&#x2F;O error,extendcode[6410]</h2><p>三方APP错误信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IMP AutoSDK: 2023/04/04 19:14:20 [21724] [SL_Database.cpp:329] SQL error,code[10]: disk I/O error,extendcode[6410], sql=CREATE TABLE IF NOT EXISTS NisBaseLinkGeo(Id INTEGER,Version INTEGER,Crc32c INTEGER NULL,BaseLinkGeoTile BLOB,primary key (id))</span><br><span class="line">IMP AutoSDK: 2023/04/04 19:14:20 [21724] [SL_TableWrtBase.cpp:20] 创建表失败 CREATE TABLE IF NOT EXISTS NisBaseLinkGeo(Id INTEGER,Version INTEGER,Crc32c INTEGER NULL,BaseLinkGeoTile BLOB,primary key (id))</span><br></pre></td></tr></table></figure>

<p>数据库错误，错误信息是disk I&#x2F;O error，对应错误码是10，对应的扩展错误码是6410</p>
<p>错误码定义在&#96;&#96;&#96;sqlite3.h&#96;&#96;中，可以参考：<a target="_blank" rel="noopener" href="http://sqlite.org/c3ref/c_abort_rollback.html">http://sqlite.org/c3ref/c_abort_rollback.html</a></p>
<p>IO错误找对应的SQLITE_IOERR，宏定义为10，扩展码是 (错误码|num &lt;&lt; 8), 6410-10 再 右移 8 位就知道对应的num了，也就是6400&#x2F;256&#x3D;25，</p>
<p>对应<code>#define SQLITE_IOERR_GETTEMPPATH       (SQLITE_IOERR | (25&lt;&lt;8))</code></p>
<p>所以返回的SQLITE_IOERR_GETTEMPPATH错误，查看对应源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zDir = unixTempFileDir();</span><br><span class="line">if( zDir==0 ) return SQLITE_IOERR_GETTEMPPATH;</span><br></pre></td></tr></table></figure>

<p>可以看一下 unixTempFileDir 这个函数的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static const char *unixTempFileDir(void)&#123;</span><br><span class="line">  static const char *azDirs[] = &#123;</span><br><span class="line">     0,</span><br><span class="line">     0,</span><br><span class="line">     &quot;/var/tmp&quot;,</span><br><span class="line">     &quot;/usr/tmp&quot;,</span><br><span class="line">     &quot;/tmp&quot;,</span><br><span class="line">     &quot;.&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">  unsigned int i = 0;</span><br><span class="line">  struct stat buf;</span><br><span class="line">  const char *zDir = sqlite3_temp_directory;</span><br><span class="line"></span><br><span class="line">  if( !azDirs[0] ) azDirs[0] = getenv(&quot;SQLITE_TMPDIR&quot;);</span><br><span class="line">  if( !azDirs[1] ) azDirs[1] = getenv(&quot;TMPDIR&quot;);</span><br><span class="line">  while(1)&#123;</span><br><span class="line">    if( zDir!=0</span><br><span class="line">     &amp;&amp; osStat(zDir, &amp;buf)==0</span><br><span class="line">     &amp;&amp; S_ISDIR(buf.st_mode)</span><br><span class="line">     &amp;&amp; osAccess(zDir, 03)==0</span><br><span class="line">    )&#123;</span><br><span class="line">      return zDir;</span><br><span class="line">    &#125;</span><br><span class="line">    if( i&gt;=sizeof(azDirs)/sizeof(azDirs[0]) ) break;</span><br><span class="line">    zDir = azDirs[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就是用数组存放了一系列可以作为临时目录的路径，依次是：</p>
<ul>
<li><code>$SQLITE_TMPDIR</code></li>
<li><code>$TMPDIR</code></li>
<li><code>/var/tmp</code></li>
<li><code>/usr/tmp</code></li>
<li><code>/tmp</code></li>
<li><code>.</code></li>
</ul>
<p>然后依次校验：<br>文件存在 &amp;&amp; 可以获取到文件的元数据 &amp;&amp; 是一个目录 &amp;&amp; 目录有访问权限</p>
<p>如果环境变量没有设置临时路径，Android中会走到当前目录，这个报错的原因应该就是当前目录没有权限。<br>后续写了个测试程序，在app中执行shell指令获取当前路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">execShell(&quot;echo $SQLITE_TMPDIR&quot;);</span><br><span class="line">execShell(&quot;echo $TMPDIR&quot;);</span><br><span class="line">execShell(&quot;pwd&quot;);</span><br><span class="line">execShell(&quot;whoami&quot;);</span><br><span class="line"></span><br><span class="line">private void execShell(String cmd) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Process process = Runtime.getRuntime().exec(new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, cmd&#125;);</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        char[] buff = new char[1024];</span><br><span class="line">        int ch = 0;</span><br><span class="line">        while ((ch = bufferedReader.read(buff)) != -1) &#123;</span><br><span class="line">            stringBuilder.append(buff, 0, ch);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        Log.d(TAG, &quot;cmd [&quot;+cmd+&quot;] execute result: &quot;+stringBuilder.toString());</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmd [echo $SQLITE_TMPDIR] execute result: </span><br><span class="line">cmd [echo $TMPDIR] execute result: </span><br><span class="line">cmd [pwd] execute result: /</span><br><span class="line">cmd [whoami] execute result: u10_a33</span><br></pre></td></tr></table></figure>

<p>根目录确实没有写的权限,</p>
<p>所以只需要设置一下环境变量就好,<code>SQLITE_TMPDIR</code>和<code>TMPDIR</code>任意设置一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Os.setenv(&quot;SQLITE_TMPDIR&quot;, &quot;/data/data/custom&quot;, false);</span><br><span class="line">    Os.setenv(&quot;TMPDIR&quot;, &quot;/data/data/tmp&quot;, false);</span><br><span class="line">&#125; catch (ErrnoException e) &#123;</span><br><span class="line">    throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="startActivity抛异常"><a href="#startActivity抛异常" class="headerlink" title="startActivity抛异常"></a>startActivity抛异常</h2><p>startActivity会调用 mMainThread.getInstrumentation().execStartActivity<br>方法内部会去checkStartActivityResult，根据错误码抛异常<br>而startActivityAsUser直接调用ActivityTaskManager.getService().startActivityAsUser，不会针对错误码抛异常</p>
<h2 id="startService-U10-not-found"><a href="#startService-U10-not-found" class="headerlink" title="startService U10 not found"></a>startService U10 not found</h2><p>现象：persist进程开机无法启动自己u10下的服务。<br>解决方案： 给组件加上 <code>android:directBootAware=&quot;true&quot;</code>  或者 直接在 application标签中加上&#96;&#96;&#96;android:directBootAware&#x3D;”true”&#96;&#96;</p>
<p>ActiveServices:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ResolveInfo rInfo = mAm.getPackageManagerInternalLocked().resolveService(service,</span><br><span class="line">                        resolvedType, flags, userId, callingUid);</span><br><span class="line">ServiceInfo sInfo = rInfo != null ? rInfo.serviceInfo : null;</span><br><span class="line">if (sInfo == null) &#123;</span><br><span class="line">    Slog.w(TAG_SERVICE, &quot;Unable to start service &quot; + service + &quot; U=&quot; + userId +</span><br><span class="line">          &quot;: not found&quot;);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PackageManagerService:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private ResolveInfo resolveServiceInternal(Intent intent, String resolvedType, int flags,</span><br><span class="line">            int userId, int callingUid) &#123;</span><br><span class="line">    //...</span><br><span class="line">    List&lt;ResolveInfo&gt; query = queryIntentServicesInternal(</span><br><span class="line">            intent, resolvedType, flags, userId, callingUid, false /*includeInstantApps*/);</span><br><span class="line">    Slog.e(&quot;custom_debug&quot;, &quot;List&lt;ResolveInfo&gt; = &quot;+query);</span><br><span class="line">    if (query != null) &#123;</span><br><span class="line">        Slog.e(&quot;custom_debug&quot;, &quot;List&lt;ResolveInfo&gt; size = &quot;+query.size());</span><br><span class="line">        if (query.size() &gt;= 1) &#123;</span><br><span class="line">            // If there is more than one service with the same priority,</span><br><span class="line">            // just arbitrarily pick the first one.</span><br><span class="line">            return query.get(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private @NonNull List&lt;ResolveInfo&gt; queryIntentServicesInternal(Intent intent,</span><br><span class="line">      String resolvedType, int flags, int userId, int callingUid,</span><br><span class="line">      boolean includeInstantApps) &#123;</span><br><span class="line"></span><br><span class="line">      //...</span><br><span class="line">      final ServiceInfo si = getServiceInfo(comp, flags, userId);</span><br><span class="line">      //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ServiceInfo getServiceInfo(ComponentName component, int flags, int userId) &#123;</span><br><span class="line">  //...</span><br><span class="line">          if (mSettings.isEnabledAndMatchLPr(pkg, s, flags, userId)) &#123;</span><br><span class="line">              //...</span><br><span class="line">          &#125;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Settings:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boolean isEnabledAndMatchLPr(ComponentInfo componentInfo, int flags, int userId) &#123;</span><br><span class="line">    final PackageSetting ps = mPackages.get(componentInfo.packageName);</span><br><span class="line">    if (ps == null) return false;</span><br><span class="line"></span><br><span class="line">    final PackageUserState userState = ps.readUserState(userId);</span><br><span class="line">    return userState.isMatch(componentInfo, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PackageUserState:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatch(boolean isSystem, boolean isPackageEnabled, boolean isComponentEnabled,</span><br><span class="line">            boolean isComponentDirectBootAware, String componentName, int flags) &#123;</span><br><span class="line">    final boolean matchUninstalled = (flags &amp; PackageManager.MATCH_KNOWN_PACKAGES) != 0;</span><br><span class="line">    if (!isAvailable(flags) &amp;&amp; !(isSystem &amp;&amp; matchUninstalled)) &#123;</span><br><span class="line">        return reportIfDebug(false, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!isEnabled(isPackageEnabled, isComponentEnabled, componentName, flags)) &#123;</span><br><span class="line">        return reportIfDebug(false, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((flags &amp; MATCH_SYSTEM_ONLY) != 0) &#123;</span><br><span class="line">        if (!isSystem) &#123;</span><br><span class="line">            return reportIfDebug(false, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //关键看这里</span><br><span class="line">    final boolean matchesUnaware = ((flags &amp; MATCH_DIRECT_BOOT_UNAWARE) != 0)</span><br><span class="line">            &amp;&amp; !isComponentDirectBootAware;</span><br><span class="line">    final boolean matchesAware = ((flags &amp; MATCH_DIRECT_BOOT_AWARE) != 0)</span><br><span class="line">            &amp;&amp; isComponentDirectBootAware;</span><br><span class="line">    Slog.e(&quot;custom_debug&quot;,&quot;isComponentDirectBootAware = &quot;+isComponentDirectBootAware+&quot;,&quot; +</span><br><span class="line">            &quot;matchesUnaware = &quot;+matchesUnaware+&quot;, matchesAware = &quot;+ matchesAware);</span><br><span class="line">    //matchesUnaware 或 matchesAware 任意一个满足就返回match</span><br><span class="line">    //而flags肯定包含MATCH_DIRECT_BOOT_AWARE，所以只要isComponentDirectBootAware为true就满足matchesAware</span><br><span class="line">    return reportIfDebug(matchesUnaware || matchesAware, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flags可以看 pms中的 updateFlags() updateFlagsForComponent()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Update given flags based on encryption status of current user.</span><br><span class="line"> */</span><br><span class="line">private int updateFlags(int flags, int userId) &#123;</span><br><span class="line">    if ((flags &amp; (PackageManager.MATCH_DIRECT_BOOT_UNAWARE</span><br><span class="line">            | PackageManager.MATCH_DIRECT_BOOT_AWARE)) != 0) &#123;</span><br><span class="line">        // Caller expressed an explicit opinion about what encryption</span><br><span class="line">        // aware/unaware components they want to see, so fall through and</span><br><span class="line">        // give them what they want</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Caller expressed no opinion, so match based on user state</span><br><span class="line">        if (mUserManager.isUserUnlockingOrUnlocked(userId)) &#123;</span><br><span class="line">            flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="编译AndroidSDK报错"><a href="#编译AndroidSDK报错" class="headerlink" title="编译AndroidSDK报错"></a>编译AndroidSDK报错</h2><p>由于framework中引入了新的字体，编译sdk时，一直报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;PYTHONPATH=\$PYTHONPATH:external/fonttools/Lib frameworks/layoutlib/rename_font/build_font_single.py out/target/product/msmnile_gvmq/system/fonts/Alibaba-PuHuiTi-Bold.ttf out/host/common/obj/PACKAGING/sdk-fonts_intermediates/Alibaba-PuHuiTi-Bold.ttf&quot;</span><br><span class="line">Converting font: Alibaba-PuHuiTi-Bold.ttf</span><br><span class="line">ERROR: Unhandled exception has occurred</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttx.py&quot;, line 401, in main</span><br><span class="line">    process(jobs, options)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttx.py&quot;, line 375, in process</span><br><span class="line">    action(input, output, options)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/misc/loggingTools.py&quot;, line 375, in wrapper</span><br><span class="line">    return func(*args, **kwds)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttx.py&quot;, line 272, in ttDump</span><br><span class="line">    newlinestr=options.newlinestr)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 228, in saveXML</span><br><span class="line">    self._saveXML(writer, **kwargs)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 283, in _saveXML</span><br><span class="line">    self._tableToXML(tableWriter, tag, splitGlyphs=splitGlyphs)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 314, in _tableToXML</span><br><span class="line">    table.toXML(writer, self)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/tables/S_V_G_.py&quot;, line 275, in toXML</span><br><span class="line">    for doc, startGID, endGID in self.docList:</span><br><span class="line">TypeError: &#x27;NoneType&#x27; object is not iterable</span><br></pre></td></tr></table></figure>

<p>看着是S_V_G_.py中报错了，self.docList是空的,加<code>if self.docList is not None:</code>进行判断，但还是报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;PYTHONPATH=\$PYTHONPATH:external/fonttools/Lib frameworks/layoutlib/rename_font/build_font_single.py out/target/product/msmnile_gvmq/system/fonts/Alibaba-PuHuiTi-Regular.ttf out/host/common/</span><br><span class="line">obj/PACKAGING/sdk-fonts_intermediates/Alibaba-PuHuiTi-Regular.ttf&quot;</span><br><span class="line">ERROR: Unhandled exception has occurred</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttx.py&quot;, line 401, in main</span><br><span class="line">    process(jobs, options)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttx.py&quot;, line 375, in process</span><br><span class="line">    action(input, output, options)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/misc/loggingTools.py&quot;, line 375, in wrapper</span><br><span class="line">    return func(*args, **kwds)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttx.py&quot;, line 293, in ttCompile</span><br><span class="line">    ttf.save(output)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 173, in save</span><br><span class="line">    writer_reordersTables = self._save(tmp)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 212, in _save</span><br><span class="line">    self._writeTable(tag, writer, done, tableCache)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 633, in _writeTable</span><br><span class="line">    tabledata = self.getTableData(tag)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 651, in getTableData</span><br><span class="line">    return self.tables[tag].compile(self)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/tables/S_V_G_.py&quot;, line 192, in compile</span><br><span class="line">    data = self.compileFormat0(ttFont)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/tables/S_V_G_.py&quot;, line 201, in compileFormat0</span><br><span class="line">    numEntries = len(self.docList)</span><br><span class="line">AttributeError: &#x27;table_S_V_G_&#x27; object has no attribute &#x27;docList&#x27;</span><br></pre></td></tr></table></figure>
<p>继续加异常判断：<code>if hasattr(self, &quot;docList&quot;):</code></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>View带有FITS_SYSTEM_WINDOWS flag 会applyInsets</p>
<h2 id="后台启动Activity"><a href="#后台启动Activity" class="headerlink" title="后台启动Activity"></a>后台启动Activity</h2><p>被前台app bind的service可以在后台启动activity</p>
<h2 id="Home回到主页后，后台启动Activity延迟"><a href="#Home回到主页后，后台启动Activity延迟" class="headerlink" title="Home回到主页后，后台启动Activity延迟"></a>Home回到主页后，后台启动Activity延迟</h2><p>原生机制，回到主页后5s内没有STOP_APP_SWITCHES权限的app，不会立即响应startActivity</p>
<p>在ActivityStarter的executeRequest中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// If we are starting an activity that is not from the same uid as the currently resumed</span><br><span class="line">// one, check whether app switches are allowed.</span><br><span class="line">if (voiceSession == null &amp;&amp; stack != null &amp;&amp; (stack.getResumedActivity() == null</span><br><span class="line">        || stack.getResumedActivity().info.applicationInfo.uid != realCallingUid)) &#123;</span><br><span class="line">    //这里会去检查是否有appswitch的权限</span><br><span class="line">    if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,</span><br><span class="line">            realCallingPid, realCallingUid, &quot;Activity start&quot;)) &#123;</span><br><span class="line">        if (!(restrictedBgActivity &amp;&amp; handleBackgroundActivityAbort(r))) &#123;</span><br><span class="line">            mController.addPendingActivityLaunch(new PendingActivityLaunch(r,</span><br><span class="line">                    sourceRecord, startFlags, stack, callerApp, intentGrants));</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityOptions.abort(checkedOptions);</span><br><span class="line">        return ActivityManager.START_SWITCHES_CANCELED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ATMS中checkAppSwitchAllowedLocked：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">boolean checkAppSwitchAllowedLocked(int sourcePid, int sourceUid,</span><br><span class="line">        int callingPid, int callingUid, String name) &#123;</span><br><span class="line">    //判断当前时间是否已经到达允许普通app进行app切换的时间</span><br><span class="line">    if (mAppSwitchesAllowedTime &lt; SystemClock.uptimeMillis()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (getRecentTasks().isCallerRecents(sourceUid)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里检查STOP_APP_SWITCHES权限</span><br><span class="line">    int perm = checkComponentPermission(STOP_APP_SWITCHES, sourcePid, sourceUid, -1, true);</span><br><span class="line">    if (perm == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (checkAllowAppSwitchUid(sourceUid)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the actual IPC caller is different from the logical source, then</span><br><span class="line">    // also see if they are allowed to control app switches.</span><br><span class="line">    if (callingUid != -1 &amp;&amp; callingUid != sourceUid) &#123;</span><br><span class="line">        perm = checkComponentPermission(STOP_APP_SWITCHES, callingPid, callingUid, -1, true);</span><br><span class="line">        if (perm == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (checkAllowAppSwitchUid(callingUid)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Slog.w(TAG, name + &quot; request from &quot; + sourceUid + &quot; stopped&quot;);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void stopAppSwitches() &#123;</span><br><span class="line">    enforceCallerIsRecentsOrHasPermission(STOP_APP_SWITCHES, &quot;stopAppSwitches&quot;);</span><br><span class="line">    synchronized (mGlobalLock) &#123;</span><br><span class="line">        //每次调用stopAppSwitches时，都会将允许普通app切换的时间延长5s，而源码搜索发现在回到桌面时会调用次方法</span><br><span class="line">        mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + APP_SWITCH_DELAY_TIME;</span><br><span class="line">        mLastStopAppSwitchesTime = SystemClock.uptimeMillis();</span><br><span class="line">        mDidAppSwitch = false;</span><br><span class="line">        getActivityStartController().schedulePendingActivityLaunches(APP_SWITCH_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="onStop在onPause-10s后才回调"><a href="#onStop在onPause-10s后才回调" class="headerlink" title="onStop在onPause 10s后才回调"></a>onStop在onPause 10s后才回调</h2><p>onStop触发的时机，App在onResume之后，会向主线程的MessageQueue中添加一个IdleHandler，在MessageQueue空闲时触发IdleHandler的queueIdle(),<br>在queueIdle()中执行stop事件</p>
<p>在handleResumeActivity中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,</span><br><span class="line">            String reason) &#123;</span><br><span class="line">        //......</span><br><span class="line">        final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">        //......</span><br><span class="line">        //将当前resume的Activity的nextIdle指向之前最新的那个activity</span><br><span class="line">        r.nextIdle = mNewActivities;</span><br><span class="line">        //将最新resume的activity赋值给mNewActivities（链表）</span><br><span class="line">        mNewActivities = r;</span><br><span class="line">        if (localLOGV || enableLifeCycleLog()) Slog.v(TAG, &quot;Scheduling idle handler for &quot; + r);</span><br><span class="line">        Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看queueIdle()做了啥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private class Idler implements MessageQueue.IdleHandler &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public final boolean queueIdle() &#123;</span><br><span class="line">            //取到最新resume的activity</span><br><span class="line">            ActivityClientRecord a = mNewActivities;</span><br><span class="line">            boolean stopProfiling = false;</span><br><span class="line">            if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null</span><br><span class="line">                    &amp;&amp; mProfiler.autoStopProfiler) &#123;</span><br><span class="line">                stopProfiling = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (a != null) &#123;</span><br><span class="line">                mNewActivities = null;</span><br><span class="line">                IActivityTaskManager am = ActivityTaskManager.getService();</span><br><span class="line">                ActivityClientRecord prev;</span><br><span class="line">                //开始遍历resume的activity链表</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (localLOGV || enableLifeCycleLog()) Slog.v(</span><br><span class="line">                        TAG, &quot;Reporting idle of &quot; + a +</span><br><span class="line">                        &quot; finished=&quot; +</span><br><span class="line">                        (a.activity != null &amp;&amp; a.activity.mFinished));</span><br><span class="line">                    //如果resume的activity没有finished，就调用ActivityManagerTaskService的activityIdle</span><br><span class="line">                    if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                            a.createdConfig = null;</span><br><span class="line">                        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                            throw ex.rethrowFromSystemServer();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = a;</span><br><span class="line">                    a = a.nextIdle;</span><br><span class="line">                    prev.nextIdle = null;</span><br><span class="line">                &#125; while (a != null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (stopProfiling) &#123;</span><br><span class="line">                mProfiler.stopProfiling();</span><br><span class="line">            &#125;</span><br><span class="line">            applyPendingProcessState();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接着就到了SystemServer，ATMS的activityIdle中调用的ActivityStackSupervisor的activityIdleInternal，内部又调用了processStoppingAndFinishingActivities，<br>看看processStoppingAndFinishingActivities：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void processStoppingAndFinishingActivities(ActivityRecord launchedActivity,</span><br><span class="line">        boolean processPausingActivities, String reason) &#123;</span><br><span class="line">    //......</span><br><span class="line">    for (int i = 0; i &lt; numReadyStops; i++) &#123;</span><br><span class="line">        final ActivityRecord r = readyToStopActivities.get(i);</span><br><span class="line">        if (r.isInHistory()) &#123;</span><br><span class="line">            //这里判断如果是调用了finish，就会走到destory的逻辑</span><br><span class="line">            if (r.finishing) &#123;</span><br><span class="line">                // TODO(b/137329632): Wait for idle of the right activity, not just any.</span><br><span class="line">                r.destroyIfPossible(reason);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //没有调用finish，就走stop的逻辑</span><br><span class="line">                r.stopIfPossible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //.......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有调用ActivityStackSupervisor.scheduleIdle(),会向handler发送一个空的IDLE_NOW_MSG消息<br>ActivityRecord.addToStopping<br>ActivityRecord.onAnimationFinished</p>
<h2 id="AppWiget刷新UI没变"><a href="#AppWiget刷新UI没变" class="headerlink" title="AppWiget刷新UI没变"></a>AppWiget刷新UI没变</h2><p>刷新appwidget是通过调用AppWidgetManager.updateAppWidget()将RemoteViews传递给AppWidgetHost,在AppWidgetHostView中显示<br>所以数据源是来自于APP传的RemoteViews，UI没变化，就需要APP端排查。<br>出现刷新UI没变化这个问题：<br>app进程crash了，在crash前后重启后传入的RemoteViews的layoutId是一样的，AppWidgetHostView会直接复用之前的layout，所有的子控件状态都是crash前的状态。<br>但是app重启后没有对RemoteViews中的子控件进行初始化操作，部分控件是不可见的，所以刷新后UI没变化。</p>
<h2 id="记录一下关于WindowInsetsController的用法"><a href="#记录一下关于WindowInsetsController的用法" class="headerlink" title="记录一下关于WindowInsetsController的用法"></a>记录一下关于WindowInsetsController的用法</h2><p>WindowInsetsController可以显示隐藏指定的系统窗口,可以通过它实现全屏显示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//隐藏导航栏和状态栏</span><br><span class="line">getWindow().getDecorView().getWindowInsetsController().hide(WindowInsets.Type.navigationBars() | WindowInsets.Type.statusBars());</span><br></pre></td></tr></table></figure>
<p>但默认只要用户有任何交互都会导致隐藏的系统窗口再次显示<br>可以添加加behavior来实现沉浸式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().getWindowInsetsController().setSystemBarsBehavior(WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE);</span><br></pre></td></tr></table></figure>
<p>此外还有其他方式,但最终都是设置的behavior.<br>在ViewRootImpl中的adjustLayoutParamsForCompatibility有如下逻辑:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void adjustLayoutParamsForCompatibility(WindowManager.LayoutParams inOutParams) &#123;</span><br><span class="line">    //......</span><br><span class="line">    //判断是否有调用过setSystemBarsBehavior</span><br><span class="line">    if ((inOutParams.privateFlags &amp; PRIVATE_FLAG_BEHAVIOR_CONTROLLED) == 0) &#123;</span><br><span class="line">        //没有调用过setSystemBarsBehavior,</span><br><span class="line">        //如果有SYSTEM_UI_FLAG_IMMERSIVE_STICKY</span><br><span class="line">        //或者window的glag中有FLAG_FULLSCREEN都会自动设置BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE</span><br><span class="line">        if ((sysUiVis &amp; SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0</span><br><span class="line">                || (flags &amp; FLAG_FULLSCREEN) != 0) &#123;</span><br><span class="line">            inOutParams.insetsFlags.behavior = BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE;</span><br><span class="line">        &#125; else if ((sysUiVis &amp; SYSTEM_UI_FLAG_IMMERSIVE) != 0) &#123;</span><br><span class="line">            inOutParams.insetsFlags.behavior = BEHAVIOR_SHOW_BARS_BY_SWIPE;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //默认behavior就是点击就显示系统窗口</span><br><span class="line">            inOutParams.insetsFlags.behavior = BEHAVIOR_SHOW_BARS_BY_TOUCH;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以可以有另外的方式来实现沉浸式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置SystemUiVisibility来实现沉浸式</span><br><span class="line">getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);</span><br><span class="line">//window添加全屏flag来实现沉浸式 和 在主题中配置 &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; 是一样的</span><br><span class="line">getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);</span><br></pre></td></tr></table></figure>

<h2 id="app切换时，闪其它app页面"><a href="#app切换时，闪其它app页面" class="headerlink" title="app切换时，闪其它app页面"></a>app切换时，闪其它app页面</h2><p>现象：从activity A 启动到 B ，再启动C，finish C后，有时会闪一下A再显示B</p>
<p>排查wm的tag后发现，从A 到 B的过程，A已经不可见了，但是并没有触发A的onStop生命周期，一直处于onPause状态，<br>启动C后，触发了B和A的onStop，finish C时，B和A重走了一次onRestart生命周期。</p>
<p>所以问题点就在A到B的过程，B已经将A遮挡但A还没有走onStop，那说明B有什么配置导致A对用户来说还是可见的，排查后发现B有一个windowIsTranslucent为true的配置</p>
<p>查看ActivityRecord的源码可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ActivityRecord(...)&#123;</span><br><span class="line">    //......</span><br><span class="line">    final AttributeCache.Entry ent = AttributeCache.instance().get(packageName,</span><br><span class="line">            realTheme, com.android.internal.R.styleable.Window, mUserId);</span><br><span class="line"></span><br><span class="line">    if (ent != null) &#123;</span><br><span class="line">        //这里判断了Activity是否是全遮盖的</span><br><span class="line">        mOccludesParent = !ActivityInfo.isTranslucentOrFloating(ent.array);</span><br><span class="line">        hasWallpaper = ent.array.getBoolean(R.styleable.Window_windowShowWallpaper, false);</span><br><span class="line">        noDisplay = ent.array.getBoolean(R.styleable.Window_windowNoDisplay, false);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        hasWallpaper = false;</span><br><span class="line">        noDisplay = false;</span><br><span class="line">    &#125;</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Activity不是全遮盖，下面的Activity就是可见的<br>在ActivityStack的ensureActivitiesVisible中会去调用EnsureActivitiesVisibleHelper的process</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void ensureActivitiesVisible(@Nullable ActivityRecord starting, int configChanges,</span><br><span class="line">        boolean preserveWindows, boolean notifyClients) &#123;</span><br><span class="line">    mTopActivityOccludesKeyguard = false;</span><br><span class="line">    mTopDismissingKeyguardActivity = null;</span><br><span class="line">    mStackSupervisor.beginActivityVisibilityUpdate();</span><br><span class="line">    try &#123;</span><br><span class="line">        mEnsureActivitiesVisibleHelper.process(</span><br><span class="line">                starting, configChanges, preserveWindows, notifyClients);</span><br><span class="line"></span><br><span class="line">        if (mTranslucentActivityWaiting != null &amp;&amp;</span><br><span class="line">                mUndrawnActivitiesBelowTopTranslucent.isEmpty()) &#123;</span><br><span class="line">            // Nothing is getting drawn or everything was already visible, don&#x27;t wait for timeout.</span><br><span class="line">            notifyActivityDrawnLocked(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mStackSupervisor.endActivityVisibilityUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void process(@Nullable ActivityRecord starting, int configChanges, boolean preserveWindows,</span><br><span class="line">        boolean notifyClients) &#123;</span><br><span class="line">    reset(starting, configChanges, preserveWindows, notifyClients);</span><br><span class="line"></span><br><span class="line">    if (DEBUG_VISIBILITY) Slog.v(TAG_VISIBILITY, &quot;ensureActivitiesVisible behind &quot; + mTop</span><br><span class="line">            + &quot; configChanges=0x&quot; + Integer.toHexString(configChanges));</span><br><span class="line">    if (mTop != null) &#123;</span><br><span class="line">        mContiner.checkTranslucentActivityWaiting(mTop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We should not resume activities that being launched behind because these</span><br><span class="line">    // activities are actually behind other fullscreen activities, but still required</span><br><span class="line">    // to be visible (such as performing Recents animation).</span><br><span class="line">    final boolean resumeTopActivity = mTop != null &amp;&amp; !mTop.mLaunchTaskBehind</span><br><span class="line">            &amp;&amp; mContiner.isTopActivityFocusable()</span><br><span class="line">            &amp;&amp; (starting == null || !starting.isDescendantOf(mContiner));</span><br><span class="line"></span><br><span class="line">    final PooledConsumer f = PooledLambda.obtainConsumer(</span><br><span class="line">            EnsureActivitiesVisibleHelper::setActivityVisibilityState, this,</span><br><span class="line">            PooledLambda.__(ActivityRecord.class), starting, resumeTopActivity);</span><br><span class="line">    mContiner.forAllActivities(f);</span><br><span class="line">    f.recycle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reset(ActivityRecord starting, int configChanges, boolean preserveWindows,</span><br><span class="line">        boolean notifyClients) &#123;</span><br><span class="line">    mStarting = starting;</span><br><span class="line">    mTop = mContiner.topRunningActivity();</span><br><span class="line">    // If the top activity is not fullscreen, then we need to make sure any activities under it</span><br><span class="line">    // are now visible.</span><br><span class="line">    mAboveTop = mTop != null;</span><br><span class="line">    mContainerShouldBeVisible = mContiner.shouldBeVisible(mStarting);</span><br><span class="line">    mBehindFullscreenActivity = !mContainerShouldBeVisible;</span><br><span class="line">    mConfigChanges = configChanges;</span><br><span class="line">    mPreserveWindows = preserveWindows;</span><br><span class="line">    mNotifyClients = notifyClients;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>reset中重新判断了task的可见性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">int getVisibility(ActivityRecord starting) &#123;</span><br><span class="line">    if (!isAttached() || isForceHidden()) &#123;</span><br><span class="line">        return STACK_VISIBILITY_INVISIBLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isTopActivityLaunchedBehind()) &#123;</span><br><span class="line">        return STACK_VISIBILITY_VISIBLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean gotSplitScreenStack = false;</span><br><span class="line">    boolean gotOpaqueSplitScreenPrimary = false;</span><br><span class="line">    boolean gotOpaqueSplitScreenSecondary = false;</span><br><span class="line">    boolean gotTranslucentFullscreen = false;</span><br><span class="line">    boolean gotTranslucentSplitScreenPrimary = false;</span><br><span class="line">    boolean gotTranslucentSplitScreenSecondary = false;</span><br><span class="line">    boolean shouldBeVisible = true;</span><br><span class="line"></span><br><span class="line">    // This stack is only considered visible if all its parent stacks are considered visible,</span><br><span class="line">    // so check the visibility of all ancestor stacks first.</span><br><span class="line">    final WindowContainer parent = getParent();</span><br><span class="line">    if (parent.asTask() != null) &#123;</span><br><span class="line">        final int parentVisibility = parent.asTask().getVisibility(starting);</span><br><span class="line">        if (parentVisibility == STACK_VISIBILITY_INVISIBLE) &#123;</span><br><span class="line">            // Can&#x27;t be visible if parent isn&#x27;t visible</span><br><span class="line">            return STACK_VISIBILITY_INVISIBLE;</span><br><span class="line">        &#125; else if (parentVisibility == STACK_VISIBILITY_VISIBLE_BEHIND_TRANSLUCENT) &#123;</span><br><span class="line">            // Parent is behind a translucent container so the highest visibility this container</span><br><span class="line">            // can get is that.</span><br><span class="line">            gotTranslucentFullscreen = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int windowingMode = getWindowingMode();</span><br><span class="line">    final boolean isAssistantType = isActivityTypeAssistant();</span><br><span class="line">    //这里会去遍历所有的task</span><br><span class="line">    for (int i = parent.getChildCount() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        final WindowContainer wc = parent.getChildAt(i);</span><br><span class="line">        final Task other = wc.asTask();</span><br><span class="line">        if (other == null) continue;</span><br><span class="line"></span><br><span class="line">        final boolean hasRunningActivities = other.topRunningActivity() != null;</span><br><span class="line">        if (other == this) &#123;</span><br><span class="line">            // Should be visible if there is no other stack occluding it, unless it doesn&#x27;t</span><br><span class="line">            // have any running activities, not starting one and not home stack.</span><br><span class="line">            shouldBeVisible = hasRunningActivities || isInTask(starting) != null</span><br><span class="line">                    || isActivityTypeHome();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!hasRunningActivities) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int otherWindowingMode = other.getWindowingMode();</span><br><span class="line"></span><br><span class="line">        //主要逻辑在这里，一般Task的windowMode都是WINDOWING_MODE_FULLSCREEN，</span><br><span class="line">        //正常情况下，只要上层的Task不是translucent就会直接返回STACK_VISIBILITY_INVISIBLE</span><br><span class="line">        if (otherWindowingMode == WINDOWING_MODE_FULLSCREEN) &#123;</span><br><span class="line">            if (other.isTranslucent(starting)) &#123;</span><br><span class="line">                // Can be visible behind a translucent fullscreen stack.</span><br><span class="line">                gotTranslucentFullscreen = true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            return STACK_VISIBILITY_INVISIBLE;</span><br><span class="line">        &#125; //......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!shouldBeVisible) &#123;</span><br><span class="line">        return STACK_VISIBILITY_INVISIBLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Handle cases when there can be a translucent split-screen stack on top.</span><br><span class="line">    switch (windowingMode) &#123;</span><br><span class="line">        case WINDOWING_MODE_FULLSCREEN:</span><br><span class="line">            if (gotTranslucentSplitScreenPrimary || gotTranslucentSplitScreenSecondary) &#123;</span><br><span class="line">                // At least one of the split-screen stacks that covers this one is translucent.</span><br><span class="line">                return STACK_VISIBILITY_VISIBLE_BEHIND_TRANSLUCENT;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case WINDOWING_MODE_SPLIT_SCREEN_PRIMARY:</span><br><span class="line">            if (gotTranslucentSplitScreenPrimary) &#123;</span><br><span class="line">                // Covered by translucent primary split-screen on top.</span><br><span class="line">                return STACK_VISIBILITY_VISIBLE_BEHIND_TRANSLUCENT;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case WINDOWING_MODE_SPLIT_SCREEN_SECONDARY:</span><br><span class="line">            if (gotTranslucentSplitScreenSecondary) &#123;</span><br><span class="line">                // Covered by translucent secondary split-screen on top.</span><br><span class="line">                return STACK_VISIBILITY_VISIBLE_BEHIND_TRANSLUCENT;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Lastly - check if there is a translucent fullscreen stack on top.</span><br><span class="line">    return gotTranslucentFullscreen ? STACK_VISIBILITY_VISIBLE_BEHIND_TRANSLUCENT</span><br><span class="line">            : STACK_VISIBILITY_VISIBLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以只要最上层的task是translucent，下面一个task就是visible的，不会走onStop生命周期，<br>此时如果打开一个新的Activity，下层2个可见的task都会走onStop，<br>接着再finish最上层的，下层2个可见的就会重新restart，当下层app在透明task获取到焦点（onResume）前完成了onStart就会出现闪烁现象</p>
<p>注：onStart——对用户可见  onResume——对用户可见并获取到焦点，位于栈顶<br>生命周期的可见性可在[官方文档(<a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/components/activities/intro-activities?hl=zh-cn#mtal)]%E4%B8%AD%E6%9F%A5%E7%9C%8B">https://developer.android.google.cn/guide/components/activities/intro-activities?hl=zh-cn#mtal)]中查看</a></p>
<h2 id="Activity在onPause后无法收到onConfigurationChanged"><a href="#Activity在onPause后无法收到onConfigurationChanged" class="headerlink" title="Activity在onPause后无法收到onConfigurationChanged"></a>Activity在onPause后无法收到onConfigurationChanged</h2><p>Activity在onPause后无法收到onConfigurationChanged，<br>原因就是原生逻辑就是：Activity没有调用finish并且Activity没有pause，才会将其加到有效的回调队列</p>
<p>在AOSP的ActivityThread中有如下源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void handleConfigurationChanged(Configuration config) &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;configChanged&quot;);</span><br><span class="line">    mCurDefaultDisplayDpi = config.densityDpi;</span><br><span class="line">    handleConfigurationChanged(config, null /* compat */);</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleConfigurationChanged(Configuration config, CompatibilityInfo compat) &#123;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    //先收集所有的有效的callback</span><br><span class="line">    ArrayList&lt;ComponentCallbacks2&gt; callbacks = collectComponentCallbacks(false, config);</span><br><span class="line"></span><br><span class="line">    freeTextLayoutCachesIfNeeded(configDiff);</span><br><span class="line"></span><br><span class="line">    //这里会去遍历所有的callback，然后根据callback的类型进行回调</span><br><span class="line">    if (callbacks != null) &#123;</span><br><span class="line">        final int N = callbacks.size();</span><br><span class="line">        for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">            ComponentCallbacks2 cb = callbacks.get(i);</span><br><span class="line">            if (cb instanceof Activity) &#123;</span><br><span class="line">                // If callback is an Activity - call corresponding method to consider override</span><br><span class="line">                // config and avoid onConfigurationChanged if it hasn&#x27;t changed.</span><br><span class="line">                Activity a = (Activity) cb;</span><br><span class="line">                performConfigurationChangedForActivity(mActivities.get(a.getActivityToken()),</span><br><span class="line">                        config);</span><br><span class="line">            &#125; else if (!equivalent) &#123;</span><br><span class="line">                performConfigurationChanged(cb, config);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // TODO (b/135719017): Temporary log for debugging IME service.</span><br><span class="line">                if (Build.IS_DEBUGGABLE &amp;&amp; cb instanceof InputMethodService) &#123;</span><br><span class="line">                    Log.w(TAG, &quot;performConfigurationChanged didn&#x27;t callback to IME &quot;</span><br><span class="line">                            + &quot;, configDiff=&quot; + configDiff</span><br><span class="line">                            + &quot;, mConfiguration=&quot; + mConfiguration);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">ArrayList&lt;ComponentCallbacks2&gt; collectComponentCallbacks(</span><br><span class="line">        boolean allActivities, Configuration newConfig) &#123;</span><br><span class="line">    ArrayList&lt;ComponentCallbacks2&gt; callbacks</span><br><span class="line">            = new ArrayList&lt;ComponentCallbacks2&gt;();</span><br><span class="line"></span><br><span class="line">    synchronized (mResourcesManager) &#123;</span><br><span class="line">        //Application组件的callback</span><br><span class="line">        final int NAPP = mAllApplications.size();</span><br><span class="line">        for (int i=0; i&lt;NAPP; i++) &#123;</span><br><span class="line">            callbacks.add(mAllApplications.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        //Activity组件的callback</span><br><span class="line">        final int NACT = mActivities.size();</span><br><span class="line">        for (int i=0; i&lt;NACT; i++) &#123;</span><br><span class="line">            ActivityClientRecord ar = mActivities.valueAt(i);</span><br><span class="line">            Activity a = ar.activity;</span><br><span class="line">            if (a != null) &#123;</span><br><span class="line">                Configuration thisConfig = applyConfigCompatMainThread(</span><br><span class="line">                        mCurDefaultDisplayDpi, newConfig,</span><br><span class="line">                        ar.packageInfo.getCompatibilityInfo());</span><br><span class="line">                //这里有逻辑：Activity没有调用finish并且Activity没有pause，才会将其加到有效的回调队列</span><br><span class="line">                if (!ar.activity.mFinished &amp;&amp; (allActivities || !ar.paused)) &#123;</span><br><span class="line">                    // If the activity is currently resumed, its configuration</span><br><span class="line">                    // needs to change right now.</span><br><span class="line">                    callbacks.add(a);</span><br><span class="line">                &#125; else if (thisConfig != null) &#123;</span><br><span class="line">                    // Otherwise, we will tell it about the change</span><br><span class="line">                    // the next time it is resumed or shown.  Note that</span><br><span class="line">                    // the activity manager may, before then, decide the</span><br><span class="line">                    // activity needs to be destroyed to handle its new</span><br><span class="line">                    // configuration.</span><br><span class="line">                    if (DEBUG_CONFIGURATION || enableLifeCycleLog()) &#123;</span><br><span class="line">                        Slog.v(TAG, &quot;Setting activity &quot;</span><br><span class="line">                                + ar.activityInfo.name + &quot; newConfig=&quot; + thisConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ar.newConfig = thisConfig;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //Service组件的callback</span><br><span class="line">        final int NSVC = mServices.size();</span><br><span class="line">        for (int i=0; i&lt;NSVC; i++) &#123;</span><br><span class="line">            final ComponentCallbacks2 serviceComp = mServices.valueAt(i);</span><br><span class="line">            if (serviceComp instanceof InputMethodService) &#123;</span><br><span class="line">                mHasImeComponent = true;</span><br><span class="line">            &#125;</span><br><span class="line">            callbacks.add(serviceComp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //ContentProvider组件的callback</span><br><span class="line">    synchronized (mProviderMap) &#123;</span><br><span class="line">        final int NPRV = mLocalProviders.size();</span><br><span class="line">        for (int i=0; i&lt;NPRV; i++) &#123;</span><br><span class="line">            callbacks.add(mLocalProviders.valueAt(i).mLocalProvider);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return callbacks;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h2 id="记录一起开机卡LOGO的问题"><a href="#记录一起开机卡LOGO的问题" class="headerlink" title="记录一起开机卡LOGO的问题"></a>记录一起开机卡LOGO的问题</h2><p>可以搜索关键字<code>wm_</code>,<code>uc_</code>,<code>BootAnimation</code>,<code>FinishBooting</code></p>
<p>也可以搜索<code>SystemServiceManager</code>,<code>SystemServerTiming</code>查看服务启动过程</p>
<p>这里记录的问题是发现在 <code>SystemServerTiming</code>的log中<code>setBinderProxies</code>之后就没有了,后续应该是<code>WaitInitThreadPoolShutdown</code>，<br>查看对应源码，发现是在PHASE_BOOT_COMPLETED阶段调用，也就是没有触发PHASE_BOOT_COMPLETED，<br>查看<code>Starting phase</code>相关的log，发现没有<code>Starting phase 1000</code>,也就是没有<code>PHASE_BOOT_COMPLETED</code><br>继续查看源码，发现 <code>PHASE_BOOT_COMPLETED</code>是在AMS的 <code>finishBooting</code>中调用的</p>
<p>后面继续往前排查，找到在<code>activityIdleInternal</code>中会去调用方法，最后调用到<code>finishBooting</code></p>
<p>由于idle是在ActivityThread中触发，没触发idle说明没有进程起来，最后排查发现确实有人修改了AMS的逻辑，<br>特殊条件下拦截了Activity的启动，导致无法触发idle，所以一直卡在LOGO界面</p>
<p>在wms中的performEnableScreen<br>调用ams的bootAnimationComplete 在此时会将mBootAnimationComplete置为true，如果mCallFinishBooting是true就会执行finishBooting<br>在finishBooting中又将mCallFinishBooting置为false，然后进行userunlock的操作<br>所以关键点就是<strong>只有mCallFinishBooting为true的时候才会执行userunlock</strong>（即在mBootAnimationComplete&#x3D;false的情况下调用一次finishBooting）</p>
<p>正常情况下，在Activity resume的时候就会触发一次idle，然后调用checkFinishBootingLocked去调用atms中的postFinishBooting，最终调用到ams的finishBooting</p>
<p>加log排查后发现，在idle中mService.isBooting()是false，所以没走checkFinishBootingLocked的逻辑，也就没有将mCallFinishBooting置为true<br>排查isBooting所有的赋值点，在systemReady之前isBooting为false，以及只有在AMS中的ensureBootCompleted()会将其置为false，<br>而在app crash 和 ANR时都会触发ensureBootCompleted(),<br>最后排查，确实在userunlock之前，carservice crash了，booting被异常终止，导致开机流程没有完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">            case SHOW_ERROR_UI_MSG: &#123;</span><br><span class="line">                mAppErrors.handleShowAppErrorUi(msg);</span><br><span class="line">                ensureBootCompleted();</span><br><span class="line">            &#125; break;</span><br><span class="line">            case SHOW_NOT_RESPONDING_UI_MSG: &#123;</span><br><span class="line">                mAppErrors.handleShowAnrUi(msg);</span><br><span class="line">                ensureBootCompleted();</span><br><span class="line">            &#125; break;</span><br><span class="line"></span><br><span class="line">final void ensureBootCompleted() &#123;</span><br><span class="line">    boolean booting;</span><br><span class="line">    boolean enableScreen;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        booting = mBooting;</span><br><span class="line">        mBooting = false;</span><br><span class="line">        enableScreen = !mBooted;</span><br><span class="line">        mBooted = true;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果在ensureBootCompleted时，mBooting是true就会执行finishBooting</span><br><span class="line">    if (booting) &#123;</span><br><span class="line">        finishBooting();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (enableScreen) &#123;</span><br><span class="line">        mAtmInternal.enableScreenAfterBoot(mBooted);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                </span><br></pre></td></tr></table></figure>

<p>根据以上信息，<br>在ensureBootCompleted时，mBooting是true就会执行finishBooting，即在systemReady之后第一次触发ensureBootCompleted时会调用finishBooting<br>在idle时，mBooting是true就会执行checkFinishBootingLocked，即即在systemReady之后第一次触发idle时会调用finishBooting</p>
<p>systemReady的关键log：<code>System now ready</code>, 在<code>startPersistentApps</code>后会去将mBooting置为true</p>
<p>所以正常的log<br><code>grep -rniE &quot; wm_| uc_|FinishBooting|startPersistentApps|System now ready&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager: System now ready           </span><br><span class="line">SystemServerTiming: startPersistentApps     mBooting=true</span><br><span class="line">wm_on_top_resumed_gained_called:            FallbackHome onResume</span><br><span class="line">ActivityManagerTiming: FinishBooting        idle或ensureBootCompleted 触发FinishBooting，会将mCallFinishBooting置为true</span><br><span class="line">wm_boot_animation_done:                     wms的performEnableScreen()触发AMS的bootAnimationComplete(),会将mBootAnimationComplete置为true，并且mCallFinishBooting为true会再次调用FinishBooting</span><br><span class="line"></span><br><span class="line">ActivityManagerTiming: FinishBooting        第二次FinishBooting，mBootAnimationComplete为true，走userunlock流程</span><br><span class="line">uc_finish_user_boot:</span><br><span class="line">uc_finish_user_unlocking: </span><br><span class="line">uc_finish_user_unlocked:</span><br></pre></td></tr></table></figure>

<p>userunlock是在FinishBooting中，需要mBootAnimationComplete为true才触发逻辑，所以正常log中 wm_boot_animation_done之后触发FinishBooting</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wm_boot_animation_done</span><br><span class="line">ActivityManagerTiming: FinishBooting</span><br></pre></td></tr></table></figure>





<p>wms performEnableScreen()<br>wms enableScreenAfterBoot()  performBootTimeout()</p>
<p>ATMS                    startHomeActivity(int userId, String reason)<br>RootWindowContainer     startHomeOnDisplay startHomeOnTaskDisplayArea<br>ActivityStartController startHomeActivity(Intent intent, ActivityInfo aInfo, String reason,TaskDisplayArea taskDisplayArea)</p>
<p>在ATMS中获取到的HomeIntent</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String mTopAction = Intent.ACTION_MAIN;</span><br><span class="line">Intent getHomeIntent() &#123;</span><br><span class="line">    Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);</span><br><span class="line">    intent.setComponent(mTopComponent);</span><br><span class="line">    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);</span><br><span class="line">    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">    &#125;</span><br><span class="line">    return intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在RootWindowContainer中去找对应的组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    if (taskDisplayArea == getDefaultTaskDisplayArea()) &#123;</span><br><span class="line">        homeIntent = mService.getHomeIntent();</span><br><span class="line">        aInfo = resolveHomeActivity(userId, homeIntent);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@VisibleForTesting</span><br><span class="line">ActivityInfo resolveHomeActivity(int userId, Intent homeIntent) &#123;</span><br><span class="line">    final int flags = ActivityManagerService.STOCK_PM_FLAGS;</span><br><span class="line">    final ComponentName comp = homeIntent.getComponent();</span><br><span class="line">    ActivityInfo aInfo = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (comp != null) &#123;</span><br><span class="line">            // Factory test.</span><br><span class="line">            aInfo = AppGlobals.getPackageManager().getActivityInfo(comp, flags, userId);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final String resolvedType =</span><br><span class="line">                    homeIntent.resolveTypeIfNeeded(mService.mContext.getContentResolver());</span><br><span class="line">            final ResolveInfo info = AppGlobals.getPackageManager()</span><br><span class="line">                    .resolveIntent(homeIntent, resolvedType, flags, userId);</span><br><span class="line">            if (info != null) &#123;</span><br><span class="line">                aInfo = info.activityInfo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        // ignore</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (aInfo == null) &#123;</span><br><span class="line">        Slog.wtf(TAG, &quot;No home screen found for &quot; + homeIntent, new Throwable());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aInfo = new ActivityInfo(aInfo);</span><br><span class="line">    aInfo.applicationInfo = mService.getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line">    return aInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ams systemReady中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mAtmInternal.startHomeOnAllDisplays(currentUserId, &quot;systemReady&quot;);</span><br></pre></td></tr></table></figure>
<p>在 ActivityStack的resumeNextFocusableActivityWhenStackIsEmpty中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private boolean resumeNextFocusableActivityWhenStackIsEmpty(ActivityRecord prev,</span><br><span class="line">        ActivityOptions options) &#123;</span><br><span class="line">    final String reason = &quot;noMoreActivities&quot;;</span><br><span class="line"></span><br><span class="line">    if (!isActivityTypeHome()) &#123;</span><br><span class="line">        final ActivityStack nextFocusedStack = adjustFocusToNextFocusableTask(reason);</span><br><span class="line">        if (nextFocusedStack != null) &#123;</span><br><span class="line">            // Try to move focus to the next visible stack with a running activity if this</span><br><span class="line">            // stack is not covering the entire screen or is on a secondary display with no home</span><br><span class="line">            // stack.</span><br><span class="line">            return mRootWindowContainer.resumeFocusedStacksTopActivities(nextFocusedStack,</span><br><span class="line">                    prev, null /* targetOptions */);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the current stack is a home stack, or if focus didn&#x27;t switch to a different stack -</span><br><span class="line">    // just start up the Launcher...</span><br><span class="line">    ActivityOptions.abort(options);</span><br><span class="line">    if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">            &quot;resumeNextFocusableActivityWhenStackIsEmpty: &quot; + reason + &quot;, go home&quot;);</span><br><span class="line">    return mRootWindowContainer.resumeHomeActivity(prev, reason, getDisplayArea());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Fireflies</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/pages/4211e5/">http://example.com/pages/4211e5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Fireflies's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/pages/62cb3b/" title="Widget之AppWidgetHost"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Widget之AppWidgetHost</div></div></a></div><div class="next-post pull-right"><a href="/pages/72a181/" title="framework中一些通用逻辑"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">framework中一些通用逻辑</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fireflies</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FirefliesL"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BC%96Selinux%EF%BC%8Cpush%E5%90%8E%E6%97%A0%E6%B3%95Android%E5%90%AF%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">单编Selinux，push后无法Android启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder-getCallingPid%E4%B8%BA0"><span class="toc-number">2.</span> <span class="toc-text">Binder.getCallingPid为0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOSP%E4%B8%8BAIDL%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99couldn%E2%80%99t-find-import-for-class"><span class="toc-number">3.</span> <span class="toc-text">AOSP下AIDL编译报错couldn’t find import for class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%8A%A8%E6%80%81jar%E5%8C%85%E5%8A%A0%E8%BD%BD%E5%90%8C%E4%B8%80%E4%B8%AAso%E5%BC%95%E8%B5%B7%E5%B4%A9%E6%BA%83"><span class="toc-number">4.</span> <span class="toc-text">多个动态jar包加载同一个so引起崩溃</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8Cnative%E6%96%B9%E6%B3%95%E5%A4%B1%E8%B4%A5%EF%BC%8Cso%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5"><span class="toc-number">5.</span> <span class="toc-text">注册native方法失败，so加载失败</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-Studio-%E6%B7%B7%E6%B7%86%E5%90%8E%EF%BC%8C%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%8F%98%E6%88%90%E4%BA%86public"><span class="toc-number">6.</span> <span class="toc-text">Android Studio 混淆后，类中的私有方法变成了public</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%B1%8F%E4%BF%9D%E6%97%A0%E6%B3%95%E9%80%80%E5%87%BA%E7%9A%84%E7%8E%B0%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">记录一次屏保无法退出的现象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E8%B1%A1"><span class="toc-number">7.1.</span> <span class="toc-text">现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">7.2.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">解决方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileObserver"><span class="toc-number">8.</span> <span class="toc-text">FileObserver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ubuntu%E4%B8%8Badb%E6%8A%A5%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">Ubuntu下adb报权限问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Bu0-u10%E8%BF%9B%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">记录一下u0 u10进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APP%E7%9A%84uid%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96"><span class="toc-number">11.</span> <span class="toc-text">APP的uid发生变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Binder%E9%80%9A%E4%BF%A1%E5%BC%82%E5%B8%B8"><span class="toc-number">12.</span> <span class="toc-text">记录一次Binder通信异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-error-code-10-disk-I-O-error-extendcode-6410"><span class="toc-number">13.</span> <span class="toc-text">SQL error,code[10]: disk I&#x2F;O error,extendcode[6410]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#startActivity%E6%8A%9B%E5%BC%82%E5%B8%B8"><span class="toc-number">14.</span> <span class="toc-text">startActivity抛异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#startService-U10-not-found"><span class="toc-number">15.</span> <span class="toc-text">startService U10 not found</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91AndroidSDK%E6%8A%A5%E9%94%99"><span class="toc-number">16.</span> <span class="toc-text">编译AndroidSDK报错</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8Activity"><span class="toc-number">18.</span> <span class="toc-text">后台启动Activity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Home%E5%9B%9E%E5%88%B0%E4%B8%BB%E9%A1%B5%E5%90%8E%EF%BC%8C%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8Activity%E5%BB%B6%E8%BF%9F"><span class="toc-number">19.</span> <span class="toc-text">Home回到主页后，后台启动Activity延迟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#onStop%E5%9C%A8onPause-10s%E5%90%8E%E6%89%8D%E5%9B%9E%E8%B0%83"><span class="toc-number">20.</span> <span class="toc-text">onStop在onPause 10s后才回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AppWiget%E5%88%B7%E6%96%B0UI%E6%B2%A1%E5%8F%98"><span class="toc-number">21.</span> <span class="toc-text">AppWiget刷新UI没变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%85%B3%E4%BA%8EWindowInsetsController%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">22.</span> <span class="toc-text">记录一下关于WindowInsetsController的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#app%E5%88%87%E6%8D%A2%E6%97%B6%EF%BC%8C%E9%97%AA%E5%85%B6%E5%AE%83app%E9%A1%B5%E9%9D%A2"><span class="toc-number">23.</span> <span class="toc-text">app切换时，闪其它app页面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity%E5%9C%A8onPause%E5%90%8E%E6%97%A0%E6%B3%95%E6%94%B6%E5%88%B0onConfigurationChanged"><span class="toc-number">24.</span> <span class="toc-text">Activity在onPause后无法收到onConfigurationChanged</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E4%B8%80%E8%B5%B7%E5%BC%80%E6%9C%BA%E5%8D%A1LOGO%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">25.</span> <span class="toc-text">记录一起开机卡LOGO的问题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/25/android_fw/26.AdbService/" title="AdbService">AdbService</a><time datetime="2024-12-25T14:50:32.000Z" title="发表于 2024-12-25 14:50:32">2024-12-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/11/android_fw/56.ActivityView/" title="ActivityView">ActivityView</a><time datetime="2024-12-11T10:51:06.000Z" title="发表于 2024-12-11 10:51:06">2024-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/06/android_fw/55.%E9%BB%98%E8%AE%A4%E8%BE%93%E5%85%A5%E6%B3%95/" title="默认输入法">默认输入法</a><time datetime="2024-12-06T15:40:04.000Z" title="发表于 2024-12-06 15:40:04">2024-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/03/%E5%85%B6%E5%AE%83/22.gradle%E7%AC%94%E8%AE%B0/" title="gradle笔记">gradle笔记</a><time datetime="2024-12-03T17:48:28.000Z" title="发表于 2024-12-03 17:48:28">2024-12-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/02/%E5%85%B6%E5%AE%83/21.javadoc%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3/" title="javadoc生成文档">javadoc生成文档</a><time datetime="2024-12-02T16:41:51.000Z" title="发表于 2024-12-02 16:41:51">2024-12-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By Fireflies</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>