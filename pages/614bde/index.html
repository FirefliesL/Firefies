<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Insets相关 | Fireflies's blog</title><meta name="author" content="Fireflies"><meta name="copyright" content="Fireflies"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简单概念在aosp中，顶部的状态栏，底部的导航栏占用的空间被抽象成了一个Insets，Insets用来表示一个矩形的四个边缘的内边距（注意，表示的是上下左右的内变距，不是系统栏的坐标，也不是描述系统栏的对象）例如 Insets.of(0, 100, 0, 0),表示的是上方有100的内边距的矩形，最终会将多个Insets进行计算，生成一个处理了各个系统栏之后的Insets值，这个insets表示当">
<meta property="og:type" content="article">
<meta property="og:title" content="Insets相关">
<meta property="og:url" content="http://example.com/pages/614bde/index.html">
<meta property="og:site_name" content="Fireflies&#39;s blog">
<meta property="og:description" content="简单概念在aosp中，顶部的状态栏，底部的导航栏占用的空间被抽象成了一个Insets，Insets用来表示一个矩形的四个边缘的内边距（注意，表示的是上下左右的内变距，不是系统栏的坐标，也不是描述系统栏的对象）例如 Insets.of(0, 100, 0, 0),表示的是上方有100的内边距的矩形，最终会将多个Insets进行计算，生成一个处理了各个系统栏之后的Insets值，这个insets表示当">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-05-30T15:18:02.000Z">
<meta property="article:modified_time" content="2025-01-14T08:14:21.166Z">
<meta property="article:author" content="Fireflies">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/ico.jpg"><link rel="canonical" href="http://example.com/pages/614bde/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Insets相关',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-14 08:14:21'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #FF8F00)"><nav id="nav"><span id="blog-info"><a href="/" title="Fireflies's blog"><img class="site-icon" src="/img/avatar.jpg"/><span class="site-name">Fireflies's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Insets相关</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-30T15:18:02.000Z" title="发表于 2023-05-30 15:18:02">2023-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-14T08:14:21.166Z" title="更新于 2025-01-14 08:14:21">2025-01-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Insets相关"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="简单概念"><a href="#简单概念" class="headerlink" title="简单概念"></a>简单概念</h2><p>在aosp中，顶部的状态栏，底部的导航栏占用的空间被抽象成了一个Insets，<br>Insets用来表示一个矩形的四个边缘的内边距（注意，表示的是上下左右的内变距，不是系统栏的坐标，也不是描述系统栏的对象）<br>例如 Insets.of(0, 100, 0, 0),表示的是上方有100的内边距的矩形，<br>最终会将多个Insets进行计算，生成一个处理了各个系统栏之后的Insets值，这个insets表示当前窗口的4个方向上的内边距<br>Insets是一个序列化的实体类,可以类比Rect:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class Insets implements Parcelable &#123;</span><br><span class="line">    public static final @NonNull Insets NONE = new Insets(0, 0, 0, 0);</span><br><span class="line"></span><br><span class="line">    public final int left;</span><br><span class="line">    public final int top;</span><br><span class="line">    public final int right;</span><br><span class="line">    public final int bottom;</span><br><span class="line"></span><br><span class="line">    private Insets(int left, int top, int right, int bottom) &#123;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.top = top;</span><br><span class="line">        this.right = right;</span><br><span class="line">        this.bottom = bottom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外还有一个InsetsState，更加细化了Insets的状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public static final int ITYPE_INVALID = -1;</span><br><span class="line"></span><br><span class="line">static final int FIRST_TYPE = 0;</span><br><span class="line"></span><br><span class="line">public static final int ITYPE_STATUS_BAR = FIRST_TYPE;</span><br><span class="line">public static final int ITYPE_NAVIGATION_BAR = 1;</span><br><span class="line">public static final int ITYPE_CAPTION_BAR = 2;</span><br><span class="line"></span><br><span class="line">public static final int ITYPE_TOP_GESTURES = 3;</span><br><span class="line">public static final int ITYPE_BOTTOM_GESTURES = 4;</span><br><span class="line">public static final int ITYPE_LEFT_GESTURES = 5;</span><br><span class="line">public static final int ITYPE_RIGHT_GESTURES = 6;</span><br><span class="line"></span><br><span class="line">/** Additional gesture inset types that map into &#123;@link Type.MANDATORY_SYSTEM_GESTURES&#125;. */</span><br><span class="line">public static final int ITYPE_TOP_MANDATORY_GESTURES = 7;</span><br><span class="line">public static final int ITYPE_BOTTOM_MANDATORY_GESTURES = 8;</span><br><span class="line">public static final int ITYPE_LEFT_MANDATORY_GESTURES = 9;</span><br><span class="line">public static final int ITYPE_RIGHT_MANDATORY_GESTURES = 10;</span><br><span class="line"></span><br><span class="line">public static final int ITYPE_TOP_TAPPABLE_ELEMENT = 11;</span><br><span class="line">public static final int ITYPE_BOTTOM_TAPPABLE_ELEMENT = 12;</span><br><span class="line"></span><br><span class="line">public static final int ITYPE_LEFT_DISPLAY_CUTOUT = 13;</span><br><span class="line">public static final int ITYPE_TOP_DISPLAY_CUTOUT = 14;</span><br><span class="line">public static final int ITYPE_RIGHT_DISPLAY_CUTOUT = 15;</span><br><span class="line">public static final int ITYPE_BOTTOM_DISPLAY_CUTOUT = 16;</span><br><span class="line"></span><br><span class="line">/** Input method window. */</span><br><span class="line">public static final int ITYPE_IME = 17;</span><br><span class="line"></span><br><span class="line">/** Additional system decorations inset type. */</span><br><span class="line">public static final int ITYPE_CLIMATE_BAR = 18;</span><br><span class="line">public static final int ITYPE_EXTRA_NAVIGATION_BAR = 19;</span><br><span class="line"></span><br><span class="line">static final int LAST_TYPE = ITYPE_EXTRA_NAVIGATION_BAR;</span><br><span class="line">public static final int SIZE = LAST_TYPE + 1;</span><br><span class="line"></span><br><span class="line">// Derived types</span><br><span class="line"></span><br><span class="line">/** A shelf is the same as the navigation bar. */</span><br><span class="line">public static final int ITYPE_SHELF = ITYPE_NAVIGATION_BAR;</span><br><span class="line"></span><br><span class="line">//提供静态方法，获取InsetsState对应的公共的Insets的类型</span><br><span class="line">public static @Type.InsetsType int toPublicType(@InternalInsetsType int type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case ITYPE_STATUS_BAR:</span><br><span class="line">            return Type.STATUS_BARS;</span><br><span class="line">        case ITYPE_NAVIGATION_BAR:</span><br><span class="line">        case ITYPE_CLIMATE_BAR:</span><br><span class="line">        case ITYPE_EXTRA_NAVIGATION_BAR:</span><br><span class="line">            return Type.NAVIGATION_BARS;</span><br><span class="line">        case ITYPE_CAPTION_BAR:</span><br><span class="line">            return Type.CAPTION_BAR;</span><br><span class="line">        case ITYPE_IME:</span><br><span class="line">            return Type.IME;</span><br><span class="line">        case ITYPE_TOP_GESTURES:</span><br><span class="line">        case ITYPE_BOTTOM_GESTURES:</span><br><span class="line">        case ITYPE_TOP_MANDATORY_GESTURES:</span><br><span class="line">        case ITYPE_BOTTOM_MANDATORY_GESTURES:</span><br><span class="line">        case ITYPE_LEFT_MANDATORY_GESTURES:</span><br><span class="line">        case ITYPE_RIGHT_MANDATORY_GESTURES:</span><br><span class="line">            return Type.MANDATORY_SYSTEM_GESTURES;</span><br><span class="line">        case ITYPE_LEFT_GESTURES:</span><br><span class="line">        case ITYPE_RIGHT_GESTURES:</span><br><span class="line">            return Type.SYSTEM_GESTURES;</span><br><span class="line">        case ITYPE_TOP_TAPPABLE_ELEMENT:</span><br><span class="line">        case ITYPE_BOTTOM_TAPPABLE_ELEMENT:</span><br><span class="line">            return Type.TAPPABLE_ELEMENT;</span><br><span class="line">        case ITYPE_LEFT_DISPLAY_CUTOUT:</span><br><span class="line">        case ITYPE_TOP_DISPLAY_CUTOUT:</span><br><span class="line">        case ITYPE_RIGHT_DISPLAY_CUTOUT:</span><br><span class="line">        case ITYPE_BOTTOM_DISPLAY_CUTOUT:</span><br><span class="line">            return Type.DISPLAY_CUTOUT;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unknown type: &quot; + type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Insets的类型"><a href="#Insets的类型" class="headerlink" title="Insets的类型"></a>Insets的类型</h2><p>Insets的类型定义在WindowInsets.Type中，并且定义了每个type的索引值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static final int FIRST = 1 &lt;&lt; 0;</span><br><span class="line">static final int STATUS_BARS = FIRST;           //状态栏</span><br><span class="line">static final int NAVIGATION_BARS = 1 &lt;&lt; 1;      //导航栏</span><br><span class="line">static final int CAPTION_BAR = 1 &lt;&lt; 2;          //标题栏</span><br><span class="line"></span><br><span class="line">static final int IME = 1 &lt;&lt; 3;</span><br><span class="line"></span><br><span class="line">static final int SYSTEM_GESTURES = 1 &lt;&lt; 4;</span><br><span class="line">static final int MANDATORY_SYSTEM_GESTURES = 1 &lt;&lt; 5;</span><br><span class="line">static final int TAPPABLE_ELEMENT = 1 &lt;&lt; 6;</span><br><span class="line"></span><br><span class="line">static final int DISPLAY_CUTOUT = 1 &lt;&lt; 7;</span><br><span class="line"></span><br><span class="line">static final int LAST = 1 &lt;&lt; 8;</span><br><span class="line">static final int SIZE = 9;</span><br><span class="line">static final int WINDOW_DECOR = LAST;</span><br><span class="line"></span><br><span class="line">//提供静态方法获取对应type的索引值</span><br><span class="line">static int indexOf(@InsetsType int type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case STATUS_BARS:</span><br><span class="line">            return 0;</span><br><span class="line">        case NAVIGATION_BARS:</span><br><span class="line">            return 1;</span><br><span class="line">        case CAPTION_BAR:</span><br><span class="line">            return 2;</span><br><span class="line">        case IME:</span><br><span class="line">            return 3;</span><br><span class="line">        case SYSTEM_GESTURES:</span><br><span class="line">            return 4;</span><br><span class="line">        case MANDATORY_SYSTEM_GESTURES:</span><br><span class="line">            return 5;</span><br><span class="line">        case TAPPABLE_ELEMENT:</span><br><span class="line">            return 6;</span><br><span class="line">        case DISPLAY_CUTOUT:</span><br><span class="line">            return 7;</span><br><span class="line">        case WINDOW_DECOR:</span><br><span class="line">            return 8;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalArgumentException(&quot;type needs to be &gt;= FIRST and &lt;= LAST,&quot;</span><br><span class="line">                    + &quot; type=&quot; + type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<h2 id="Insets的方向（侧）"><a href="#Insets的方向（侧）" class="headerlink" title="Insets的方向（侧）"></a>Insets的方向（侧）</h2><p>Insets可以在上、下、左、右，它的定义在WindowInsets.Side中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final int LEFT = 1 &lt;&lt; 0;</span><br><span class="line">public static final int TOP = 1 &lt;&lt; 1;</span><br><span class="line">public static final int RIGHT = 1 &lt;&lt; 2;</span><br><span class="line">public static final int BOTTOM = 1 &lt;&lt; 3;</span><br></pre></td></tr></table></figure>

<h2 id="关于内边距消费"><a href="#关于内边距消费" class="headerlink" title="关于内边距消费"></a>关于内边距消费</h2><p>AOSP中关于insets的处理很多地方用到consume来进行命名，<br>这里的消费内边距是指是否已经处理过，消费过的就不再往下传递，子view就不再需要再进行处理</p>
<h2 id="WindowInsets"><a href="#WindowInsets" class="headerlink" title="WindowInsets"></a>WindowInsets</h2><p>WindowInsets是用来描述窗口insets的集合的类。<br>主要看里面几个成员变量：</p>
<ul>
<li><p>mTypeInsetsMap        用来保存当前各个类型内边距的数组</p>
</li>
<li><p>mTypeMaxInsetsMap     用来保存忽略可见性时（认为一直存在），各个类型内边距的数组</p>
</li>
<li><p>mTypeVisibilityMap    用来保存各个类型的Inset的可见性</p>
</li>
<li><p>mAlwaysConsumeSystemBars</p>
</li>
<li><p>mSystemWindowInsetsConsumed   标记当前是否已经消费了显示出来的系统窗口所产生的内边距</p>
</li>
<li><p>mStableInsetsConsumed         标记是否已经消费了所有系统窗口占位产生的内边距</p>
</li>
<li><p>mDisplayCutoutConsumed        标记是否已经消费了缺口（刘海）区域的内边距</p>
</li>
<li><p>mCompatInsetsTypes            记录关注的insets类型，计算内边距时会根据这个来取数据源进行计算</p>
</li>
<li><p>mCompatIgnoreVisibility       标记是否忽略产生内边距的来源窗口的可见性,忽略可见性时，就会认为所有产生占位的窗口都是可见的</p>
</li>
</ul>
<p>再看看它的构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Construct a new WindowInsets from individual insets.</span><br><span class="line">     *</span><br><span class="line">     * &#123;@code typeInsetsMap&#125; and &#123;@code typeMaxInsetsMap&#125; are a map of indexOf(type) -&gt; insets that</span><br><span class="line">     * contain the information what kind of system bars causes how much insets. The insets in this</span><br><span class="line">     * map are non-additive; i.e. they have the same origin. In other words: If two system bars</span><br><span class="line">     * overlap on one side, the insets of the larger bar will also include the insets of the smaller</span><br><span class="line">     * bar.</span><br><span class="line">     *</span><br><span class="line">     * &#123;@code null&#125; type inset map indicates that the respective inset is fully consumed.</span><br><span class="line">     * @hide</span><br><span class="line">     */</span><br><span class="line">    public WindowInsets(@Nullable Insets[] typeInsetsMap,</span><br><span class="line">            @Nullable Insets[] typeMaxInsetsMap,</span><br><span class="line">            boolean[] typeVisibilityMap,</span><br><span class="line">            boolean isRound,</span><br><span class="line">            boolean alwaysConsumeSystemBars, DisplayCutout displayCutout,</span><br><span class="line">            @InsetsType int compatInsetsTypes, boolean compatIgnoreVisibility) &#123;</span><br><span class="line">        //传入typeInsetsMap为null，认为当前显示出来的系统窗口占位产生的内边距已经被消费了</span><br><span class="line">        mSystemWindowInsetsConsumed = typeInsetsMap == null;</span><br><span class="line">        //被消费过的直接初始化一个数组，元素全为null</span><br><span class="line">        mTypeInsetsMap = mSystemWindowInsetsConsumed</span><br><span class="line">                ? new Insets[SIZE]</span><br><span class="line">                : typeInsetsMap.clone();</span><br><span class="line"></span><br><span class="line">        //传入typeMaxInsetsMap为null，认为所有系统窗口占位产生的内边距已经被消费了</span><br><span class="line">        mStableInsetsConsumed = typeMaxInsetsMap == null;</span><br><span class="line">        mTypeMaxInsetsMap = mStableInsetsConsumed</span><br><span class="line">                ? new Insets[SIZE]</span><br><span class="line">                : typeMaxInsetsMap.clone();</span><br><span class="line"></span><br><span class="line">        mTypeVisibilityMap = typeVisibilityMap;</span><br><span class="line">        mIsRound = isRound;</span><br><span class="line">        mAlwaysConsumeSystemBars = alwaysConsumeSystemBars;</span><br><span class="line">        mCompatInsetsTypes = compatInsetsTypes;</span><br><span class="line">        mCompatIgnoreVisibility = compatIgnoreVisibility;</span><br><span class="line"></span><br><span class="line">        mDisplayCutoutConsumed = displayCutout == null;</span><br><span class="line">        mDisplayCutout = (mDisplayCutoutConsumed || displayCutout.isEmpty())</span><br><span class="line">                ? null : displayCutout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="InsetsState"><a href="#InsetsState" class="headerlink" title="InsetsState"></a>InsetsState</h2><p>InsetsState是用来保存窗口insets状态的集合的类。主要有一个成员变量<code>mSources</code>，<br><code>mSources</code>是一个InsetsSource数组，保存了当前窗口所有的insets。</p>
<h2 id="一个Activity创建时Insets相关逻辑"><a href="#一个Activity创建时Insets相关逻辑" class="headerlink" title="一个Activity创建时Insets相关逻辑"></a>一个Activity创建时Insets相关逻辑</h2><p>在ViewRootImpl的第一次performTraversals中会执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br></pre></td></tr></table></figure>
<p>其实就是调用DecorView的dispatchAttachedToWindow</p>
<p>ViewRootImpl.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    Rect frame = mWinFrame;</span><br><span class="line">    if (mFirst) &#123;</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        // Set the layout direction if it has not been set before (inherit is the default)</span><br><span class="line">        if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) &#123;</span><br><span class="line">            host.setLayoutDirection(config.getLayoutDirection());</span><br><span class="line">        &#125;</span><br><span class="line">        host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);</span><br><span class="line">        dispatchApplyInsets(host);</span><br><span class="line">    &#125; </span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123;</span><br><span class="line">    mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;</span><br><span class="line">    super.dispatchAttachedToWindow(info, visibility);</span><br><span class="line">    mGroupFlags &amp;= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>View.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)</span><br><span class="line">void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123;</span><br><span class="line">    //....</span><br><span class="line">    performCollectViewAttributes(mAttachInfo, visibility);</span><br><span class="line">    //这里调用onAttachedToWindow</span><br><span class="line">    onAttachedToWindow();</span><br><span class="line"></span><br><span class="line">    L//....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要看DecorView中重写的onAttachedToWindow<br>DecorView.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onAttachedToWindow() &#123;</span><br><span class="line">    super.onAttachedToWindow();</span><br><span class="line"></span><br><span class="line">    //方法最后一行</span><br><span class="line">    mWindow.onViewRootImplSet(getViewRootImpl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PhoneWindow.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/** Notify when decor view is attached to window and &#123;@link ViewRootImpl&#125; is available. */</span><br><span class="line">void onViewRootImplSet(ViewRootImpl viewRoot) &#123;</span><br><span class="line">    viewRoot.setActivityConfigCallback(mActivityConfigCallback);</span><br><span class="line">    //这里让DecorView去Fits SystemWindows</span><br><span class="line">    applyDecorFitsSystemWindows();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void applyDecorFitsSystemWindows() &#123;</span><br><span class="line">    ViewRootImpl impl = getViewRootImplOrNull();</span><br><span class="line">    if (impl != null) &#123;</span><br><span class="line">        //默认mDecorFitsSystemWindows是true</span><br><span class="line">        impl.setOnContentApplyWindowInsetsListener(mDecorFitsSystemWindows</span><br><span class="line">                ? sDefaultContentInsetsApplier</span><br><span class="line">                : null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean mDecorFitsSystemWindows = true;</span><br><span class="line"></span><br><span class="line">private static final OnContentApplyWindowInsetsListener sDefaultContentInsetsApplier =</span><br><span class="line">        (view, insets) -&gt; &#123;</span><br><span class="line">            //这里的SYSTEM_UI_LAYOUT_FLAGS = SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;</span><br><span class="line">            //也就是说只要有这2Flag中的其中一个，就会返回Insets.NONE</span><br><span class="line">            if ((view.getWindowSystemUiVisibility() &amp; SYSTEM_UI_LAYOUT_FLAGS) != 0) &#123;</span><br><span class="line">                return new Pair&lt;&gt;(Insets.NONE, insets);</span><br><span class="line">            &#125;</span><br><span class="line">            Insets insetsToApply = insets.getSystemWindowInsets();</span><br><span class="line">            return new Pair&lt;&gt;(insetsToApply,</span><br><span class="line">                    insets.inset(insetsToApply).consumeSystemWindowInsets());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里返回的insets是最终需要用到的，在View的computeSystemWindowInsets中会取到这个值，然后调用applyInsets<br>内部调用internalSetPadding设置padding</p>
<p><strong>所以非全屏模式下，Activity的DecorView下的直接子view会设置padding</strong>，然后将剩下的没消费的WindowInsets标记为消费，不再继续传递给子View</p>
<h2 id="Activity中的Insets值的计算"><a href="#Activity中的Insets值的计算" class="headerlink" title="Activity中的Insets值的计算"></a>Activity中的Insets值的计算</h2><p>首先，在ViewRootImpl中有一个dispatchApplyInsets方法用来处理Insets变化的业务，<br>在第一次performTraversals的时候，会回调DecorView的onAttachedToWindow<br>ViewRootImpl.java:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    //......</span><br><span class="line">    if (mFirst) &#123;</span><br><span class="line">        //......</span><br><span class="line">        //host就是mView，即DecorView，这里调用View的dispatchAttachedToWindow</span><br><span class="line">        host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);</span><br><span class="line">        dispatchApplyInsets(host);            </span><br><span class="line">    &#125;    </span><br><span class="line">    //......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>View</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123;</span><br><span class="line">    //......</span><br><span class="line">    performCollectViewAttributes(mAttachInfo, visibility);</span><br><span class="line">    //这里调用到子类DecorView的方法</span><br><span class="line">    onAttachedToWindow();</span><br><span class="line">    //......        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecorView</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void onAttachedToWindow() &#123;</span><br><span class="line">    //......</span><br><span class="line">    //在最后调用PhoneWindow的onViewRootImplSet</span><br><span class="line">    mWindow.onViewRootImplSet(getViewRootImpl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PhoneWindow.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void onViewRootImplSet(ViewRootImpl viewRoot) &#123;</span><br><span class="line">    viewRoot.setActivityConfigCallback(mActivityConfigCallback);</span><br><span class="line">    applyDecorFitsSystemWindows();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void applyDecorFitsSystemWindows() &#123;</span><br><span class="line">    ViewRootImpl impl = getViewRootImplOrNull();</span><br><span class="line">    if (impl != null) &#123;</span><br><span class="line">        //给ViewRootImpl设置了一个Insets变化的默认处理器，主要进行最终的insets计算的</span><br><span class="line">        impl.setOnContentApplyWindowInsetsListener(mDecorFitsSystemWindows</span><br><span class="line">                ? sDefaultContentInsetsApplier</span><br><span class="line">                : null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public static final int SYSTEM_UI_LAYOUT_FLAGS =</span><br><span class="line">        SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span><br><span class="line">        | SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;    </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @see Window#setDecorFitsSystemWindows</span><br><span class="line"> */</span><br><span class="line">private static final OnContentApplyWindowInsetsListener sDefaultContentInsetsApplier =</span><br><span class="line">        (view, insets) -&gt; &#123;</span><br><span class="line">            //这里的View其时是DecorView下的子View,即DecorView的mContentRoot</span><br><span class="line">            //判断的是如果有LAYOUT相关的Flag，根布局不消费内边距，继续传递给子视图</span><br><span class="line">            if ((view.getWindowSystemUiVisibility() &amp; SYSTEM_UI_LAYOUT_FLAGS) != 0) &#123;</span><br><span class="line">                return new Pair&lt;&gt;(Insets.NONE, insets);</span><br><span class="line">            &#125;</span><br><span class="line">            //否则就会根据mCompatInsetsTypes去获取系统窗口所占用的位置，mCompatInsetsTypes和flag有关</span><br><span class="line">            Insets insetsToApply = insets.getSystemWindowInsets();</span><br><span class="line">            //最后返回2个对象</span><br><span class="line">            //第一个insetsToApply是需要DecorView下的子View处理的内边距</span><br><span class="line">            //第二个是 原来的insets移除insetsToApply这一部分也标记为消费</span><br><span class="line">            return new Pair&lt;&gt;(insetsToApply,</span><br><span class="line">                    insets.inset(insetsToApply).consumeSystemWindowInsets());</span><br><span class="line">        &#125;;    </span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<p>这里关注一下ViewRootImpl中设置的默认的内边距apply监听，先看看这个接口的描述,<br>onContentApplyWindowInsets接口回调的2个参数是当前要进行处理的view，以及还未处理的内边距<br>最后要返回的是2个对象，<br>第一个是一个insets（交给Decorview下的子view的）<br>第二个是要继续分法给子view的WindowInsets</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface OnContentApplyWindowInsetsListener &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Called when the window needs to apply insets on the container of its content view which</span><br><span class="line">     * are set by calling &#123;@link #setContentView&#125;. The method should determine what insets to</span><br><span class="line">     * apply on the container of the root level content view and what should be dispatched to</span><br><span class="line">     * the content view&#x27;s</span><br><span class="line">     * &#123;@link View#setOnApplyWindowInsetsListener(OnApplyWindowInsetsListener)&#125; through the view</span><br><span class="line">     * hierarchy.</span><br><span class="line">     *</span><br><span class="line">     * @param view The view for which to apply insets. Must not be directly modified.</span><br><span class="line">     * @param insets The root level insets that are about to be dispatched</span><br><span class="line">     * @return A pair, with the first element containing the insets to apply as margin to the</span><br><span class="line">     * root-level content views, and the second element determining what should be</span><br><span class="line">     * dispatched to the content view.</span><br><span class="line">     */</span><br><span class="line">    @NonNull</span><br><span class="line">    Pair&lt;Insets, WindowInsets&gt; onContentApplyWindowInsets(@NonNull View view,</span><br><span class="line">            @NonNull WindowInsets insets);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="Activity中设置Insets的流程"><a href="#Activity中设置Insets的流程" class="headerlink" title="Activity中设置Insets的流程"></a>Activity中设置Insets的流程</h2><p>在ViewRootImpl中在performTraversals的时候，如果Insets发生了变化或者主动请求刷新（requestFitSystemWindows）的时候，<br>会去调用dispatchApplyInsets，内部去调用的View（实例是DecorView）的dispatchApplyWindowInsets</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchApplyInsets(View host) &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;dispatchApplyInsets&quot;);</span><br><span class="line">    mApplyInsetsRequested = false;</span><br><span class="line">    //先获取所有的Insets</span><br><span class="line">    WindowInsets insets = getWindowInsets(true /* forceConstruct */);</span><br><span class="line">    if (!shouldDispatchCutout()) &#123;</span><br><span class="line">        // Window is either not laid out in cutout or the status bar inset takes care of</span><br><span class="line">        // clearing the cutout, so we don&#x27;t need to dispatch the cutout to the hierarchy.</span><br><span class="line">        insets = insets.consumeDisplayCutout();</span><br><span class="line">    &#125;</span><br><span class="line">    //然后调用Decorview的dispatchApplyWindowInsets</span><br><span class="line">    host.dispatchApplyWindowInsets(insets);</span><br><span class="line">    mAttachInfo.delayNotifyContentCaptureInsetsEvent(insets.getInsets(Type.all()));</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有2个关键点，一个是获取的Insets的逻辑（getWindowInsets），一个是处理Insets的逻辑（dispatchApplyWindowInsets）</p>
<h3 id="ViewRootImpl–getWindowInsets，获取当前窗口的insets（内边距）"><a href="#ViewRootImpl–getWindowInsets，获取当前窗口的insets（内边距）" class="headerlink" title="ViewRootImpl–getWindowInsets，获取当前窗口的insets（内边距）"></a>ViewRootImpl–getWindowInsets，获取当前窗口的insets（内边距）</h3><p>先来看看获取Insets的逻辑，内部传入了mWindowAttributes相关值，交给InsetsController去计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* package */ WindowInsets getWindowInsets(boolean forceConstruct) &#123;</span><br><span class="line">    if (mLastWindowInsets == null || forceConstruct) &#123;</span><br><span class="line">        //传入window的信息，交给mInsetsController成员去处理</span><br><span class="line">        mLastWindowInsets = mInsetsController.calculateInsets(</span><br><span class="line">                mContext.getResources().getConfiguration().isScreenRound(),</span><br><span class="line">                mAttachInfo.mAlwaysConsumeSystemBars, mPendingDisplayCutout.get(),</span><br><span class="line">                mWindowAttributes.softInputMode, mWindowAttributes.flags,</span><br><span class="line">                (mWindowAttributes.systemUiVisibility</span><br><span class="line">                        | mWindowAttributes.subtreeSystemUiVisibility));</span><br><span class="line"></span><br><span class="line">        Rect visibleInsets = mInsetsController.calculateVisibleInsets(</span><br><span class="line">                mWindowAttributes.softInputMode);</span><br><span class="line"></span><br><span class="line">        mAttachInfo.mVisibleInsets.set(visibleInsets);</span><br><span class="line">        mAttachInfo.mContentInsets.set(mLastWindowInsets.getSystemWindowInsets().toRect());</span><br><span class="line">        mAttachInfo.mStableInsets.set(mLastWindowInsets.getStableInsets().toRect());</span><br><span class="line">    &#125;</span><br><span class="line">    return mLastWindowInsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InsetsController.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/** The local state */</span><br><span class="line">private final InsetsState mState = new InsetsState();</span><br><span class="line"></span><br><span class="line">public WindowInsets calculateInsets(boolean isScreenRound,</span><br><span class="line">        boolean alwaysConsumeSystemBars, DisplayCutout cutout,</span><br><span class="line">        int legacySoftInputMode, int legacyWindowFlags, int legacySystemUiFlags) &#123;</span><br><span class="line">    //InsetsController会将传入的信息保存为全局变量</span><br><span class="line">    mLastLegacySoftInputMode = legacySoftInputMode;</span><br><span class="line">    mLastLegacyWindowFlags = legacyWindowFlags;</span><br><span class="line">    mLastLegacySystemUiFlags = legacySystemUiFlags;</span><br><span class="line">    mLastDisplayCutout = cutout;</span><br><span class="line"></span><br><span class="line">    //又调用InsetsState的calculateInsets</span><br><span class="line">    mLastInsets = mState.calculateInsets(mFrame, null /* ignoringVisibilityState*/,</span><br><span class="line">            isScreenRound, alwaysConsumeSystemBars, cutout,</span><br><span class="line">            legacySoftInputMode, legacyWindowFlags, legacySystemUiFlags,</span><br><span class="line">            null /* typeSideMap */);</span><br><span class="line">    return mLastInsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InsetsState.java<br>InsetsState的calculateInsets方法会去计算当前界面，所有类型的占位窗口对当前界面产生的内边距信息，封装成一个WindowInsets对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">public WindowInsets calculateInsets(Rect frame, @Nullable InsetsState ignoringVisibilityState,</span><br><span class="line">            boolean isScreenRound, boolean alwaysConsumeSystemBars, DisplayCutout cutout,</span><br><span class="line">            int legacySoftInputMode, int legacyWindowFlags, int legacySystemUiFlags,</span><br><span class="line">            @Nullable @InternalInsetsSide SparseIntArray typeSideMap) &#123;</span><br><span class="line">        //初始化局部变量</span><br><span class="line">        //存储每种内边距类型的当前内边距</span><br><span class="line">        Insets[] typeInsetsMap = new Insets[Type.SIZE];</span><br><span class="line">        //存储每种内边距类型的最大内边距(即一直认为其可见时的内边距)</span><br><span class="line">        Insets[] typeMaxInsetsMap = new Insets[Type.SIZE];</span><br><span class="line">        //存储每种内边距类型的可见性状态</span><br><span class="line">        boolean[] typeVisibilityMap = new boolean[SIZE];</span><br><span class="line">        final Rect relativeFrame = new Rect(frame);</span><br><span class="line">        final Rect relativeFrameMax = new Rect(frame);</span><br><span class="line">        //遍历所有的内边距类型</span><br><span class="line">        for (int type = FIRST_TYPE; type &lt;= LAST_TYPE; type++) &#123;</span><br><span class="line">            InsetsSource source = mSources[type];</span><br><span class="line">            //将遍历出来的为空的以 Insets.NONE 保存到typeInsetsMap</span><br><span class="line">            if (source == null) &#123;</span><br><span class="line">                int index = indexOf(toPublicType(type));</span><br><span class="line">                if (typeInsetsMap[index] == null) &#123;</span><br><span class="line">                    typeInsetsMap[index] = Insets.NONE;</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //标记需要跳过的类型</span><br><span class="line">            boolean skipNonImeInImeMode = ViewRootImpl.sNewInsetsMode == NEW_INSETS_MODE_IME</span><br><span class="line">                    &amp;&amp; source.getType() != ITYPE_IME;</span><br><span class="line">            boolean skipSystemBars = ViewRootImpl.sNewInsetsMode != NEW_INSETS_MODE_FULL</span><br><span class="line">                    &amp;&amp; (type == ITYPE_STATUS_BAR || type == ITYPE_NAVIGATION_BAR);</span><br><span class="line">            boolean skipLegacyTypes = ViewRootImpl.sNewInsetsMode == NEW_INSETS_MODE_NONE</span><br><span class="line">                    &amp;&amp; (type == ITYPE_STATUS_BAR || type == ITYPE_NAVIGATION_BAR</span><br><span class="line">                            || type == ITYPE_IME);</span><br><span class="line">            //针对需要跳过计算的，将其可见性保存在typeVisibilityMap，不进行后续内边距计算</span><br><span class="line">            if (skipSystemBars || skipLegacyTypes || skipNonImeInImeMode) &#123;</span><br><span class="line">                typeVisibilityMap[indexOf(toPublicType(type))] = source.isVisible();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //根据原始的InsetsSource，以及当前窗口的边框，不忽略InsetsSource的可见度</span><br><span class="line">            //计算内边距保存在typeInsetsMap，将InsetsSource的可见度保存在typeVisibilityMap中</span><br><span class="line">            processSource(source, relativeFrame, false /* ignoreVisibility */, typeInsetsMap,</span><br><span class="line">                                    typeSideMap, typeVisibilityMap);</span><br><span class="line"></span><br><span class="line">            // IME won&#x27;t be reported in max insets as the size depends on the EditorInfo of the IME</span><br><span class="line">            // target.</span><br><span class="line">            if (source.getType() != ITYPE_IME) &#123;</span><br><span class="line">                InsetsSource ignoringVisibilitySource = ignoringVisibilityState != null</span><br><span class="line">                        ? ignoringVisibilityState.getSource(type)</span><br><span class="line">                        : source;</span><br><span class="line">                if (ignoringVisibilitySource == null) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //针对非输入法类型的占位，会忽略其可见性再计算一次内边距保存在typeMaxInsetsMap中</span><br><span class="line">                processSource(ignoringVisibilitySource, relativeFrameMax,</span><br><span class="line">                        true /* ignoreVisibility */, typeMaxInsetsMap, null /* typeSideMap */,</span><br><span class="line">                        null /* typeVisibilityMap */);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        final int softInputAdjustMode = legacySoftInputMode &amp; SOFT_INPUT_MASK_ADJUST;</span><br><span class="line"></span><br><span class="line">        //处理兼容性，默认感知 所有的系统栏和切口区域（刘海屏）的内边距</span><br><span class="line">        @InsetsType int compatInsetsTypes = systemBars() | displayCutout();</span><br><span class="line">        //如果配置的SOFT_INPUT_ADJUST_RESIZE会加上 输入法区域 的内边距</span><br><span class="line">        if (softInputAdjustMode == SOFT_INPUT_ADJUST_RESIZE) &#123;</span><br><span class="line">            compatInsetsTypes |= ime();</span><br><span class="line">        &#125;</span><br><span class="line">        //如果有WindowAttributes的flag设置了全屏flag FLAG_FULLSCREEN，去掉状态栏区域的内边距</span><br><span class="line">        if ((legacyWindowFlags &amp; FLAG_FULLSCREEN) != 0) &#123;</span><br><span class="line">            compatInsetsTypes &amp;= ~statusBars();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //最后将计算的数据封装成一个WindowInsets对象</span><br><span class="line">        return new WindowInsets(typeInsetsMap, typeMaxInsetsMap, typeVisibilityMap, isScreenRound,</span><br><span class="line">                alwaysConsumeSystemBars, cutout, compatInsetsTypes,</span><br><span class="line">                sNewInsetsMode == NEW_INSETS_MODE_FULL</span><br><span class="line">                        &amp;&amp; (legacySystemUiFlags &amp; SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void processSource(InsetsSource source, Rect relativeFrame, boolean ignoreVisibility,</span><br><span class="line">            Insets[] typeInsetsMap, @Nullable @InternalInsetsSide SparseIntArray typeSideMap,</span><br><span class="line">            @Nullable boolean[] typeVisibilityMap) &#123;</span><br><span class="line">        //调用InsetsSource的calculateInsets来计算内边距</span><br><span class="line">        //计算出InsetsSource占位而导致显示区域所产生的内边距</span><br><span class="line">        Insets insets = source.calculateInsets(relativeFrame, ignoreVisibility);</span><br><span class="line"></span><br><span class="line">        //取到InsetsSource所属的大类型，进行处理，保存到对应的数组中</span><br><span class="line">        int type = toPublicType(source.getType());</span><br><span class="line">        processSourceAsPublicType(source, typeInsetsMap, typeSideMap, typeVisibilityMap,</span><br><span class="line">                insets, type);</span><br><span class="line"></span><br><span class="line">        //针对MANDATORY_SYSTEM_GESTURES这种类型的占位还会额外再处理一次</span><br><span class="line">        if (type == MANDATORY_SYSTEM_GESTURES) &#123;</span><br><span class="line">            // Mandatory system gestures are also system gestures.</span><br><span class="line">            // TODO: find a way to express this more generally. One option would be to define</span><br><span class="line">            //       Type.systemGestureInsets() as NORMAL | MANDATORY, but then we lose the</span><br><span class="line">            //       ability to set systemGestureInsets() independently from</span><br><span class="line">            //       mandatorySystemGestureInsets() in the Builder.</span><br><span class="line">            processSourceAsPublicType(source, typeInsetsMap, typeSideMap, typeVisibilityMap,</span><br><span class="line">                    insets, SYSTEM_GESTURES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    private void processSourceAsPublicType(InsetsSource source, Insets[] typeInsetsMap,</span><br><span class="line">            @InternalInsetsSide @Nullable SparseIntArray typeSideMap,</span><br><span class="line">            @Nullable boolean[] typeVisibilityMap, Insets insets, int type) &#123;</span><br><span class="line">        //根据InsetsSource所属大类型，从数组中取值</span><br><span class="line">        int index = indexOf(type);</span><br><span class="line">        Insets existing = typeInsetsMap[index];</span><br><span class="line">        //然后将计算出来的内边距和原来的内边距进行对比，取最大值保存在typeInsetsMap</span><br><span class="line">        if (existing == null) &#123;</span><br><span class="line">            typeInsetsMap[index] = insets;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            typeInsetsMap[index] = Insets.max(existing, insets);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将InsetsSource的可见性保存在typeVisibilityMap</span><br><span class="line">        if (typeVisibilityMap != null) &#123;</span><br><span class="line">            typeVisibilityMap[index] = source.isVisible();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (typeSideMap != null) &#123;</span><br><span class="line">            //如果传入了typeSideMap，也会将insets所在的方向保存在typeSideMap</span><br><span class="line">            @InternalInsetsSide int insetSide = getInsetSide(insets);</span><br><span class="line">            if (insetSide != ISIDE_UNKNOWN) &#123;</span><br><span class="line">                typeSideMap.put(source.getType(), insetSide);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     </span><br></pre></td></tr></table></figure>
<p>InsetsSource.java<br>InsetsSource中的calculateInsets，主要是计算InsetsSource和显示的边框的交叉区域，然后在判断内边距在上下左右哪个方向上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public Insets calculateInsets(Rect relativeFrame, boolean ignoreVisibility) &#123;</span><br><span class="line">    return calculateInsets(relativeFrame, mFrame, ignoreVisibility);</span><br><span class="line">&#125;</span><br><span class="line">private Insets calculateInsets(Rect relativeFrame, Rect frame, boolean ignoreVisibility) &#123;</span><br><span class="line">    //不可见直接返回NONE</span><br><span class="line">    if (!ignoreVisibility &amp;&amp; !mVisible) &#123;</span><br><span class="line">        return Insets.NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    // During drag-move and drag-resizing, the caption insets position may not get updated</span><br><span class="line">    // before the app frame get updated. To layout the app content correctly during drag events,</span><br><span class="line">    // we always return the insets with the corresponding height covering the top.</span><br><span class="line">    if (getType() == ITYPE_CAPTION_BAR) &#123;</span><br><span class="line">        return Insets.of(0, frame.height(), 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    //取2个区域的交集保存在mTmpFrame中,后续根据这个相交的区域来计算内边距</span><br><span class="line">    if (!getIntersection(frame, relativeFrame, mTmpFrame)) &#123;</span><br><span class="line">        return Insets.NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // TODO: Currently, non-floating IME always intersects at bottom due to issues with cutout.</span><br><span class="line">    // However, we should let the policy decide from the server.</span><br><span class="line">    if (getType() == ITYPE_IME) &#123;</span><br><span class="line">        //当前占用空间的是输入法，就直接返回相交矩形的高度作为底部内边距</span><br><span class="line">        return Insets.of(0, 0, 0, mTmpFrame.height());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Intersecting at top/bottom</span><br><span class="line">    // 相交区域的宽度 和 内容所在的边框宽度一致，说明水平方向上没有占位产生，处理上下的内边距</span><br><span class="line">    if (mTmpFrame.width() == relativeFrame.width()) &#123;</span><br><span class="line">        if (mTmpFrame.top == relativeFrame.top) &#123;</span><br><span class="line">            return Insets.of(0, mTmpFrame.height(), 0, 0);</span><br><span class="line">        &#125; else if (mTmpFrame.bottom == relativeFrame.bottom) &#123;</span><br><span class="line">            return Insets.of(0, 0, 0, mTmpFrame.height());</span><br><span class="line">        &#125;</span><br><span class="line">        // TODO: remove when insets are shell-customizable.</span><br><span class="line">        // This is a hack that says &quot;if this is a top-inset (eg statusbar), always apply it</span><br><span class="line">        // to the top&quot;. It is used when adjusting primary split for IME.</span><br><span class="line">        if (mTmpFrame.top == 0) &#123;</span><br><span class="line">            return Insets.of(0, mTmpFrame.height(), 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Intersecting at left/right</span><br><span class="line">    // 相交区域的高度 和 内容所在的边框高度一致，说明在上下方向上没有占位产生，处理左右的内边距</span><br><span class="line">    else if (mTmpFrame.height() == relativeFrame.height()) &#123;</span><br><span class="line">        if (mTmpFrame.left == relativeFrame.left) &#123;</span><br><span class="line">            return Insets.of(mTmpFrame.width(), 0, 0, 0);</span><br><span class="line">        &#125; else if (mTmpFrame.right == relativeFrame.right) &#123;</span><br><span class="line">            return Insets.of(0, 0, mTmpFrame.width(), 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Insets.NONE;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="View–dispatchApplyWindowInsets，处理insets-消费内边距"><a href="#View–dispatchApplyWindowInsets，处理insets-消费内边距" class="headerlink" title="View–dispatchApplyWindowInsets，处理insets(消费内边距)"></a>View–dispatchApplyWindowInsets，处理insets(消费内边距)</h3><p>接着看处理Insets的逻辑，Decorview的dispatchApplyWindowInsets<br>DecorView父类是FrameLayout,实现在ViewGroup中<br>ViewGroup.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public WindowInsets dispatchApplyWindowInsets(WindowInsets insets) &#123;</span><br><span class="line">    //调用父类View的dispatchApplyWindowInsets，返回处理完成的WindowInsets</span><br><span class="line">    insets = super.dispatchApplyWindowInsets(insets);</span><br><span class="line">    //WindowInsets被消费了就返回</span><br><span class="line">    if (insets.isConsumed()) &#123;</span><br><span class="line">        return insets;</span><br><span class="line">    &#125;</span><br><span class="line">    if (View.sBrokenInsetsDispatch) &#123;</span><br><span class="line">        return brokenDispatchApplyWindowInsets(insets);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //没有被消费的WindowInsets会分法给子View</span><br><span class="line">        return newDispatchApplyWindowInsets(insets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private WindowInsets newDispatchApplyWindowInsets(WindowInsets insets) &#123;</span><br><span class="line">    final int count = getChildCount();</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        getChildAt(i).dispatchApplyWindowInsets(insets);</span><br><span class="line">    &#125;</span><br><span class="line">    return insets;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>View.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public WindowInsets dispatchApplyWindowInsets(WindowInsets insets) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //添加一个内部私有flag</span><br><span class="line">        mPrivateFlags3 |= PFLAG3_APPLYING_INSETS;</span><br><span class="line">        //如果设置了监听就回调</span><br><span class="line">        if (mListenerInfo != null &amp;&amp; mListenerInfo.mOnApplyWindowInsetsListener != null) &#123;</span><br><span class="line">            return mListenerInfo.mOnApplyWindowInsetsListener.onApplyWindowInsets(this, insets);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //没有设置insets监听就走默认方法，在DecorView中重写过onApplyWindowInsets，去看DecorView的实现</span><br><span class="line">            return onApplyWindowInsets(insets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //最后会清理私有flag</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_APPLYING_INSETS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在DecorView中重写过onApplyWindowInsets，所以DecorView会先特殊处理一次内边距</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">public WindowInsets onApplyWindowInsets(WindowInsets insets) &#123;</span><br><span class="line">    final WindowManager.LayoutParams attrs = mWindow.getAttributes();</span><br><span class="line">    //......</span><br><span class="line">    mFrameOffsets.set(insets.getSystemWindowInsetsAsRect());</span><br><span class="line">    //传入获取到的insets，去更新ColorViews</span><br><span class="line">    insets = updateColorViews(insets, true /* animate */);</span><br><span class="line">    insets = updateStatusGuard(insets);</span><br><span class="line">    if (getForeground() != null) &#123;</span><br><span class="line">        drawableChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    return insets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WindowInsets updateColorViews(WindowInsets insets, boolean animate) &#123;</span><br><span class="line">    WindowManager.LayoutParams attrs = mWindow.getAttributes();</span><br><span class="line">    int sysUiVisibility = attrs.systemUiVisibility | getWindowSystemUiVisibility();</span><br><span class="line"></span><br><span class="line">    final WindowInsetsController controller = getWindowInsetsController();</span><br><span class="line"></span><br><span class="line">    // IME is an exceptional floating window that requires color view.</span><br><span class="line">    final boolean isImeWindow =</span><br><span class="line">            mWindow.getAttributes().type == WindowManager.LayoutParams.TYPE_INPUT_METHOD;</span><br><span class="line">    if (!mWindow.mIsFloating || isImeWindow) &#123;</span><br><span class="line">        boolean disallowAnimate = !isLaidOut();</span><br><span class="line">        disallowAnimate |= ((mLastWindowFlags ^ attrs.flags)</span><br><span class="line">                &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0;</span><br><span class="line">        mLastWindowFlags = attrs.flags;</span><br><span class="line"></span><br><span class="line">        if (insets != null) &#123;</span><br><span class="line">            //这里去获取系统栏占位的产生的内边距，忽略其可见度（即获取所有系统栏可见状态下所产生的内边距）</span><br><span class="line">            final Insets stableBarInsets = insets.getInsetsIgnoringVisibility(</span><br><span class="line">                    WindowInsets.Type.systemBars());</span><br><span class="line">            //获取当前显示的状态栏和切口区域产生内边距，和前面获取的对比取最小值</span><br><span class="line">            final Insets systemInsets = Insets.min(</span><br><span class="line">                    insets.getInsets(WindowInsets.Type.systemBars()</span><br><span class="line">                            | WindowInsets.Type.displayCutout()), stableBarInsets);</span><br><span class="line">            //将上下左右的内边距保存到DecorView的全局变量</span><br><span class="line">            mLastTopInset = systemInsets.top;</span><br><span class="line">            mLastBottomInset = systemInsets.bottom;</span><br><span class="line">            mLastRightInset = systemInsets.right;</span><br><span class="line">            mLastLeftInset = systemInsets.left;</span><br><span class="line"></span><br><span class="line">            // Don&#x27;t animate if the presence of stable insets has changed, because that</span><br><span class="line">            // indicates that the window was either just added and received them for the</span><br><span class="line">            // first time, or the window size or position has changed.</span><br><span class="line">            //记录占位窗口在可见状态下时的当前窗口上下左右的内边距是否存在</span><br><span class="line">            boolean hasTopStableInset = stableBarInsets.top != 0;</span><br><span class="line">            disallowAnimate |= (hasTopStableInset != mLastHasTopStableInset);</span><br><span class="line">            mLastHasTopStableInset = hasTopStableInset;</span><br><span class="line"></span><br><span class="line">            boolean hasBottomStableInset = stableBarInsets.bottom != 0;</span><br><span class="line">            disallowAnimate |= (hasBottomStableInset != mLastHasBottomStableInset);</span><br><span class="line">            mLastHasBottomStableInset = hasBottomStableInset;</span><br><span class="line"></span><br><span class="line">            boolean hasRightStableInset = stableBarInsets.right != 0;</span><br><span class="line">            disallowAnimate |= (hasRightStableInset != mLastHasRightStableInset);</span><br><span class="line">            mLastHasRightStableInset = hasRightStableInset;</span><br><span class="line"></span><br><span class="line">            boolean hasLeftStableInset = stableBarInsets.left != 0;</span><br><span class="line">            disallowAnimate |= (hasLeftStableInset != mLastHasLeftStableInset);</span><br><span class="line">            mLastHasLeftStableInset = hasLeftStableInset;</span><br><span class="line"></span><br><span class="line">            mLastShouldAlwaysConsumeSystemBars = insets.shouldAlwaysConsumeSystemBars();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //计算导航栏的位置和大小，并调用 updateColorViewInt 方法更新导航栏</span><br><span class="line">        boolean navBarToRightEdge = isNavBarToRightEdge(mLastBottomInset, mLastRightInset);</span><br><span class="line">        boolean navBarToLeftEdge = isNavBarToLeftEdge(mLastBottomInset, mLastLeftInset);</span><br><span class="line">        int navBarSize = getNavBarSize(mLastBottomInset, mLastRightInset, mLastLeftInset);</span><br><span class="line">        updateColorViewInt(mNavigationColorViewState, sysUiVisibility,</span><br><span class="line">                calculateNavigationBarColor(), mWindow.mNavigationBarDividerColor, navBarSize,</span><br><span class="line">                navBarToRightEdge || navBarToLeftEdge, navBarToLeftEdge,</span><br><span class="line">                0 /* sideInset */, animate &amp;&amp; !disallowAnimate,</span><br><span class="line">                mForceWindowDrawsBarBackgrounds, controller);</span><br><span class="line"></span><br><span class="line">        //处理导航栏背景        </span><br><span class="line">        boolean oldDrawLegacy = mDrawLegacyNavigationBarBackground;</span><br><span class="line">        mDrawLegacyNavigationBarBackground = mNavigationColorViewState.visible</span><br><span class="line">                &amp;&amp; (mWindow.getAttributes().flags &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0;</span><br><span class="line">        if (oldDrawLegacy != mDrawLegacyNavigationBarBackground) &#123;</span><br><span class="line">            ViewRootImpl vri = getViewRootImpl();</span><br><span class="line">            if (vri != null) &#123;</span><br><span class="line">                vri.requestInvalidateRootRenderNode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //计算状态栏是否需要右侧或左侧的内边距，并更新状态栏</span><br><span class="line">        boolean statusBarNeedsRightInset = navBarToRightEdge</span><br><span class="line">                &amp;&amp; mNavigationColorViewState.present;</span><br><span class="line">        boolean statusBarNeedsLeftInset = navBarToLeftEdge</span><br><span class="line">                &amp;&amp; mNavigationColorViewState.present;</span><br><span class="line">        int statusBarSideInset = statusBarNeedsRightInset ? mLastRightInset</span><br><span class="line">                : statusBarNeedsLeftInset ? mLastLeftInset : 0;</span><br><span class="line">        updateColorViewInt(mStatusColorViewState, sysUiVisibility,</span><br><span class="line">                calculateStatusBarColor(), 0, mLastTopInset,</span><br><span class="line">                false /* matchVertical */, statusBarNeedsLeftInset, statusBarSideInset,</span><br><span class="line">                animate &amp;&amp; !disallowAnimate,</span><br><span class="line">                mForceWindowDrawsBarBackgrounds, controller);</span><br><span class="line"></span><br><span class="line">        //处理标题栏</span><br><span class="line">        if (mHasCaption) &#123;</span><br><span class="line">            final int captionColor = calculateStatusBarColor();</span><br><span class="line">            mDecorCaptionView.getCaption().setBackgroundColor(captionColor);</span><br><span class="line">            updateDecorCaptionShade();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // When we expand the window with FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS or</span><br><span class="line">    // mForceWindowDrawsBarBackgrounds, we still need to ensure that the rest of the view</span><br><span class="line">    // hierarchy doesn&#x27;t notice it, unless they&#x27;ve explicitly asked for it.</span><br><span class="line">    //</span><br><span class="line">    // Note: We don&#x27;t need to check for IN_SCREEN or INSET_DECOR because unlike the status bar,</span><br><span class="line">    // these flags wouldn&#x27;t make the window draw behind the navigation bar, unless</span><br><span class="line">    // LAYOUT_HIDE_NAVIGATION was set.</span><br><span class="line">    //</span><br><span class="line">    // Note: Once the app uses the R+ Window.setDecorFitsSystemWindows(false) API we no longer</span><br><span class="line">    // consume insets because they might no longer set SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION.</span><br><span class="line">    //隐藏导航栏的标记 （有SYSTEM_UI_FLAG_HIDE_NAVIGATION这个flag，或者WindowInsetsController没有请求导航栏可见）</span><br><span class="line">    boolean hideNavigation = (sysUiVisibility &amp; SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0</span><br><span class="line">            || !(controller == null || controller.isRequestedVisible(ITYPE_NAVIGATION_BAR));</span><br><span class="line">    //默认DecorView是去适应系统窗口的</span><br><span class="line">    boolean decorFitsSystemWindows = mWindow.mDecorFitsSystemWindows;</span><br><span class="line">    //强制消费导航栏的标记</span><br><span class="line">    boolean forceConsumingNavBar = (mForceWindowDrawsBarBackgrounds</span><br><span class="line">                    &amp;&amp; (attrs.flags &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0</span><br><span class="line">                    &amp;&amp; (sysUiVisibility &amp; SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0</span><br><span class="line">                    &amp;&amp; decorFitsSystemWindows</span><br><span class="line">                    &amp;&amp; !hideNavigation)</span><br><span class="line">            || (mLastShouldAlwaysConsumeSystemBars &amp;&amp; hideNavigation);</span><br><span class="line">    </span><br><span class="line">    //消费导航栏的标记</span><br><span class="line">    boolean consumingNavBar =</span><br><span class="line">            ((attrs.flags &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0</span><br><span class="line">                    &amp;&amp; (sysUiVisibility &amp; SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0</span><br><span class="line">                    &amp;&amp; decorFitsSystemWindows</span><br><span class="line">                    &amp;&amp; !hideNavigation)</span><br><span class="line">            || forceConsumingNavBar;</span><br><span class="line"></span><br><span class="line">    // If we didn&#x27;t request fullscreen layout, but we still got it because of the</span><br><span class="line">    // mForceWindowDrawsBarBackgrounds flag, also consume top inset.</span><br><span class="line">    // If we should always consume system bars, only consume that if the app wanted to go to</span><br><span class="line">    // fullscreen, as othrewise we can expect the app to handle it.</span><br><span class="line">    //全屏标记 （有SYSTEM_UI_FLAG_FULLSCREEN标记 或者 有FLAG_FULLSCREEN标记 或者 WindowInsetsController没有请求状态栏可见）</span><br><span class="line">    boolean fullscreen = (sysUiVisibility &amp; SYSTEM_UI_FLAG_FULLSCREEN) != 0</span><br><span class="line">            || (attrs.flags &amp; FLAG_FULLSCREEN) != 0</span><br><span class="line">            || !(controller == null || controller.isRequestedVisible(ITYPE_STATUS_BAR));</span><br><span class="line">    //消费状态栏的标记</span><br><span class="line">    boolean consumingStatusBar = (sysUiVisibility &amp; SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN) == 0</span><br><span class="line">            &amp;&amp; decorFitsSystemWindows</span><br><span class="line">            &amp;&amp; (attrs.flags &amp; FLAG_LAYOUT_IN_SCREEN) == 0</span><br><span class="line">            &amp;&amp; (attrs.flags &amp; FLAG_LAYOUT_INSET_DECOR) == 0</span><br><span class="line">            &amp;&amp; mForceWindowDrawsBarBackgrounds</span><br><span class="line">            &amp;&amp; mLastTopInset != 0</span><br><span class="line">            || (mLastShouldAlwaysConsumeSystemBars &amp;&amp; fullscreen);</span><br><span class="line"></span><br><span class="line">    //消费状态栏和导航栏就会将之前记录的 上下左右的 内边距保存在临时变量中</span><br><span class="line">    int consumedTop = consumingStatusBar ? mLastTopInset : 0;</span><br><span class="line">    int consumedRight = consumingNavBar ? mLastRightInset : 0;</span><br><span class="line">    int consumedBottom = consumingNavBar ? mLastBottomInset : 0;</span><br><span class="line">    int consumedLeft = consumingNavBar ? mLastLeftInset : 0;</span><br><span class="line"></span><br><span class="line">    if (mContentRoot != null</span><br><span class="line">            &amp;&amp; mContentRoot.getLayoutParams() instanceof MarginLayoutParams) &#123;</span><br><span class="line">        MarginLayoutParams lp = (MarginLayoutParams) mContentRoot.getLayoutParams();</span><br><span class="line">        if (lp.topMargin != consumedTop || lp.rightMargin != consumedRight</span><br><span class="line">                || lp.bottomMargin != consumedBottom || lp.leftMargin != consumedLeft) &#123;</span><br><span class="line">            lp.topMargin = consumedTop;</span><br><span class="line">            lp.rightMargin = consumedRight;</span><br><span class="line">            lp.bottomMargin = consumedBottom;</span><br><span class="line">            lp.leftMargin = consumedLeft;</span><br><span class="line">            //这里将上下左右要消费的内边距赋值给MarginLayoutParams，让DecorView的子View去消费</span><br><span class="line">            mContentRoot.setLayoutParams(lp);</span><br><span class="line"></span><br><span class="line">            if (insets == null) &#123;</span><br><span class="line">                // The insets have changed, but we&#x27;re not currently in the process</span><br><span class="line">                // of dispatching them.</span><br><span class="line">                requestApplyInsets();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (insets != null) &#123;</span><br><span class="line">            //消费了的insets会在原来的insets基础上进行一次缩进，剩下的交给子view的onApplyWindowInsets去处理</span><br><span class="line">            insets = insets.inset(consumedLeft, consumedTop, consumedRight, consumedBottom);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (forceConsumingNavBar) &#123;</span><br><span class="line">        mBackgroundInsets = Insets.of(mLastLeftInset, 0, mLastRightInset, mLastBottomInset);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mBackgroundInsets = Insets.NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    updateBackgroundDrawable();</span><br><span class="line"></span><br><span class="line">    return insets;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>到DecorView处理完WindowInsets返回时，WindowInsets并没有消费完成，<br>会继续走ViewGroup中的newDispatchApplyWindowInsets将剩余的WindowInsets分发给子View，<br>也就是DecorView的mContentRoot，然后继续回调到onApplyWindowInsets，走默认的View中的实现<br>View.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public WindowInsets onApplyWindowInsets(WindowInsets insets) &#123;</span><br><span class="line">        //这里判断了flag来决定后续的处理</span><br><span class="line">        //PFLAG4_FRAMEWORK_OPTIONAL_FITS_SYSTEM_WINDOWS在PhoneWidnow中设置了--mDecor.makeFrameworkOptionalFitsSystemWindows()</span><br><span class="line">        //而FITS_SYSTEM_WINDOWS这个默认是读取View的fitsSystemWindows这个属性值，目前DecorView的mContentRoot在xml中默认是fitsSystemWindows</span><br><span class="line">        //所以一定会走onApplyFrameworkOptionalFitSystemWindows</span><br><span class="line">        if ((mPrivateFlags4 &amp; PFLAG4_FRAMEWORK_OPTIONAL_FITS_SYSTEM_WINDOWS) != 0</span><br><span class="line">                &amp;&amp; (mViewFlags &amp; FITS_SYSTEM_WINDOWS) != 0) &#123;</span><br><span class="line">            return onApplyFrameworkOptionalFitSystemWindows(insets);</span><br><span class="line">        &#125;</span><br><span class="line">        if ((mPrivateFlags3 &amp; PFLAG3_FITTING_SYSTEM_WINDOWS) == 0) &#123;</span><br><span class="line">            // We weren&#x27;t called from within a direct call to fitSystemWindows,</span><br><span class="line">            // call into it as a fallback in case we&#x27;re in a class that overrides it</span><br><span class="line">            // and has logic to perform.</span><br><span class="line">            if (fitSystemWindows(insets.getSystemWindowInsetsAsRect())) &#123;</span><br><span class="line">                return insets.consumeSystemWindowInsets();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // We were called from within a direct call to fitSystemWindows.</span><br><span class="line">            if (fitSystemWindowsInt(insets.getSystemWindowInsetsAsRect())) &#123;</span><br><span class="line">                return insets.consumeSystemWindowInsets();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return insets;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    private WindowInsets onApplyFrameworkOptionalFitSystemWindows(WindowInsets insets) &#123;</span><br><span class="line">        Rect localInsets = sThreadLocal.get();</span><br><span class="line">        //去计算要消费的insets保存到localInsets中，然后返回消费完剩余的WindowInsets</span><br><span class="line">        WindowInsets result = computeSystemWindowInsets(insets, localInsets);</span><br><span class="line">        //这里就是将要消费的insets设置为padding</span><br><span class="line">        applyInsets(localInsets);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public WindowInsets computeSystemWindowInsets(WindowInsets in, Rect outLocalInsets) &#123;</span><br><span class="line">        boolean isOptionalFitSystemWindows = (mViewFlags &amp; OPTIONAL_FITS_SYSTEM_WINDOWS) != 0</span><br><span class="line">                || (mPrivateFlags4 &amp; PFLAG4_FRAMEWORK_OPTIONAL_FITS_SYSTEM_WINDOWS) != 0;</span><br><span class="line">        if (isOptionalFitSystemWindows &amp;&amp; mAttachInfo != null) &#123;</span><br><span class="line">            OnContentApplyWindowInsetsListener listener =</span><br><span class="line">                    mAttachInfo.mContentOnApplyWindowInsetsListener;</span><br><span class="line">            if (listener == null) &#123;</span><br><span class="line">                // The application wants to take care of fitting system window for</span><br><span class="line">                // the content.</span><br><span class="line">                outLocalInsets.setEmpty();</span><br><span class="line">                return in;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里就是去调用在onAttachedToWindow时设置的默认的WindowInsets处理</span><br><span class="line">            Pair&lt;Insets, WindowInsets&gt; result = listener.onContentApplyWindowInsets(this, in);</span><br><span class="line">            outLocalInsets.set(result.first.toRect());</span><br><span class="line">            return result.second;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            outLocalInsets.set(in.getSystemWindowInsetsAsRect());</span><br><span class="line">            return in.consumeSystemWindowInsets().inset(outLocalInsets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    private void applyInsets(Rect insets) &#123;</span><br><span class="line">        mUserPaddingStart = UNDEFINED_PADDING;</span><br><span class="line">        mUserPaddingEnd = UNDEFINED_PADDING;</span><br><span class="line">        mUserPaddingLeftInitial = insets.left;</span><br><span class="line">        mUserPaddingRightInitial = insets.right;</span><br><span class="line">        internalSetPadding(insets.left, insets.top, insets.right, insets.bottom);</span><br><span class="line">    &#125;        </span><br></pre></td></tr></table></figure>
<p>默认的insets计算逻辑在onAttachedToWindow时进行了设置，默认的逻辑在PhoneWindow中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static final OnContentApplyWindowInsetsListener sDefaultContentInsetsApplier =</span><br><span class="line">        (view, insets) -&gt; &#123;</span><br><span class="line">            //这里的View其时是DecorView下的子View,即DecorView的mContentRoot</span><br><span class="line">            //判断的是如果有SYSTEM_UI_FLAG_LAYOUT_xxx相关的Flag，根布局不消费内边距，继续传递给子视图</span><br><span class="line">            if ((view.getWindowSystemUiVisibility() &amp; SYSTEM_UI_LAYOUT_FLAGS) != 0) &#123;</span><br><span class="line">                return new Pair&lt;&gt;(Insets.NONE, insets);</span><br><span class="line">            &#125;</span><br><span class="line">            //否则就会根据mCompatInsetsTypes去获取系统窗口所占用的位置，mCompatInsetsTypes和flag有关</span><br><span class="line">            Insets insetsToApply = insets.getSystemWindowInsets();</span><br><span class="line">            //最后返回2个对象</span><br><span class="line">            //第一个insetsToApply是需要DecorView下的子View处理的内边距</span><br><span class="line">            //第二个是 原来的insets移除insetsToApply这一部分也标记为消费</span><br><span class="line">            return new Pair&lt;&gt;(insetsToApply,</span><br><span class="line">                    insets.inset(insetsToApply).consumeSystemWindowInsets());</span><br><span class="line">        &#125;; </span><br></pre></td></tr></table></figure>

<p>所以针对WindowInsets，首先会在DecorView中的updateColorViews中计算消费一次，<br>再把剩下未消费的分发给DecorView的子View mContentRoot 去计算消费一次，<br>需要理清在updateColorViews消费的逻辑和在mContentRoot中消费的逻辑</p>
<h3 id="在DecorView的updateColorViews中对WindowInsets的消费"><a href="#在DecorView的updateColorViews中对WindowInsets的消费" class="headerlink" title="在DecorView的updateColorViews中对WindowInsets的消费"></a>在DecorView的updateColorViews中对WindowInsets的消费</h3><p>在updataColorViews中主要判断的consumingStatusBar和consumingNavBar<br>这里主要来看这2段逻辑，在这里有一些是默认配置的，一般值是固定的<br>如：</p>
<ul>
<li>mForceWindowDrawsBarBackgrounds 读取的config_forceWindowDrawsStatusBarBackground的值，默认为true</li>
<li>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 在PhoneWindow中设置的，一般为true，读的windowDrawsSystemBarBackgrounds属性</li>
<li>mDecorFitsSystemWindows 默认为true</li>
<li>mLastShouldAlwaysConsumeSystemBars 在Android11中为true，在WMS中addWindow时加了ADD_FLAG_USE_TRIPLE_BUFFERING，和ADD_FLAG_ALWAYS_CONSUME_SYSTEM_BARS值一样导致在ViewRootImpl中mAlwaysConsumeSystemBars初始化为true</li>
<li>FLAG_LAYOUT_IN_SCREEN 在PhoneWindow中设置的，windowIsFloating为flase的情况下会设置</li>
<li>FLAG_LAYOUT_INSET_DECOR 在PhoneWindow中设置的，windowIsFloating为flase的情况下会设置<br>这里Decorview消费Insets是对mContentRoot设置margin。<br>根据逻辑来看，<br>DecorView是否消费导航栏主要和APP行为有关，app没有主动隐藏导航栏并且没有指定从最底部开始布局，就会给mContentRoot设置margin<br>一旦app请求了隐藏导航栏，或者指定了从最底部开始布局，就不会处理insets，交给mContentRoot去处理设置padding</li>
</ul>
<p>DecorView一般不消费状态栏</p>
<p>所以一般正常情况下，Decorview会去消费导航栏，但不消费状态栏，即给mContentRoot底部设置margin，顶部交给mContentRoot去处理padding</p>
<p>Decorview会消费导航栏，除非app指定隐藏导航栏，此时就会丢给mContentRoot去处理设置padding<br>Decorview一般不会消费状态栏，app请求隐藏状态栏时，Decorview也不消费，分发给mContentRoot去处理设置padding</p>
<p>代码的逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">WindowInsets updateColorViews(WindowInsets insets, boolean animate) &#123;</span><br><span class="line">    //......</span><br><span class="line">    //设置了SYSTEM_UI_FLAG_HIDE_NAVIGATION flag 或者WindowInsetsController主动请求隐藏导航栏</span><br><span class="line">    boolean hideNavigation = (sysUiVisibility &amp; SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0</span><br><span class="line">            || !(controller == null || controller.isRequestedVisible(ITYPE_NAVIGATION_BAR));</span><br><span class="line">    //decorFitsSystemWindows默认为true</span><br><span class="line">    boolean decorFitsSystemWindows = mWindow.mDecorFitsSystemWindows;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    //由于 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 默认一般是true</span><br><span class="line">    //要满足没有FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 并且 app正常非全屏（没有指定根布局从最底部开始，没有主动请求隐藏导航栏） 在第一个条件就false了</span><br><span class="line">    // 另一种情况是 主动请求隐藏导航栏 但是 WindowInsets中指定了要始终消费系统栏 （这种场景很难想像，app主动隐藏状态栏就是想全屏，Decorview此时强制消费留白界面会很奇怪）</span><br><span class="line">    //所以一般情况下DecorView不会强制消费导航栏（不会强制给mContentRoot设置margin）</span><br><span class="line">    boolean forceConsumingNavBar = (mForceWindowDrawsBarBackgrounds</span><br><span class="line">                    &amp;&amp; (attrs.flags &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0</span><br><span class="line">                    &amp;&amp; (sysUiVisibility &amp; SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0</span><br><span class="line">                    &amp;&amp; decorFitsSystemWindows</span><br><span class="line">                    &amp;&amp; !hideNavigation)</span><br><span class="line">            || (mLastShouldAlwaysConsumeSystemBars &amp;&amp; hideNavigation);</span><br><span class="line"></span><br><span class="line">    //消费导航栏的情况</span><br><span class="line">    //1. 强制消费导航栏 （一般不满足）</span><br><span class="line">    //2. 没有主动隐藏导航栏 并且 没有指定根布局从最底部开始</span><br><span class="line">    boolean consumingNavBar =</span><br><span class="line">            ((attrs.flags &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0</span><br><span class="line">                    &amp;&amp; (sysUiVisibility &amp; SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0</span><br><span class="line">                    &amp;&amp; decorFitsSystemWindows</span><br><span class="line">                    &amp;&amp; !hideNavigation)</span><br><span class="line">            || forceConsumingNavBar;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //app请求全屏</span><br><span class="line">    boolean fullscreen = (sysUiVisibility &amp; SYSTEM_UI_FLAG_FULLSCREEN) != 0</span><br><span class="line">            || (attrs.flags &amp; FLAG_FULLSCREEN) != 0</span><br><span class="line">            || !(controller == null || controller.isRequestedVisible(ITYPE_STATUS_BAR));</span><br><span class="line">    //消费状态栏的情况</span><br><span class="line">    //1.没有请求从顶部开始布局，并且还有没有FLAG_LAYOUT_IN_SCREEN，FLAG_LAYOUT_INSET_DECOR，flag条件一般不满足，针对floatingwindow会消费状态栏</span><br><span class="line">    //2.mLastShouldAlwaysConsumeSystemBars并且app请求了全屏，mLastShouldAlwaysConsumeSystemBars一般不满足</span><br><span class="line">    boolean consumingStatusBar = (sysUiVisibility &amp; SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN) == 0</span><br><span class="line">            &amp;&amp; decorFitsSystemWindows</span><br><span class="line">            &amp;&amp; (attrs.flags &amp; FLAG_LAYOUT_IN_SCREEN) == 0</span><br><span class="line">            &amp;&amp; (attrs.flags &amp; FLAG_LAYOUT_INSET_DECOR) == 0</span><br><span class="line">            &amp;&amp; mForceWindowDrawsBarBackgrounds</span><br><span class="line">            &amp;&amp; mLastTopInset != 0</span><br><span class="line">            || (mLastShouldAlwaysConsumeSystemBars &amp;&amp; fullscreen);                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在DecorView的mContentRoot中消费WindowInsets的逻辑"><a href="#在DecorView的mContentRoot中消费WindowInsets的逻辑" class="headerlink" title="在DecorView的mContentRoot中消费WindowInsets的逻辑"></a>在DecorView的mContentRoot中消费WindowInsets的逻辑</h3><p>由于在DecorView中基本上不会处理状态栏产生的Insets,所以状态栏相关的Insets基本上都在mContentRoot中处理的，<br>只要app加了SYSTEM_UI_FLAG_LAYOUT_xxx相关的Flag，mContentRoot就不会处理Insets，会继续传递给子View，<br>触发子View的onApplyWindowInsets继续走OnContentApplyWindowInsetsListener的onContentApplyWindowInsets。<br>只要有SYSTEM_UI_FLAG_LAYOUT_xxx相关的Flag，默认的处理逻辑是所有分发到的View都不处理。<br>没有的话，父容器一旦处理了，后续就不会继续分发了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static final OnContentApplyWindowInsetsListener sDefaultContentInsetsApplier =</span><br><span class="line">        (view, insets) -&gt; &#123;</span><br><span class="line">            //这里的View其时是DecorView下的子View,即DecorView的mContentRoot</span><br><span class="line">            //判断的是如果有SYSTEM_UI_FLAG_LAYOUT_xxx相关的Flag，根布局不消费内边距，继续传递给子视图</span><br><span class="line">            if ((view.getWindowSystemUiVisibility() &amp; SYSTEM_UI_LAYOUT_FLAGS) != 0) &#123;</span><br><span class="line">                return new Pair&lt;&gt;(Insets.NONE, insets);</span><br><span class="line">            &#125;</span><br><span class="line">            //否则就会根据mCompatInsetsTypes去获取系统窗口所占用的位置，mCompatInsetsTypes和flag有关</span><br><span class="line">            Insets insetsToApply = insets.getSystemWindowInsets();</span><br><span class="line">            //最后返回2个对象</span><br><span class="line">            //第一个insetsToApply是需要DecorView下的子View处理的内边距</span><br><span class="line">            //第二个是 原来的insets移除insetsToApply这一部分也标记为消费</span><br><span class="line">            return new Pair&lt;&gt;(insetsToApply,</span><br><span class="line">                    insets.inset(insetsToApply).consumeSystemWindowInsets());</span><br><span class="line">        &#125;; </span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Fireflies</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/pages/614bde/">http://example.com/pages/614bde/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Fireflies's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/pages/4b117f/" title="Toast"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Toast</div></div></a></div><div class="next-post pull-right"><a href="/pages/99f85c/" title="Handler"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Handler</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fireflies</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FirefliesL"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">简单概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Insets%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">Insets的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Insets%E7%9A%84%E6%96%B9%E5%90%91%EF%BC%88%E4%BE%A7%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">Insets的方向（侧）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%86%85%E8%BE%B9%E8%B7%9D%E6%B6%88%E8%B4%B9"><span class="toc-number">4.</span> <span class="toc-text">关于内边距消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WindowInsets"><span class="toc-number">5.</span> <span class="toc-text">WindowInsets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InsetsState"><span class="toc-number">6.</span> <span class="toc-text">InsetsState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAActivity%E5%88%9B%E5%BB%BA%E6%97%B6Insets%E7%9B%B8%E5%85%B3%E9%80%BB%E8%BE%91"><span class="toc-number">7.</span> <span class="toc-text">一个Activity创建时Insets相关逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity%E4%B8%AD%E7%9A%84Insets%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">8.</span> <span class="toc-text">Activity中的Insets值的计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity%E4%B8%AD%E8%AE%BE%E7%BD%AEInsets%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">Activity中设置Insets的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewRootImpl%E2%80%93getWindowInsets%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%AA%97%E5%8F%A3%E7%9A%84insets%EF%BC%88%E5%86%85%E8%BE%B9%E8%B7%9D%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">ViewRootImpl–getWindowInsets，获取当前窗口的insets（内边距）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View%E2%80%93dispatchApplyWindowInsets%EF%BC%8C%E5%A4%84%E7%90%86insets-%E6%B6%88%E8%B4%B9%E5%86%85%E8%BE%B9%E8%B7%9D"><span class="toc-number">9.2.</span> <span class="toc-text">View–dispatchApplyWindowInsets，处理insets(消费内边距)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8DecorView%E7%9A%84updateColorViews%E4%B8%AD%E5%AF%B9WindowInsets%E7%9A%84%E6%B6%88%E8%B4%B9"><span class="toc-number">9.3.</span> <span class="toc-text">在DecorView的updateColorViews中对WindowInsets的消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8DecorView%E7%9A%84mContentRoot%E4%B8%AD%E6%B6%88%E8%B4%B9WindowInsets%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-number">9.4.</span> <span class="toc-text">在DecorView的mContentRoot中消费WindowInsets的逻辑</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/25/android_fw/26.AdbService/" title="AdbService">AdbService</a><time datetime="2024-12-25T14:50:32.000Z" title="发表于 2024-12-25 14:50:32">2024-12-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/11/android_fw/56.ActivityView/" title="ActivityView">ActivityView</a><time datetime="2024-12-11T10:51:06.000Z" title="发表于 2024-12-11 10:51:06">2024-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/06/android_fw/55.%E9%BB%98%E8%AE%A4%E8%BE%93%E5%85%A5%E6%B3%95/" title="默认输入法">默认输入法</a><time datetime="2024-12-06T15:40:04.000Z" title="发表于 2024-12-06 15:40:04">2024-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/03/%E5%85%B6%E5%AE%83/22.gradle%E7%AC%94%E8%AE%B0/" title="gradle笔记">gradle笔记</a><time datetime="2024-12-03T17:48:28.000Z" title="发表于 2024-12-03 17:48:28">2024-12-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/02/%E5%85%B6%E5%AE%83/21.javadoc%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3/" title="javadoc生成文档">javadoc生成文档</a><time datetime="2024-12-02T16:41:51.000Z" title="发表于 2024-12-02 16:41:51">2024-12-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By Fireflies</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>