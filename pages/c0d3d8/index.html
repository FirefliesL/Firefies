<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WMS | Fireflies's blog</title><meta name="author" content="Fireflies"><meta name="copyright" content="Fireflies"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="先看看WMS的启动SystemServer的startOtherServices中启动的。 1234567891011t.traceBegin(&quot;StartWindowManagerService&quot;);&#x2F;&#x2F; WMS needs sensor service readyConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceS">
<meta property="og:type" content="article">
<meta property="og:title" content="WMS">
<meta property="og:url" content="http://example.com/pages/c0d3d8/index.html">
<meta property="og:site_name" content="Fireflies&#39;s blog">
<meta property="og:description" content="先看看WMS的启动SystemServer的startOtherServices中启动的。 1234567891011t.traceBegin(&quot;StartWindowManagerService&quot;);&#x2F;&#x2F; WMS needs sensor service readyConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-03-27T11:08:08.000Z">
<meta property="article:modified_time" content="2025-01-14T08:14:21.166Z">
<meta property="article:author" content="Fireflies">
<meta property="article:tag" content="Android Framework">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/ico.jpg"><link rel="canonical" href="http://example.com/pages/c0d3d8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WMS',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-14 08:14:21'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #FF8F00)"><nav id="nav"><span id="blog-info"><a href="/" title="Fireflies's blog"><img class="site-icon" src="/img/avatar.jpg"/><span class="site-name">Fireflies's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">WMS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-27T11:08:08.000Z" title="发表于 2023-03-27 11:08:08">2023-03-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-14T08:14:21.166Z" title="更新于 2025-01-14 08:14:21">2025-01-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="WMS"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="先看看WMS的启动"><a href="#先看看WMS的启动" class="headerlink" title="先看看WMS的启动"></a>先看看WMS的启动</h2><p>SystemServer的startOtherServices中<a target="_blank" rel="noopener" href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/java/com/android/server/SystemServer.java#1163">启动</a>的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t.traceBegin(&quot;StartWindowManagerService&quot;);</span><br><span class="line">// WMS needs sensor service ready</span><br><span class="line">ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);</span><br><span class="line">mSensorServiceStart = null;</span><br><span class="line">wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,</span><br><span class="line">        new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);</span><br><span class="line">ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= */ false,</span><br><span class="line">        DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);</span><br><span class="line">ServiceManager.addService(Context.INPUT_SERVICE, inputManager,</span><br><span class="line">        /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">t.traceEnd();</span><br></pre></td></tr></table></figure>

<p>主要逻辑：<br>在DisplayThread（android.display）中调用handler的runWithScissors创建了一个WindowManagerService.<br>关于runWithScissors，可以理解为在当前线程中插入一个优先执行的任务。当前的线程会被阻塞，直到runWithScissors中的runnable执行完毕。</p>
<p>WMS的构造方法中初始化&#x2F;保存ATMS、WindowManagerPolicy、InputManagerService等多个系统服务</p>
<p>WMS创建成功后，继续SystemServer的后续流程，会调用<code>wm.onInitReady();</code><br>在该方法中</p>
<ol>
<li>initPolicy：<br> 在UiThread（android.ui）中调用handler的runWithScissors 去执行WindowManagerPolicy的init方法，<br> WindowManagerPolicy在SystemServer初始化WMS时传入，是一个PhoneWindowManager</li>
<li>wms加入watchdog</li>
<li>createWatermark, 创建水印？源码看着是去读的&#x2F;system&#x2F;etc&#x2F;setup.conf</li>
</ol>
<p>继续回到SystemServer，还会依次调用<br><code>wm.displayReady();</code> 更新显示配置<br><code>wm.systemReady();</code> 在UI线程调用了SettingsObserver的loadSettings，更新systemui的设置等</p>
<h2 id="WMS的整体架构"><a href="#WMS的整体架构" class="headerlink" title="WMS的整体架构"></a>WMS的整体架构</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  classDiagram
ConfigurationContainer &lt;|-- WindowProcessController
ConfigurationContainer &lt;|-- WindowContainer
WindowContainer &lt;|-- WindowState
WindowContainer &lt;|-- DisplayArea
WindowContainer &lt;|-- DisplayContent
WindowContainer &lt;|-- RootWindowContainer
WindowContainer &lt;|-- WindowToken
WindowContainer &lt;|-- Task
Task &lt;|-- ActivityStack
WindowToken &lt;|-- ActivityRecord

  </pre></div>

<h2 id="WMS中的一些重要成员"><a href="#WMS中的一些重要成员" class="headerlink" title="WMS中的一些重要成员"></a>WMS中的一些重要成员</h2><p>WMS源码8000多行，成员变量比较多，暂时先列出一些，边看边记录，后续慢慢补充。</p>
<h3 id="WindowManagerPolicy-mPolicy"><a href="#WindowManagerPolicy-mPolicy" class="headerlink" title="WindowManagerPolicy[mPolicy]"></a>WindowManagerPolicy[mPolicy]</h3><p>WindowManagerPolicy是窗口管理策略的接口类，用来定义一个窗口策略所要遵循的通用规范，并提供了WindowManager所有的特定的UI行为。它的具体实现类为PhoneWindowManager，这个实现类在WMS创建时被创建。WMP允许定制窗口层级和特殊窗口类型以及关键的调度和布局。</p>
<h3 id="AppOpsManager-mAppOps"><a href="#AppOpsManager-mAppOps" class="headerlink" title="AppOpsManager[mAppOps]"></a>AppOpsManager[mAppOps]</h3><p>源码中解释 App-ops 用于访问控制和跟踪，WMS中只在构造方法中调用了startWatchingMode，监听了system_dialog和toast，会在收到回调时更新window状态</p>
<h3 id="DisplayWindowSettings-mDisplayWindowSettings"><a href="#DisplayWindowSettings-mDisplayWindowSettings" class="headerlink" title="DisplayWindowSettings[mDisplayWindowSettings]"></a>DisplayWindowSettings[mDisplayWindowSettings]</h3><p>保存window的显示设置的实体类</p>
<h3 id="ArraySet-mSessions"><a href="#ArraySet-mSessions" class="headerlink" title="ArraySet[mSessions]"></a>ArraySet[mSessions]</h3><p>保存的当前活动的客户端的会话。session主要用于记录请求WMS接口的客户端信息，应用程序想要和WMS进行通信就需要经过Session，并且每个应用程序进程都会对应一个Session，WMS保存这些Session用来记录所有向WMS提出窗口管理服务的客户端。</p>
<h3 id="HashMap-mWindowMap"><a href="#HashMap-mWindowMap" class="headerlink" title="HashMap[mWindowMap]"></a>HashMap[mWindowMap]</h3><p>保存windowtoke映射的WindowState的map，这里涉及到WindowState，可以把一个WindowState认为是一个窗口，WindowState内部保存了窗口的各种信息</p>
<h3 id="HashMap-mInputToWindowMap"><a href="#HashMap-mInputToWindowMap" class="headerlink" title="HashMap[mInputToWindowMap]"></a>HashMap[mInputToWindowMap]</h3><p>维护输入事件和窗口的映射关系</p>
<h3 id="WindowManagerGlobalLock-mGlobalLock"><a href="#WindowManagerGlobalLock-mGlobalLock" class="headerlink" title="WindowManagerGlobalLock[mGlobalLock]"></a>WindowManagerGlobalLock[mGlobalLock]</h3><p>wms中的全局锁，wms中很多地方都用了这个锁来保证数据的同步，这个锁在ActivityTaskManagerService创建的.</p>
<h2 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h2><p>window的实现类，持有一个DecorView.</p>
<h2 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h2><p>RootWindowContainer</p>
<h2 id="WindowManager-LaLayoutParams"><a href="#WindowManager-LaLayoutParams" class="headerlink" title="WindowManager.LaLayoutParams"></a>WindowManager.LaLayoutParams</h2><p>定义了一系列的window type，主要关注一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static final int FIRST_APPLICATION_WINDOW = 1;</span><br><span class="line">public static final int LAST_APPLICATION_WINDOW = 99;</span><br><span class="line"></span><br><span class="line">public static final int FIRST_SUB_WINDOW = 1000;</span><br><span class="line">public static final int LAST_SUB_WINDOW = 1999;</span><br><span class="line"></span><br><span class="line">public static final int FIRST_SYSTEM_WINDOW     = 2000;</span><br><span class="line">public static final int LAST_SYSTEM_WINDOW      = 2999;</span><br></pre></td></tr></table></figure>

<p>也就是说 普通应用窗口的 type值 范围 1～99；子窗口 1000～1999；系统窗口 2000～2999</p>
<p>另外还定义一系列的window flag,以<code>FLAG_</code>开始，具体用到再去看</p>
<p>还定义了一系列软键盘相关的模式，以<code>SOFT_INPUT_</code>字段开始</p>
<h2 id="一些FLAG的记录"><a href="#一些FLAG的记录" class="headerlink" title="一些FLAG的记录"></a>一些FLAG的记录</h2><h3 id="View-SYSTEM-UI-FLAG-LAYOUT-STABLE"><a href="#View-SYSTEM-UI-FLAG-LAYOUT-STABLE" class="headerlink" title="View.SYSTEM_UI_FLAG_LAYOUT_STABLE"></a>View.SYSTEM_UI_FLAG_LAYOUT_STABLE</h3><p>稳定布局，当StatusBar和NavigationBar的显示和隐藏，系统为View设置的padding都不会变化,意味着会默认加入最大的insets</p>
<h3 id="View-SYSTEM-UI-FLAG-LAYOUT-HIDE-NAVIGATION"><a href="#View-SYSTEM-UI-FLAG-LAYOUT-HIDE-NAVIGATION" class="headerlink" title="View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION"></a>View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</h3><p>布局底部可以到达导航栏底部，但布局被导航栏遮挡<br>在不隐藏导航栏的情况下，将Activity的显示范围扩展到导航栏底部。同时Activity的部分内容也因此被NavigationBar覆盖遮挡</p>
<h3 id="View-SYSTEM-UI-FLAG-LAYOUT-FULLSCREEN"><a href="#View-SYSTEM-UI-FLAG-LAYOUT-FULLSCREEN" class="headerlink" title="View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN"></a>View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</h3><p>布局顶部可以到达状态栏顶部，但布局被状态栏遮挡<br>在不隐藏StatusBar的情况下，将view所在window的显示范围扩展到StatusBar下面。同时Activity的部分内容也因此被StatusBar覆盖遮挡。</p>
<h3 id="View-SYSTEM-UI-FLAG-HIDE-NAVIGATION"><a href="#View-SYSTEM-UI-FLAG-HIDE-NAVIGATION" class="headerlink" title="View.SYSTEM_UI_FLAG_HIDE_NAVIGATION"></a>View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</h3><p>隐藏系统NavigationBar，但是用户的任何交互，都会导致此Flag被系统清除，进而导航栏自动重新显示</p>
<h3 id="View-SYSTEM-UI-FLAG-FULLSCREEN"><a href="#View-SYSTEM-UI-FLAG-FULLSCREEN" class="headerlink" title="View.SYSTEM_UI_FLAG_FULLSCREEN"></a>View.SYSTEM_UI_FLAG_FULLSCREEN</h3><p>作用是隐藏StatusBar，但是用户的下拉状态栏操作，会导致此Flag被系统清除，进而状态栏自动重新显示</p>
<h3 id="View-SYSTEM-UI-FLAG-IMMERSIVE-STICKY"><a href="#View-SYSTEM-UI-FLAG-IMMERSIVE-STICKY" class="headerlink" title="View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY"></a>View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY</h3><p>避免某些用户交互造成系统自动清除全屏状态，配合 SYSTEM_UI_FLAG_FULLSCREEN  SYSTEM_UI_FLAG_HIDE_NAVIGATION 使用<br>默认情况下：<br>如果用户从屏幕顶部滑动，系统将强制清除<code>SYSTEM_UI_FLAG_FULLSCREEN</code><br>任何用户交互都会清除<code>SYSTEM_UI_FLAG_HIDE_NAVIGATION</code><br>所以这个flag配合状态栏|导航栏隐藏的flag使用后，下拉菜单会暂时显示状态栏|导航栏，超时后自动隐藏</p>
<h2 id="影响布局，不影响系统窗口"><a href="#影响布局，不影响系统窗口" class="headerlink" title="影响布局，不影响系统窗口"></a>影响布局，不影响系统窗口</h2><p>这2个flag都是布局范围调整，但对系统状态栏没影响的flag：</p>
<ol>
<li>SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN             布局以状态栏顶部为顶部<br> 配合fitSystemWindow&#x3D;true的view，会被系统自动添加大小为statusBar和ActionBar高度之和相同的paddingTop</li>
<li>SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION        布局以导航栏底部为底部<br> 配合fitSystemWindow&#x3D;true的view，会被系统自动添加大小为NavigationBar高度相同的paddingBottom</li>
</ol>
<h2 id="影响布局和系统窗口"><a href="#影响布局和系统窗口" class="headerlink" title="影响布局和系统窗口"></a>影响布局和系统窗口</h2><p>这两个flag影响布局，同时会隐藏对应的系统窗口，但用户交互会清除这2个flag：</p>
<ol>
<li>SYSTEM_UI_FLAG_FULLSCREEN            布局以状态栏顶部为顶部，隐藏状态栏</li>
<li>SYSTEM_UI_FLAG_HIDE_NAVIGATION       布局以导航栏底部为底部，隐藏导航栏</li>
</ol>
<p>配合 SYSTEM_UI_FLAG_IMMERSIVE_STICKY 使用，避免flag被清除</p>
<p>FITS_SYSTEM_WINDOWS + SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 会加padding</p>
<p>SYSTEM_UI_FLAG_LAYOUT_STABLE + SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 左侧无法</p>
<h2 id="WindowManager-addView"><a href="#WindowManager-addView" class="headerlink" title="WindowManager#addView"></a>WindowManager#addView</h2><p>在Activity第一次resume的时候，会调用WindowManager的addView。</p>
<p>WindowManagerImpl.addView<br>WindowManagerGlobal.addView</p>
<p>在WindowManagerGlobal的addView方法内部创建ViewRootImpl了，ViewRootImpl的构造方法中会去初始化WindowSession，<br>这个WindowSession是个静态全局变量，意味着每个进程只有一个WindowSession，这个WindowSession实际是调用wms的openSession得到的。</p>
<p>然后调用ViewRootImpl的setView，去requestLayout，并调用mWindowSession.addToDisplayAsUser.<br>而addToDisplayAsUser实际调用的就是WMS的addWindow</p>
<p>ActivityThread.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,</span><br><span class="line">            String reason) &#123;</span><br><span class="line">        //...</span><br><span class="line">        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            //......</span><br><span class="line">            if (a.mVisibleFromClient) &#123;</span><br><span class="line">                if (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = true;</span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // The activity will get a callback for this &#123;@link LayoutParams&#125; change</span><br><span class="line">                    // earlier. However, at that time the decor will not be set (this is set</span><br><span class="line">                    // in this method), so no action will be taken. This call ensures the</span><br><span class="line">                    // callback occurs with the decor set.</span><br><span class="line">                    a.onWindowAttributesChanged(l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If the window has already been added, but during resume</span><br><span class="line">            // we started another activity, then don&#x27;t yet make the</span><br><span class="line">            // window visible.</span><br><span class="line">        &#125; else if (!willBeVisible) &#123;</span><br><span class="line">            if (localLOGV || enableLifeCycleLog()) Slog.v(TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);</span><br><span class="line">            r.hideForNow = true;</span><br><span class="line">        &#125;</span><br><span class="line">        //......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>WindowManagerImpl.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,</span><br><span class="line">            mContext.getUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WindowManagerGlobal.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">        Display display, Window parentWindow, int userId) &#123;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = null;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        //......</span><br><span class="line">        root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line">        //......</span><br><span class="line">        // do this last because it fires off messages to start doing things</span><br><span class="line">        try &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView, userId);</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            //......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">public static IWindowSession getWindowSession() &#123;</span><br><span class="line">    synchronized (WindowManagerGlobal.class) &#123;</span><br><span class="line">        if (sWindowSession == null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // Emulate the legacy behavior.  The global instance of InputMethodManager</span><br><span class="line">                // was instantiated here.</span><br><span class="line">                // TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage</span><br><span class="line">                InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary();</span><br><span class="line">                IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        new IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void onAnimatorScaleChanged(float scale) &#123;</span><br><span class="line">                                ValueAnimator.setDurationScale(scale);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">public static IWindowManager getWindowManagerService() &#123;</span><br><span class="line">    synchronized (WindowManagerGlobal.class) &#123;</span><br><span class="line">        if (sWindowManagerService == null) &#123;</span><br><span class="line">            sWindowManagerService = IWindowManager.Stub.asInterface(</span><br><span class="line">                    ServiceManager.getService(&quot;window&quot;));</span><br><span class="line">            try &#123;</span><br><span class="line">                if (sWindowManagerService != null) &#123;</span><br><span class="line">                    ValueAnimator.setDurationScale(</span><br><span class="line">                            sWindowManagerService.getCurrentAnimatorScale());</span><br><span class="line">                    sUseBLASTAdapter = sWindowManagerService.useBLAST();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sWindowManagerService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewRootImpl.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public ViewRootImpl(Context context, Display display) &#123;</span><br><span class="line">    //在构造方法中初始化了mWindowSession</span><br><span class="line">    this(context, display, WindowManagerGlobal.getWindowSession(),</span><br><span class="line">            false /* useSfChoreographer */);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,</span><br><span class="line">        int userId) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mView == null) &#123;</span><br><span class="line">            //......</span><br><span class="line">            mAdded = true;</span><br><span class="line">            int res; /* = WindowManagerImpl.ADD_OKAY; */</span><br><span class="line"></span><br><span class="line">            // Schedule the first layout -before- adding to the window</span><br><span class="line">            // manager, to make sure we do the relayout before receiving</span><br><span class="line">            // any other events from the system.</span><br><span class="line">            requestLayout();</span><br><span class="line">            //......</span><br><span class="line">            </span><br><span class="line">            try &#123;</span><br><span class="line">                mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">                mAttachInfo.mRecomputeGlobalAttributes = true;</span><br><span class="line">                collectViewAttributes();</span><br><span class="line">                adjustLayoutParamsForCompatibility(mWindowAttributes);</span><br><span class="line">                //在这里调用windowSession的addToDisplayAsUser</span><br><span class="line">                res = mWindowSession.addToDisplayAsUser(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(), userId, mTmpFrame,</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mDisplayCutout, inputChannel,</span><br><span class="line">                        mTempInsets, mTempControls);</span><br><span class="line">                setFrame(mTmpFrame);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                mAdded = false;</span><br><span class="line">                mView = null;</span><br><span class="line">                mAttachInfo.mRootView = null;</span><br><span class="line">                inputChannel = null;</span><br><span class="line">                mFallbackEventHandler.setView(null);</span><br><span class="line">                unscheduleTraversals();</span><br><span class="line">                setAccessibilityFocus(null, null);</span><br><span class="line">                throw new RuntimeException(&quot;Adding window failed&quot;, e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (restore) &#123;</span><br><span class="line">                    attrs.restore();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Session.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int addToDisplayAsUser(IWindow window, int seq, WindowManager.LayoutParams attrs,</span><br><span class="line">        int viewVisibility, int displayId, int userId, Rect outFrame,</span><br><span class="line">        Rect outContentInsets, Rect outStableInsets,</span><br><span class="line">        DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,</span><br><span class="line">        InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) &#123;</span><br><span class="line">    //windowSession的addToDisplayAsUser实际调用的WMS的addWindow</span><br><span class="line">    return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outFrame,</span><br><span class="line">            outContentInsets, outStableInsets, outDisplayCutout, outInputChannel,</span><br><span class="line">            outInsetsState, outActiveControls, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="WindowManagerService-addWindow"><a href="#WindowManagerService-addWindow" class="headerlink" title="WindowManagerService#addWindow"></a>WindowManagerService#addWindow</h2><p>先列出几个看起来关键的点，后续再细看<br>WindowManagerService.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">public int addWindow(Session session, IWindow client, int seq,</span><br><span class="line">        LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame,</span><br><span class="line">        Rect outContentInsets, Rect outStableInsets,</span><br><span class="line">        DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,</span><br><span class="line">        InsetsState outInsetsState, InsetsSourceControl[] outActiveControls,</span><br><span class="line">        int requestUserId) &#123;</span><br><span class="line">    // 权限检查</span><br><span class="line">    int res = mPolicy.checkAddPermission(attrs.type, isRoundedCornerOverlay, attrs.packageName,</span><br><span class="line">            appOp);</span><br><span class="line">    if (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WindowState parentWindow = null;</span><br><span class="line">    final int callingUid = Binder.getCallingUid();</span><br><span class="line">    final int callingPid = Binder.getCallingPid();</span><br><span class="line">    final long origId = Binder.clearCallingIdentity();</span><br><span class="line">    // 拿到窗口层级</span><br><span class="line">    final int type = attrs.type;</span><br><span class="line"></span><br><span class="line">    synchronized (mGlobalLock) &#123;</span><br><span class="line">        // ....一些简单校验</span><br><span class="line"></span><br><span class="line">        // 判断是否重复添加</span><br><span class="line">        if (mWindowMap.containsKey(client.asBinder())) &#123;</span><br><span class="line">            ProtoLog.w(WM_ERROR, &quot;Window %s is already added&quot;, client);</span><br><span class="line">            return WindowManagerGlobal.ADD_DUPLICATE_ADD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 根据窗口层级进行一些逻辑校验</span><br><span class="line">        if (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        // 多用户校验</span><br><span class="line">        int userId = UserHandle.getUserId(session.mUid);</span><br><span class="line">        if (requestUserId != userId) &#123;</span><br><span class="line">            //......</span><br><span class="line">            // It&#x27;s fine to use this userId</span><br><span class="line">            userId = requestUserId;</span><br><span class="line">        &#125;</span><br><span class="line">        //......</span><br><span class="line">        ActivityRecord activity = null;</span><br><span class="line">        final boolean hasParent = parentWindow != null;            </span><br><span class="line">        //尝试去缓存的windowToken</span><br><span class="line">        WindowToken token = displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        </span><br><span class="line">        if (token == null) &#123;</span><br><span class="line">            if (!unprivilegedAppCanCreateTokenWith(parentWindow, callingUid, type,</span><br><span class="line">                    rootType, attrs.token, attrs.packageName)) &#123;</span><br><span class="line">                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果有父窗口，windowToken和父窗口一样</span><br><span class="line">            if (hasParent) &#123;</span><br><span class="line">                // Use existing parent window token for child windows.</span><br><span class="line">                token = parentWindow.mToken;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                final IBinder binder = attrs.token != null ? attrs.token : client.asBinder();</span><br><span class="line">                // 创建一个新的token</span><br><span class="line">                token = new WindowToken(this, binder, type, false, displayContent,</span><br><span class="line">                        session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        // ...... 对window的type的判断</span><br><span class="line"></span><br><span class="line">        else if (token.asActivityRecord() != null) &#123;</span><br><span class="line">            ProtoLog.w(WM_ERROR, &quot;Non-null activity for system window of rootType=%d&quot;,</span><br><span class="line">                    rootType);</span><br><span class="line">            // It is not valid to use an app token with other system types; we will</span><br><span class="line">            // instead make a new token for it (as if null had been passed in for the token).</span><br><span class="line">            attrs.token = null;</span><br><span class="line">            token = new WindowToken(this, client.asBinder(), type, false, displayContent,</span><br><span class="line">                    session.mCanAddInternalSystemWindow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 创建WindowState来记录window信息</span><br><span class="line">        final WindowState win = new WindowState(this, session, client, token, parentWindow,</span><br><span class="line">                appOp[0], seq, attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        if (win.mDeathRecipient == null) &#123;</span><br><span class="line">            // Client has apparently died, so there is no reason to</span><br><span class="line">            // continue.</span><br><span class="line">            ProtoLog.w(WM_ERROR, &quot;Adding window client %s&quot;</span><br><span class="line">                    + &quot; that is dead, aborting.&quot;, client.asBinder());</span><br><span class="line">            return WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (win.getDisplayContent() == null) &#123;</span><br><span class="line">            ProtoLog.w(WM_ERROR, &quot;Adding window to Display that has been removed.&quot;);</span><br><span class="line">            return WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final DisplayPolicy displayPolicy = displayContent.getDisplayPolicy();</span><br><span class="line">        // 这里是调整Window的属性，会去根据window的type和attr进行赋值调整</span><br><span class="line">        displayPolicy.adjustWindowParamsLw(win, win.mAttrs, callingPid, callingUid);</span><br><span class="line"></span><br><span class="line">        //判断是否允许添加window</span><br><span class="line">        res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);</span><br><span class="line">        if (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line">        // From now on, no exceptions or errors allowed!</span><br><span class="line"></span><br><span class="line">        res = WindowManagerGlobal.ADD_OKAY;</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        //保存windowState到map中</span><br><span class="line">        win.attach();</span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        win.initAppOpsState();</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        final ActivityRecord tokenActivity = token.asActivityRecord();</span><br><span class="line">        //根据window的type来记录启动窗口</span><br><span class="line">        if (type == TYPE_APPLICATION_STARTING &amp;&amp; tokenActivity != null) &#123;</span><br><span class="line">            tokenActivity.startingWindow = win;</span><br><span class="line">            ProtoLog.v(WM_DEBUG_STARTING_WINDOW, &quot;addWindow: %s startingWindow=%s&quot;,</span><br><span class="line">                    activity, win);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean imMayMove = true;</span><br><span class="line"></span><br><span class="line">        //windowToken将windowState记录下来，方法内部有逻辑如果windowState是子窗口不会被添加</span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        //交给displayPolicy去处理addWindow，主要是根据window type设置InsetProvider</span><br><span class="line">        displayPolicy.addWindowLw(win, attrs);</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        //开始处理窗口动画的状态，WindowState的WindowStateAnimator是在WindowState的构造方法中初始化的</span><br><span class="line">        final WindowStateAnimator winAnimator = win.mWinAnimator;</span><br><span class="line">        //设置window动画相关的flag</span><br><span class="line">        winAnimator.mEnterAnimationPending = true;</span><br><span class="line">        winAnimator.mEnteringAnimation = true;</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        // Don&#x27;t do layout here, the window must call</span><br><span class="line">        // relayout to be displayed, so we&#x27;ll do it there.</span><br><span class="line">        // 这里windowState的parent其实就是WindowToken，</span><br><span class="line">        win.getParent().assignChildLayers();</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        if (win.isVisibleOrAdding() &amp;&amp; displayContent.updateOrientation()) &#123;</span><br><span class="line">            displayContent.sendNewConfiguration();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getInsetsSourceControls(win, outActiveControls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;                  </span><br></pre></td></tr></table></figure>

<h2 id="WindowState"><a href="#WindowState" class="headerlink" title="WindowState"></a>WindowState</h2><p>在WindowState的构造方法中，除了一些变量赋值，也根据WindowManager.LayoutParams.type做了一些逻辑判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">    // The multiplier here is to reserve space for multiple</span><br><span class="line">    // windows in the same type layer.</span><br><span class="line">    //这里是拿到父窗口的层级值做了个运算，注释说这里的乘数是为了给多个同级窗口预留占为值</span><br><span class="line">    mBaseLayer = mPolicy.getWindowLayerLw(parentWindow)</span><br><span class="line">            * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br><span class="line">    //通过type计算子层级值</span><br><span class="line">    mSubLayer = mPolicy.getSubWindowLayerFromTypeLw(a.type);</span><br><span class="line">    mIsChildWindow = true;</span><br><span class="line"></span><br><span class="line">    mLayoutAttached = mAttrs.type !=</span><br><span class="line">            WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG;</span><br><span class="line">    mIsImWindow = parentWindow.mAttrs.type == TYPE_INPUT_METHOD</span><br><span class="line">            || parentWindow.mAttrs.type == TYPE_INPUT_METHOD_DIALOG;</span><br><span class="line">    mIsWallpaper = parentWindow.mAttrs.type == TYPE_WALLPAPER;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // The multiplier here is to reserve space for multiple</span><br><span class="line">    // windows in the same type layer.</span><br><span class="line">    mBaseLayer = mPolicy.getWindowLayerLw(this)</span><br><span class="line">            * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br><span class="line">    mSubLayer = 0;</span><br><span class="line">    mIsChildWindow = false;</span><br><span class="line">    mLayoutAttached = false;</span><br><span class="line">    mIsImWindow = mAttrs.type == TYPE_INPUT_METHOD</span><br><span class="line">            || mAttrs.type == TYPE_INPUT_METHOD_DIALOG;</span><br><span class="line">    mIsWallpaper = mAttrs.type == TYPE_WALLPAPER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DisplayFrames"><a href="#DisplayFrames" class="headerlink" title="DisplayFrames"></a>DisplayFrames</h2><p>DisplayFrames这个类用来保存了各种显示区域</p>
<ul>
<li>mUnrestricted：当前屏幕的可见大小，不考虑状态栏是否可隐藏，但不包括超出显示区域的部分（就是屏幕的非显示，如屏幕边框之类的不会包含）</li>
<li>mRestricted：当前屏幕的大小，如果状态栏不可隐藏，这个大小会减去状态栏的区域。</li>
<li>mSystem：布局过程中考虑当前可见系统 UI 元素的屏幕边界。</li>
<li>mStable：为应用程序请求稳定内容插图（insets）时的边界信息</li>
<li>mStableFullscreen：对于同时设置了全屏窗口标志和稳定内容插图的应用程序，这是没有状态栏的稳定尺寸。</li>
<li>mCurrent：布局过程中考虑所有外部装饰（状态栏、输入法停靠区等）的屏幕边界。</li>
<li>mContent：在布局过程中，用于显示用户内容的框架，考虑到所有屏幕装饰，通常和mCurrent一样，但如果屏幕装饰提供了内容插图，可能会更大。</li>
<li>mVoiceContent：在布局过程中，用于显示语音内容的框架，考虑到所有屏幕装饰。</li>
<li>mDock：布局过程中用于放置输入法窗口的屏幕边界。</li>
</ul>
<p>在performLayoutNoTrace中会先调用mDisplayPolicy.beginLayoutLw()&#x3D;&gt;DisplayFrames.onBeginLayout()<br>在onBeginLayout中将mUnrestricted 设置为 (0, 0, mDisplayWidth, mDisplayHeight),<br>并将mUnrestricted的rect值赋值给其他所有的显示区域，默认都是屏幕所有区域</p>
<h2 id="WindowFrames"><a href="#WindowFrames" class="headerlink" title="WindowFrames"></a>WindowFrames</h2><p>看起来和DisplayFrames很像，也是保存了各种显示区域，但这个是针对当前window用的，保存的是当前要布局的window的各种情况下的显示区域。<br>而DisplayFrames保存的是当前屏幕的各种显示区域，而WindowFrames保存的是当前window的显示区域，<br>一个屏幕上可能有多个window，同时显示时，每个WindowFrames数据不一样</p>
<ul>
<li>mParentFrame：</li>
</ul>
<h2 id="Displaypolicy-layoutWindowLw"><a href="#Displaypolicy-layoutWindowLw" class="headerlink" title="Displaypolicy#layoutWindowLw"></a>Displaypolicy#layoutWindowLw</h2><h2 id="强制显示下拉状态栏"><a href="#强制显示下拉状态栏" class="headerlink" title="强制显示下拉状态栏"></a>强制显示下拉状态栏</h2><p>在InsetsPolicy中的updateBarControlTarget中，会去更新statusbar和navbar的可见性<br>InsetsPolicy.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">void updateBarControlTarget(@Nullable WindowState focusedWin) &#123;</span><br><span class="line">    if (focusedWin != null &amp;&amp; (focusedWin.mAttrs.type == TYPE_APPLICATION_STARTING)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mFocusedWin != focusedWin)&#123;</span><br><span class="line">        abortTransient();</span><br><span class="line">    &#125;</span><br><span class="line">    mFocusedWin = focusedWin;</span><br><span class="line">    boolean forceShowsSystemBarsForWindowingMode = forceShowsSystemBarsForWindowingMode();</span><br><span class="line">    InsetsControlTarget statusControlTarget = getStatusControlTarget(focusedWin,</span><br><span class="line">            forceShowsSystemBarsForWindowingMode);</span><br><span class="line">    InsetsControlTarget navControlTarget = getNavControlTarget(focusedWin,</span><br><span class="line">            forceShowsSystemBarsForWindowingMode);</span><br><span class="line">    mStateController.onBarControlTargetChanged(statusControlTarget,</span><br><span class="line">            getFakeControlTarget(focusedWin, statusControlTarget),</span><br><span class="line">            navControlTarget,</span><br><span class="line">            getFakeControlTarget(focusedWin, navControlTarget));</span><br><span class="line">    if (ViewRootImpl.sNewInsetsMode != ViewRootImpl.NEW_INSETS_MODE_FULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //这里如果controlTarget是null，会让其可见</span><br><span class="line">    mStatusBar.updateVisibility(statusControlTarget, ITYPE_STATUS_BAR);</span><br><span class="line">    mNavBar.updateVisibility(navControlTarget, ITYPE_NAVIGATION_BAR);</span><br><span class="line">    mPolicy.updateHideNavInputEventReceiver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class BarWindow &#123;</span><br><span class="line"></span><br><span class="line">    private final int mId;</span><br><span class="line">    private  @StatusBarManager.WindowVisibleState int mState =</span><br><span class="line">            StatusBarManager.WINDOW_STATE_SHOWING;</span><br><span class="line"></span><br><span class="line">    BarWindow(int id) &#123;</span><br><span class="line">        mId = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void updateVisibility(InsetsControlTarget controlTarget,</span><br><span class="line">            @InternalInsetsType int type) &#123;</span><br><span class="line">        final WindowState controllingWin =</span><br><span class="line">                controlTarget instanceof WindowState ? (WindowState) controlTarget : null;</span><br><span class="line">        setVisible(controllingWin == null</span><br><span class="line">                || controllingWin.getRequestedInsetsState().getSourceOrDefaultVisibility(type));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setVisible(boolean visible) &#123;</span><br><span class="line">        final int state = visible ? WINDOW_STATE_SHOWING : WINDOW_STATE_HIDDEN;</span><br><span class="line">        if (mState != state) &#123;</span><br><span class="line">            mState = state;</span><br><span class="line">            mPolicy.getStatusBarManagerInternal().setWindowState(</span><br><span class="line">                    mDisplayContent.getDisplayId(), mId, state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h2 id="窗口层级"><a href="#窗口层级" class="headerlink" title="窗口层级"></a>窗口层级</h2><p>在DisplayContent中,在类加载的时候，默认初始化了4个WindowContainer：</p>
<ul>
<li>mWindowContainers</li>
<li>mOverlayContainers</li>
<li>ImeContainer</li>
<li>DisplayArea.Root<br>相关初始化和DisplayContent的构造方法如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Most surfaces will be a child of this window. There are some special layers and windows</span><br><span class="line"> * which are always on top of others and omitted from Screen-Magnification, for example the</span><br><span class="line"> * strict mode flash or the magnification overlay itself. Those layers will be children of</span><br><span class="line"> * &#123;@link #mOverlayContainers&#125; where mWindowContainers contains everything else.</span><br><span class="line"> */</span><br><span class="line">private final WindowContainers mWindowContainers =</span><br><span class="line">        new WindowContainers(&quot;mWindowContainers&quot;, mWmService);</span><br><span class="line"></span><br><span class="line">// Contains some special windows which are always on top of others and omitted from</span><br><span class="line">// Screen-Magnification, for example the WindowMagnification windows.</span><br><span class="line">private final NonAppWindowContainers mOverlayContainers =</span><br><span class="line">        new NonAppWindowContainers(&quot;mOverlayContainers&quot;, mWmService);</span><br><span class="line"></span><br><span class="line">/** The containers below are the only child containers &#123;@link #mWindowContainers&#125; can have. */</span><br><span class="line"></span><br><span class="line">// Contains all IME window containers. Note that the z-ordering of the IME windows will depend</span><br><span class="line">// on the IME target. We mainly have this container grouping so we can keep track of all the IME</span><br><span class="line">// window containers together and move them in-sync if/when needed. We use a subclass of</span><br><span class="line">// WindowContainer which is omitted from screen magnification, as the IME is never magnified.</span><br><span class="line">// TODO(display-area): is &quot;no magnification&quot; in the comment still true?</span><br><span class="line">private final ImeContainer mImeWindowsContainers = new ImeContainer(mWmService);</span><br><span class="line"></span><br><span class="line">private final DisplayArea.Root mRootDisplayArea = new DisplayArea.Root(mWmService);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DisplayContent(Display display, RootWindowContainer root) &#123;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    //这里是去初始化各个容器layer的开始</span><br><span class="line">    // These are the only direct children we should ever have and they are permanent.</span><br><span class="line">    super.addChild(mWindowContainers, null);</span><br><span class="line">    super.addChild(mOverlayContainers, null);</span><br><span class="line"></span><br><span class="line">    mDisplayAreaPolicy = mWmService.mDisplayAreaPolicyProvider.instantiate(</span><br><span class="line">            mWmService, this, mRootDisplayArea, mImeWindowsContainers);</span><br><span class="line">    mWindowContainers.addChildren();</span><br><span class="line"></span><br><span class="line">    // Sets the display content for the children.</span><br><span class="line">    onDisplayChanged(this);</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>看DisplayContent的父类WindowContainer中的addChild方法，就是将mWindowContainers和mOverlayContainers<br>按顺序加入一个ArrayList中，还需要看在哪里赋值的mLastLayer(即zOrder)<br>在WindowContainer调用addChild的最后一步会调用一次child.setParent(this),这里的this是DisplayContent，<br>child是mWindowContainers和mOverlayContainers，后续会回调child的onParentChanged，然后调用mParent.assignChildLayers()，<br>也就是DisplayContent的assignChildLayers</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Adds the input window container has a child of this container in order based on the input</span><br><span class="line"> * comparator.</span><br><span class="line"> * @param child The window container to add as a child of this window container.</span><br><span class="line"> * @param comparator Comparator to use in determining the position the child should be added to.</span><br><span class="line"> *                   If null, the child will be added to the top.</span><br><span class="line"> */</span><br><span class="line">@CallSuper</span><br><span class="line">protected void addChild(E child, Comparator&lt;E&gt; comparator) &#123;</span><br><span class="line">    if (!child.mReparenting &amp;&amp; child.getParent() != null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;addChild: container=&quot; + child.getName()</span><br><span class="line">                + &quot; is already a child of container=&quot; + child.getParent().getName()</span><br><span class="line">                + &quot; can&#x27;t add to container=&quot; + getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int positionToAdd = -1;</span><br><span class="line">    if (comparator != null) &#123;</span><br><span class="line">        final int count = mChildren.size();</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            if (comparator.compare(child, mChildren.get(i)) &lt; 0) &#123;</span><br><span class="line">                positionToAdd = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (positionToAdd == -1) &#123;</span><br><span class="line">        mChildren.add(child);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mChildren.add(positionToAdd, child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Set the parent after we&#x27;ve actually added a child in case a subclass depends on this.</span><br><span class="line">    child.setParent(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final protected void setParent(WindowContainer&lt;WindowContainer&gt; parent) &#123;</span><br><span class="line">    final WindowContainer oldParent = mParent;</span><br><span class="line">    mParent = parent;</span><br><span class="line"></span><br><span class="line">    if (mParent != null) &#123;</span><br><span class="line">        mParent.onChildAdded(this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!mReparenting) &#123;</span><br><span class="line">        if (mParent != null &amp;&amp; mParent.mDisplayContent != null</span><br><span class="line">                &amp;&amp; mDisplayContent != mParent.mDisplayContent) &#123;</span><br><span class="line">            onDisplayChanged(mParent.mDisplayContent);</span><br><span class="line">        &#125;</span><br><span class="line">        onParentChanged(mParent, oldParent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent) &#123;</span><br><span class="line">    onParentChanged(newParent, oldParent, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent,</span><br><span class="line">        PreAssignChildLayersCallback callback) &#123;</span><br><span class="line">    super.onParentChanged(newParent, oldParent);</span><br><span class="line">    if (mParent == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mSurfaceControl == null) &#123;</span><br><span class="line">        // If we don&#x27;t yet have a surface, but we now have a parent, we should</span><br><span class="line">        // build a surface.</span><br><span class="line">        createSurfaceControl(false /*force*/);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // If we have a surface but a new parent, we just need to perform a reparent. Go through</span><br><span class="line">        // surface animator such that hierarchy is preserved when animating, i.e.</span><br><span class="line">        // mSurfaceControl stays attached to the leash and we just reparent the leash to the</span><br><span class="line">        // new parent.</span><br><span class="line">        reparentSurfaceControl(getSyncTransaction(), mParent.mSurfaceControl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (callback != null) &#123;</span><br><span class="line">        callback.onPreAssignChildLayers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Either way we need to ask the parent to assign us a Z-order.</span><br><span class="line">    mParent.assignChildLayers();</span><br><span class="line">    scheduleAnimation();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><strong>可以看到DisplayContent的assignChildLayers中，将mOverlayContainers的layer设置为1，<br>mWindowContainers的layer设置为0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">void assignChildLayers(SurfaceControl.Transaction t) &#123;</span><br><span class="line">    mWindowContainers.assignLayer(t, 0);</span><br><span class="line">    mOverlayContainers.assignLayer(t, 1);</span><br><span class="line"></span><br><span class="line">    mWindowContainers.assignChildLayers(t);</span><br><span class="line">    mOverlayContainers.assignChildLayers(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看DisplayContent中的mDisplayAreaPolicy初始化，<br>DisplayAreaPolicy中，通过DisplayAreaPolicyBuilder来构造了一个DisplayAreaPolicy,<br>在builder中创建了一个DisplayAreaPolicy的子类Result实例，<br>在子类构造方法中调用了父类DisplayAreaPolicy的构造方法，将DisplayContent对象中的<br>mRootDisplayArea和mImeWindowsContainers传了进去。</p>
<p>DisplayAreaPolicy:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/** Provider for platform-default display area policy. */</span><br><span class="line">static final class DefaultProvider implements DisplayAreaPolicy.Provider &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public DisplayAreaPolicy instantiate(WindowManagerService wmService,</span><br><span class="line">            DisplayContent content, DisplayArea.Root root,</span><br><span class="line">            DisplayArea&lt;? extends WindowContainer&gt; imeContainer) &#123;</span><br><span class="line">        final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,</span><br><span class="line">                &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);</span><br><span class="line">        final List&lt;TaskDisplayArea&gt; tdaList = new ArrayList&lt;&gt;();</span><br><span class="line">        tdaList.add(defaultTaskDisplayArea);</span><br><span class="line">        return new DisplayAreaPolicyBuilder()</span><br><span class="line">                .build(wmService, content, root, imeContainer, tdaList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Construct a new &#123;@link DisplayAreaPolicy&#125;</span><br><span class="line"> *</span><br><span class="line"> * @param wmService the window manager service instance</span><br><span class="line"> * @param content the display content for which the policy applies</span><br><span class="line"> * @param root the root display area under which the policy operates</span><br><span class="line"> * @param imeContainer the ime container that the policy must attach</span><br><span class="line"> * @param taskDisplayAreas the task display areas that the policy must attach</span><br><span class="line"> *</span><br><span class="line"> * @see #attachDisplayAreas()</span><br><span class="line"> */</span><br><span class="line">protected DisplayAreaPolicy(WindowManagerService wmService,</span><br><span class="line">        DisplayContent content, DisplayArea.Root root,</span><br><span class="line">        DisplayArea&lt;? extends WindowContainer&gt; imeContainer,</span><br><span class="line">        List&lt;TaskDisplayArea&gt; taskDisplayAreas) &#123;</span><br><span class="line">    mWmService = wmService;</span><br><span class="line">    mContent = content;</span><br><span class="line">    mRoot = root;</span><br><span class="line">    mImeContainer = imeContainer;</span><br><span class="line">    mTaskDisplayAreas = taskDisplayAreas;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>DisplayAreaPolicyBuilder:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Result build(WindowManagerService wmService,</span><br><span class="line">        DisplayContent content, DisplayArea.Root root,</span><br><span class="line">        DisplayArea&lt;? extends WindowContainer&gt; imeContainer,</span><br><span class="line">        List&lt;TaskDisplayArea&gt; taskDisplayAreas) &#123;</span><br><span class="line"></span><br><span class="line">    return new Result(wmService, content, root, imeContainer, taskDisplayAreas, new ArrayList&lt;&gt;(</span><br><span class="line">            mFeatures));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Result extends DisplayAreaPolicy &#123;</span><br><span class="line"></span><br><span class="line">    Result(WindowManagerService wmService, DisplayContent content, DisplayArea.Root root,</span><br><span class="line">            DisplayArea&lt;? extends WindowContainer&gt; imeContainer,</span><br><span class="line">            List&lt;TaskDisplayArea&gt; taskDisplayAreas, ArrayList&lt;Feature&gt; features) &#123;</span><br><span class="line">        //主要还是调用了父类DisplayAreaPolicy的构造方法                    </span><br><span class="line">        super(wmService, content, root, imeContainer, taskDisplayAreas);</span><br><span class="line">        //mFeatures一般是个空列表</span><br><span class="line">        mFeatures = features;</span><br><span class="line">        mAreas = new HashMap&lt;&gt;(features.size());</span><br><span class="line">        for (int i = 0; i &lt; mFeatures.size(); i++) &#123;</span><br><span class="line">            mAreas.put(mFeatures.get(i), new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>最后看DisplayContent中的<code>mWindowContainers.addChildren()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static class DisplayChildWindowContainer&lt;E extends WindowContainer&gt; extends WindowContainer&lt;E&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class WindowContainers extends DisplayChildWindowContainer&lt;WindowContainer&gt; &#123;</span><br><span class="line">    void addChildren() &#123;</span><br><span class="line">        //调用父类WindowContainer的addChild，将mRootDisplayArea放在mWindowContainers中</span><br><span class="line">        addChild(mRootDisplayArea, 0);</span><br><span class="line">        //初始化容器</span><br><span class="line">        mDisplayAreaPolicy.attachDisplayAreas();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>到目前为止，DisplayContent中几个容器的层级关系如下:<br><em>mOverlayContainers和mWindowContainers在同一个Display中，mOverlayContainers高于mWindowContainers，<br>DisplayArea.Root在mWindowContainers中</em></p>
<ul>
<li>#1 mOverlayContainers</li>
<li>#0 mWindowContainers<ul>
<li>#0 DisplayArea.Root</li>
</ul>
</li>
</ul>
<p>继续看DisplayAreaPolicyBuilder中的attachDisplayAreas</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final int mMaxWindowLayer = mWmService.mPolicy.getMaxWindowLayer();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void attachDisplayAreas() &#123;</span><br><span class="line">    // This method constructs the layer hierarchy with the following properties:</span><br><span class="line">    // (1) Every feature maps to a set of DisplayAreas</span><br><span class="line">    // (2) After adding a window, for every feature the window&#x27;s type belongs to,</span><br><span class="line">    //     it is a descendant of one of the corresponding DisplayAreas of the feature.</span><br><span class="line">    // (3) Z-order is maintained, i.e. if z-range(area) denotes the set of layers of windows</span><br><span class="line">    //     within a DisplayArea:</span><br><span class="line">    //      for every pair of DisplayArea siblings (a,b), where a is below b, it holds that</span><br><span class="line">    //      max(z-range(a)) &lt;= min(z-range(b))</span><br><span class="line">    //</span><br><span class="line">    // The algorithm below iteratively creates such a hierarchy:</span><br><span class="line">    //  - Initially, all windows are attached to the root.</span><br><span class="line">    //  - For each feature we create a set of DisplayAreas, by looping over the layers</span><br><span class="line">    //    - if the feature does apply to the current layer, we need to find a DisplayArea</span><br><span class="line">    //      for it to satisfy (2)</span><br><span class="line">    //      - we can re-use the previous layer&#x27;s area if:</span><br><span class="line">    //         the current feature also applies to the previous layer, (to satisfy (3))</span><br><span class="line">    //         and the last feature that applied to the previous layer is the same as</span><br><span class="line">    //           the last feature that applied to the current layer (to satisfy (2))</span><br><span class="line">    //      - otherwise we create a new DisplayArea below the last feature that applied</span><br><span class="line">    //        to the current layer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //这里创建了一个数组，容量是默认定义好的最大的layer，这里数组的下标对应windowtype所映射的layer</span><br><span class="line">    PendingArea[] areaForLayer = new PendingArea[mMaxWindowLayer];</span><br><span class="line">    final PendingArea root = new PendingArea(null, 0, null);</span><br><span class="line">    //将数组中的每个元素都赋值成 root 对象</span><br><span class="line">    Arrays.fill(areaForLayer, root);</span><br><span class="line"></span><br><span class="line">    final int size = mFeatures.size();</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        PendingArea featureArea = null;</span><br><span class="line">        for (int layer = 0; layer &lt; mMaxWindowLayer; layer++) &#123;</span><br><span class="line">            final Feature feature = mFeatures.get(i);</span><br><span class="line">            if (feature.mWindowLayers[layer]) &#123;</span><br><span class="line">                if (featureArea == null || featureArea.mParent != areaForLayer[layer]) &#123;</span><br><span class="line">                    // No suitable DisplayArea - create a new one under the previous area</span><br><span class="line">                    // for this layer.</span><br><span class="line">                    featureArea = new PendingArea(feature, layer, areaForLayer[layer]);</span><br><span class="line">                    areaForLayer[layer].mChildren.add(featureArea);</span><br><span class="line">                &#125;</span><br><span class="line">                areaForLayer[layer] = featureArea;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                featureArea = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里的逻辑主要是去将root容器分成多个子容器，每个容器在root中的layer不一样</span><br><span class="line">    PendingArea leafArea = null;</span><br><span class="line">    int leafType = LEAF_TYPE_TOKENS;</span><br><span class="line">    //开始遍历areaForLayer这个数组</span><br><span class="line">    for (int layer = 0; layer &lt; mMaxWindowLayer; layer++) &#123;</span><br><span class="line">        //先根据当前的layer判断所属的type</span><br><span class="line">        int type = typeOfLayer(mWmService.mPolicy, layer);</span><br><span class="line">        //判断是否需要创建一个子容器（主要根据type是否变化）</span><br><span class="line">        if (leafArea == null || leafArea.mParent != areaForLayer[layer]</span><br><span class="line">                || type != leafType) &#123;</span><br><span class="line">            //创建一个子容器，mMinLayer为当前的layer值，父容器为当前layer</span><br><span class="line">            leafArea = new PendingArea(null, layer, areaForLayer[layer]);</span><br><span class="line">            //这里取当前layer，由于每个layer都是赋值的root，实际就是root</span><br><span class="line">            //root对象添加一个子容器</span><br><span class="line">            areaForLayer[layer].mChildren.add(leafArea);</span><br><span class="line">            leafType = type;</span><br><span class="line">            if (leafType == LEAF_TYPE_TASK_CONTAINERS) &#123;</span><br><span class="line">                //这里会去将LEAF_TYPE_TASK_CONTAINERS类型，也就是启动的app的窗口，单独放到一个子容器中</span><br><span class="line">                addTaskDisplayAreasToLayer(areaForLayer[layer], layer);</span><br><span class="line">            &#125; else if (leafType == LEAF_TYPE_IME_CONTAINERS) &#123;</span><br><span class="line">                leafArea.mExisting = mImeContainer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //更新子容器的mMaxLayer</span><br><span class="line">        leafArea.mMaxLayer = layer;</span><br><span class="line">    &#125;</span><br><span class="line">    root.computeMaxLayer();</span><br><span class="line">    //对子容器进行初始化排序</span><br><span class="line">    root.instantiateChildren(mRoot, mAreaForLayer, 0, mAreas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int typeOfLayer(WindowManagerPolicy policy, int layer) &#123;</span><br><span class="line">    if (layer == APPLICATION_LAYER) &#123;</span><br><span class="line">        return LEAF_TYPE_TASK_CONTAINERS;</span><br><span class="line">    &#125; else if (layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD)</span><br><span class="line">            || layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD_DIALOG)) &#123;</span><br><span class="line">        return LEAF_TYPE_IME_CONTAINERS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return LEAF_TYPE_TOKENS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** Adds all task display areas to the specified layer */</span><br><span class="line">private void addTaskDisplayAreasToLayer(PendingArea parentPendingArea, int layer) &#123;</span><br><span class="line">    final int count = mTaskDisplayAreas.size();</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        PendingArea leafArea = new PendingArea(null, layer, parentPendingArea);</span><br><span class="line">        leafArea.mExisting = mTaskDisplayAreas.get(i);</span><br><span class="line">        leafArea.mMaxLayer = layer;</span><br><span class="line">        parentPendingArea.mChildren.add(leafArea);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void instantiateChildren(DisplayArea&lt;DisplayArea&gt; parent,</span><br><span class="line">        DisplayArea.Tokens[] areaForLayer, int level, Map&lt;Feature, List&lt;DisplayArea&lt;?</span><br><span class="line">        extends WindowContainer&gt;&gt;&gt; areas) &#123;</span><br><span class="line">    //根据每个子容器的mMinLayer进行排序</span><br><span class="line">    mChildren.sort(Comparator.comparingInt(pendingArea -&gt; pendingArea.mMinLayer));</span><br><span class="line">    for (int i = 0; i &lt; mChildren.size(); i++) &#123;</span><br><span class="line">        final PendingArea child = mChildren.get(i);</span><br><span class="line">        //创建对应的子容器</span><br><span class="line">        final DisplayArea area = child.createArea(parent, areaForLayer);</span><br><span class="line">        //添加到mRootDisplayArea中，同理会触发mParent.assignChildLayers()改变zOrder</span><br><span class="line">        parent.addChild(area, WindowContainer.POSITION_TOP);</span><br><span class="line">        if (mFeature != null) &#123;</span><br><span class="line">            areas.get(mFeature).add(area);</span><br><span class="line">        &#125;</span><br><span class="line">        child.instantiateChildren(area, areaForLayer, level + 1, areas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line">private DisplayArea createArea(DisplayArea&lt;DisplayArea&gt; parent,</span><br><span class="line">        DisplayArea.Tokens[] areaForLayer) &#123;</span><br><span class="line">    if (mExisting != null) &#123;</span><br><span class="line">        return mExisting;</span><br><span class="line">    &#125;</span><br><span class="line">    DisplayArea.Type type;</span><br><span class="line">    if (mMinLayer &gt; APPLICATION_LAYER) &#123;</span><br><span class="line">        type = DisplayArea.Type.ABOVE_TASKS;</span><br><span class="line">    &#125; else if (mMaxLayer &lt; APPLICATION_LAYER) &#123;</span><br><span class="line">        type = DisplayArea.Type.BELOW_TASKS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        type = DisplayArea.Type.ANY;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mFeature == null) &#123;</span><br><span class="line">        final DisplayArea.Tokens leaf = new DisplayArea.Tokens(parent.mWmService, type,</span><br><span class="line">                &quot;Leaf:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer);</span><br><span class="line">        for (int i = mMinLayer; i &lt;= mMaxLayer; i++) &#123;</span><br><span class="line">            areaForLayer[i] = leaf;</span><br><span class="line">        &#125;</span><br><span class="line">        return leaf;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return new DisplayArea(parent.mWmService, type, mFeature.mName + &quot;:&quot;</span><br><span class="line">                + mMinLayer + &quot;:&quot; + mMaxLayer, mFeature.mId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                        </span><br></pre></td></tr></table></figure>

<p>到此可以知道各个容器间的层级关系，低层级容器中的窗口无法显示在高层级容器的窗口之上：</p>
<ul>
<li>#1 mOverlayContainers</li>
<li>#0 mWindowContainers<ul>
<li>#0 DisplayArea.Root<ul>
<li>#5 Leaf:17:34</li>
<li>#4 ImeContainer</li>
<li>#3 Leaf:3:14</li>
<li>#2 DefaultTaskDisplayArea 这是普通app Activity所在的层级</li>
<li>#1 Leaf:2:2</li>
<li>#0 Leaf:0:1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="输入法的层级"><a href="#输入法的层级" class="headerlink" title="输入法的层级"></a>输入法的层级</h2><p> 输入法的层级不是固定不变的，而是动态变化的<br> 在每次切换app的时候，会重新设置FocusedApp，然后调用WMS中的updateFocusedWindowLocked，<br> 去动态计算mInputMethodTarget,并根据mInputMethodTarget来重新设置mImeWindowsContainers的父容器和relativeLayer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">boolean updateFocusedWindowLocked(int mode, boolean updateInputWindows,</span><br><span class="line">        int topFocusedDisplayId) &#123;</span><br><span class="line">    WindowState newFocus = findFocusedWindowIfNeeded(topFocusedDisplayId);</span><br><span class="line">    if (mCurrentFocus == newFocus) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean imWindowChanged = false;</span><br><span class="line">    final WindowState imWindow = mInputMethodWindow;</span><br><span class="line">    if (imWindow != null) &#123;</span><br><span class="line">        final WindowState prevTarget = mInputMethodTarget;</span><br><span class="line">        //计算imeTagrget</span><br><span class="line">        final WindowState newTarget = computeImeTarget(true /* updateImeTarget*/);</span><br><span class="line">        imWindowChanged = prevTarget != newTarget;</span><br><span class="line"></span><br><span class="line">        if (mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS</span><br><span class="line">                &amp;&amp; mode != UPDATE_FOCUS_WILL_PLACE_SURFACES) &#123;</span><br><span class="line">            assignWindowLayers(false /* setLayoutNeeded */);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //......            </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final Predicate&lt;WindowState&gt; mComputeImeTargetPredicate = w -&gt; &#123;</span><br><span class="line">    if (DEBUG_INPUT_METHOD &amp;&amp; mUpdateImeTarget) Slog.i(TAG_WM, &quot;Checking window @&quot; + w</span><br><span class="line">            + &quot; fl=0x&quot; + Integer.toHexString(w.mAttrs.flags));</span><br><span class="line">    //判断是否可以作为imeTarget</span><br><span class="line">    return w.canBeImeTarget();</span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line">WindowState getWindow(Predicate&lt;WindowState&gt; callback) &#123;</span><br><span class="line">    for (int i = mChildren.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        final WindowState w = mChildren.get(i).getWindow(callback);</span><br><span class="line">        if (w != null) &#123;</span><br><span class="line">            return w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Determine and return the window that should be the IME target.</span><br><span class="line"> * @param updateImeTarget If true the system IME target will be updated to match what we found.</span><br><span class="line"> * @return The window that should be used as the IME target or null if there isn&#x27;t any.</span><br><span class="line"> */</span><br><span class="line">WindowState computeImeTarget(boolean updateImeTarget) &#123;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    final WindowState curTarget = mInputMethodTarget;</span><br><span class="line">    if (!canUpdateImeTarget()) &#123;</span><br><span class="line">        if (DEBUG_INPUT_METHOD) Slog.w(TAG_WM, &quot;Defer updating IME target&quot;);</span><br><span class="line">        return curTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // TODO(multidisplay): Needs some serious rethought when the target and IME are not on the</span><br><span class="line">    // same display. Or even when the current IME/target are not on the same screen as the next</span><br><span class="line">    // IME/target. For now only look for input windows on the main screen.</span><br><span class="line">    mUpdateImeTarget = updateImeTarget;</span><br><span class="line">    //关键在这里，计算target，从上到下进行遍历，找到第一个可以作为imeTarget的window</span><br><span class="line">    WindowState target = getWindow(mComputeImeTargetPredicate);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Yet more tricksyness!  If this window is a &quot;starting&quot; window, we do actually want</span><br><span class="line">    // to be on top of it, but it is not -really- where input will go. So look down below</span><br><span class="line">    // for a real window to target...</span><br><span class="line">    if (target != null &amp;&amp; target.mAttrs.type == TYPE_APPLICATION_STARTING) &#123;</span><br><span class="line">        final ActivityRecord activity = target.mActivityRecord;</span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">            final WindowState betterTarget = activity.getImeTargetBelowWindow(target);</span><br><span class="line">            if (betterTarget != null) &#123;</span><br><span class="line">                target = betterTarget;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_INPUT_METHOD &amp;&amp; updateImeTarget) Slog.v(TAG_WM,</span><br><span class="line">            &quot;Proposed new IME target: &quot; + target + &quot; for display: &quot; + getDisplayId());</span><br><span class="line"></span><br><span class="line">    // Now, a special case -- if the last target&#x27;s window is in the process of exiting, but</span><br><span class="line">    // not removed, keep on the last target to avoid IME flicker. The exception is if the</span><br><span class="line">    // current target is home since we want opening apps to become the IME target right away.</span><br><span class="line">    if (curTarget != null &amp;&amp; !curTarget.mRemoved &amp;&amp; curTarget.isDisplayedLw()</span><br><span class="line">            &amp;&amp; curTarget.isClosing() &amp;&amp; !curTarget.isActivityTypeHome()) &#123;</span><br><span class="line">        if (DEBUG_INPUT_METHOD) Slog.v(TAG_WM, &quot;Not changing target till current window is&quot;</span><br><span class="line">                + &quot; closing and not removed&quot;);</span><br><span class="line">        return curTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_INPUT_METHOD) Slog.v(TAG_WM, &quot;Desired input method target=&quot; + target</span><br><span class="line">            + &quot; updateImeTarget=&quot; + updateImeTarget);</span><br><span class="line"></span><br><span class="line">    if (target == null) &#123;</span><br><span class="line">        if (updateImeTarget) &#123;</span><br><span class="line">            if (DEBUG_INPUT_METHOD) Slog.w(TAG_WM, &quot;Moving IM target from &quot; + curTarget</span><br><span class="line">                    + &quot; to null.&quot; + (SHOW_STACK_CRAWLS ? &quot; Callers=&quot;</span><br><span class="line">                    + Debug.getCallers(4) : &quot;&quot;));</span><br><span class="line">            setInputMethodTarget(null, mInputMethodTargetWaitingAnim);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (updateImeTarget) &#123;</span><br><span class="line">        ActivityRecord activity = curTarget == null ? null : curTarget.mActivityRecord;</span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line"></span><br><span class="line">            // Now some fun for dealing with window animations that modify the Z order. We need</span><br><span class="line">            // to look at all windows below the current target that are in this app, finding the</span><br><span class="line">            // highest visible one in layering.</span><br><span class="line">            WindowState highestTarget = null;</span><br><span class="line">            if (activity.isAnimating(PARENTS | TRANSITION)) &#123;</span><br><span class="line">                highestTarget = activity.getHighestAnimLayerWindow(curTarget);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (highestTarget != null) &#123;</span><br><span class="line">                if (DEBUG_INPUT_METHOD) &#123;</span><br><span class="line">                    Slog.v(TAG_WM, mAppTransition + &quot; &quot; + highestTarget + &quot; animating=&quot;</span><br><span class="line">                            + highestTarget.isAnimating(TRANSITION | PARENTS));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mAppTransition.isTransitionSet()) &#123;</span><br><span class="line">                    // If we are currently setting up for an animation, hold everything until we</span><br><span class="line">                    // can find out what will happen.</span><br><span class="line">                    setInputMethodTarget(highestTarget, true);</span><br><span class="line">                    return highestTarget;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_INPUT_METHOD) Slog.w(TAG_WM, &quot;Moving IM target from &quot; + curTarget + &quot; to &quot;</span><br><span class="line">                + target + (SHOW_STACK_CRAWLS ? &quot; Callers=&quot; + Debug.getCallers(4) : &quot;&quot;));</span><br><span class="line">        //这里对mInputMethodTarget进行赋值</span><br><span class="line">        setInputMethodTarget(target, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return target;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>接着主要就是去看WindowState中的canBeImeTarget:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">boolean canBeImeTarget() &#123;</span><br><span class="line">    // If any of the embedded windows can be the IME target, this window will be the final IME</span><br><span class="line">    // target. This is because embedded windows are on a different display in WM so it would</span><br><span class="line">    // cause confusion trying to set the IME to a window on a different display. Instead, just</span><br><span class="line">    // make the host window the IME target.</span><br><span class="line">    if (canWindowInEmbeddedDisplayBeImeTarget()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mIsImWindow) &#123;</span><br><span class="line">        // IME windows can&#x27;t be IME targets. IME targets are required to be below the IME</span><br><span class="line">        // windows and that wouldn&#x27;t be possible if the IME window is its own target...silly.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (inPinnedWindowingMode()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mAttrs.type == TYPE_SCREENSHOT) &#123;</span><br><span class="line">        // Disallow screenshot windows from being IME targets</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final boolean windowsAreFocusable = mActivityRecord == null || mActivityRecord.windowsAreFocusable();</span><br><span class="line">    if (!windowsAreFocusable) &#123;</span><br><span class="line">        // This window can&#x27;t be an IME target if the app&#x27;s windows should not be focusable.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ActivityStack stack = getRootTask();</span><br><span class="line">    if (stack != null &amp;&amp; !stack.isFocusable()) &#123;</span><br><span class="line">        // Ignore when the stack shouldn&#x27;t receive input event.</span><br><span class="line">        // (i.e. the minimized stack in split screen mode.)</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mAttrs.type == TYPE_APPLICATION_STARTING) &#123;</span><br><span class="line">        // Ignore mayUseInputMethod for starting window for now.</span><br><span class="line">        // TODO(b/159911356): Remove this special casing (originally added in commit e75d872).</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // TODO(b/145812508): Clean this up in S, may depend on b/141738570</span><br><span class="line">        //  The current logic lets windows become the &quot;ime target&quot; even though they are</span><br><span class="line">        //  not-focusable and can thus never actually start input.</span><br><span class="line">        //  Ideally, this would reject windows where mayUseInputMethod() == false, but this</span><br><span class="line">        //  also impacts Z-ordering of and delivery of IME insets to child windows, which means</span><br><span class="line">        //  that simply disallowing non-focusable windows would break apps.</span><br><span class="line">        //  See b/159438771, b/144619551.</span><br><span class="line"></span><br><span class="line">        final int fl = mAttrs.flags &amp; (FLAG_NOT_FOCUSABLE | FLAG_ALT_FOCUSABLE_IM);</span><br><span class="line"></span><br><span class="line">        // Can only be an IME target if both FLAG_NOT_FOCUSABLE and FLAG_ALT_FOCUSABLE_IM are</span><br><span class="line">        // set or both are cleared...and not a starting window.</span><br><span class="line">        if (fl != 0 &amp;&amp; fl != (FLAG_NOT_FOCUSABLE | FLAG_ALT_FOCUSABLE_IM)) &#123;</span><br><span class="line">            //只要设置了FLAG_NOT_FOCUSABLE和FLAG_ALT_FOCUSABLE_IM其中一个就直接返回false</span><br><span class="line">            //所以要让window能成为imeTarget的前提就是要么2个flag都不设置，要么2个都设置</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_INPUT_METHOD) &#123;</span><br><span class="line">        Slog.i(TAG_WM, &quot;isVisibleOrAdding &quot; + this + &quot;: &quot; + isVisibleOrAdding());</span><br><span class="line">        if (!isVisibleOrAdding()) &#123;</span><br><span class="line">            Slog.i(TAG_WM, &quot;  mSurfaceController=&quot; + mWinAnimator.mSurfaceController</span><br><span class="line">                    + &quot; relayoutCalled=&quot; + mRelayoutCalled</span><br><span class="line">                    + &quot; viewVis=&quot; + mViewVisibility</span><br><span class="line">                    + &quot; policyVis=&quot; + isVisibleByPolicy()</span><br><span class="line">                    + &quot; policyVisAfterAnim=&quot; + mLegacyPolicyVisibilityAfterAnim</span><br><span class="line">                    + &quot; parentHidden=&quot; + isParentWindowHidden()</span><br><span class="line">                    + &quot; exiting=&quot; + mAnimatingExit + &quot; destroying=&quot; + mDestroying);</span><br><span class="line">            if (mActivityRecord != null) &#123;</span><br><span class="line">                Slog.i(TAG_WM, &quot;  mActivityRecord.visibleRequested=&quot;</span><br><span class="line">                        + mActivityRecord.mVisibleRequested);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //最后去判断window是否可见</span><br><span class="line">    return isVisibleOrAdding();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Same as isVisible(), but we also count it as visible between the</span><br><span class="line"> * call to IWindowSession.add() and the first relayout().</span><br><span class="line"> */</span><br><span class="line">boolean isVisibleOrAdding() &#123;</span><br><span class="line">    final ActivityRecord atoken = mActivityRecord;</span><br><span class="line">    return (mHasSurface || (!mRelayoutCalled &amp;&amp; mViewVisibility == View.VISIBLE))</span><br><span class="line">            &amp;&amp; isVisibleByPolicy() &amp;&amp; !isParentWindowHidden()</span><br><span class="line">            &amp;&amp; (atoken == null || atoken.mVisibleRequested)</span><br><span class="line">            &amp;&amp; !mAnimatingExit &amp;&amp; !mDestroying;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Fireflies</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/pages/c0d3d8/">http://example.com/pages/c0d3d8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Fireflies's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android-Framework/">Android Framework</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/pages/c75abc/" title="C++相关"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++相关</div></div></a></div><div class="next-post pull-right"><a href="/pages/7a896d/" title="ssh免ip免密码登陆"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ssh免ip免密码登陆</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/pages/385f7b/" title="OemLockService"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-23</div><div class="title">OemLockService</div></div></a></div><div><a href="/pages/4f2f9f/" title="AccessibilityService"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-23</div><div class="title">AccessibilityService</div></div></a></div><div><a href="/pages/fce6de/" title="AppWidgetService"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-06</div><div class="title">AppWidgetService</div></div></a></div><div><a href="/pages/753ec4/" title="DreamManagerService"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-30</div><div class="title">DreamManagerService</div></div></a></div><div><a href="/pages/e58274/" title="UserController"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-06</div><div class="title">UserController</div></div></a></div><div><a href="/pages/62cb3b/" title="Widget之AppWidgetHost"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-12</div><div class="title">Widget之AppWidgetHost</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fireflies</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FirefliesL"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E7%9C%8B%E7%9C%8BWMS%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">先看看WMS的启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WMS%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">WMS的整体架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WMS%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98"><span class="toc-number">3.</span> <span class="toc-text">WMS中的一些重要成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WindowManagerPolicy-mPolicy"><span class="toc-number">3.1.</span> <span class="toc-text">WindowManagerPolicy[mPolicy]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AppOpsManager-mAppOps"><span class="toc-number">3.2.</span> <span class="toc-text">AppOpsManager[mAppOps]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DisplayWindowSettings-mDisplayWindowSettings"><span class="toc-number">3.3.</span> <span class="toc-text">DisplayWindowSettings[mDisplayWindowSettings]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArraySet-mSessions"><span class="toc-number">3.4.</span> <span class="toc-text">ArraySet[mSessions]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-mWindowMap"><span class="toc-number">3.5.</span> <span class="toc-text">HashMap[mWindowMap]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-mInputToWindowMap"><span class="toc-number">3.6.</span> <span class="toc-text">HashMap[mInputToWindowMap]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WindowManagerGlobalLock-mGlobalLock"><span class="toc-number">3.7.</span> <span class="toc-text">WindowManagerGlobalLock[mGlobalLock]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PhoneWindow"><span class="toc-number">4.</span> <span class="toc-text">PhoneWindow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WindowManagerService"><span class="toc-number">5.</span> <span class="toc-text">WindowManagerService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WindowManager-LaLayoutParams"><span class="toc-number">6.</span> <span class="toc-text">WindowManager.LaLayoutParams</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9BFLAG%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="toc-number">7.</span> <span class="toc-text">一些FLAG的记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#View-SYSTEM-UI-FLAG-LAYOUT-STABLE"><span class="toc-number">7.1.</span> <span class="toc-text">View.SYSTEM_UI_FLAG_LAYOUT_STABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-SYSTEM-UI-FLAG-LAYOUT-HIDE-NAVIGATION"><span class="toc-number">7.2.</span> <span class="toc-text">View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-SYSTEM-UI-FLAG-LAYOUT-FULLSCREEN"><span class="toc-number">7.3.</span> <span class="toc-text">View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-SYSTEM-UI-FLAG-HIDE-NAVIGATION"><span class="toc-number">7.4.</span> <span class="toc-text">View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-SYSTEM-UI-FLAG-FULLSCREEN"><span class="toc-number">7.5.</span> <span class="toc-text">View.SYSTEM_UI_FLAG_FULLSCREEN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-SYSTEM-UI-FLAG-IMMERSIVE-STICKY"><span class="toc-number">7.6.</span> <span class="toc-text">View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D%E5%B8%83%E5%B1%80%EF%BC%8C%E4%B8%8D%E5%BD%B1%E5%93%8D%E7%B3%BB%E7%BB%9F%E7%AA%97%E5%8F%A3"><span class="toc-number">8.</span> <span class="toc-text">影响布局，不影响系统窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D%E5%B8%83%E5%B1%80%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%AA%97%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">影响布局和系统窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WindowManager-addView"><span class="toc-number">10.</span> <span class="toc-text">WindowManager#addView</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WindowManagerService-addWindow"><span class="toc-number">11.</span> <span class="toc-text">WindowManagerService#addWindow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WindowState"><span class="toc-number">12.</span> <span class="toc-text">WindowState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DisplayFrames"><span class="toc-number">13.</span> <span class="toc-text">DisplayFrames</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WindowFrames"><span class="toc-number">14.</span> <span class="toc-text">WindowFrames</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Displaypolicy-layoutWindowLw"><span class="toc-number">15.</span> <span class="toc-text">Displaypolicy#layoutWindowLw</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E6%98%BE%E7%A4%BA%E4%B8%8B%E6%8B%89%E7%8A%B6%E6%80%81%E6%A0%8F"><span class="toc-number">16.</span> <span class="toc-text">强制显示下拉状态栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7"><span class="toc-number">17.</span> <span class="toc-text">窗口层级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E5%B1%82%E7%BA%A7"><span class="toc-number">18.</span> <span class="toc-text">输入法的层级</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/25/android_fw/26.AdbService/" title="AdbService">AdbService</a><time datetime="2024-12-25T14:50:32.000Z" title="发表于 2024-12-25 14:50:32">2024-12-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/11/android_fw/56.ActivityView/" title="ActivityView">ActivityView</a><time datetime="2024-12-11T10:51:06.000Z" title="发表于 2024-12-11 10:51:06">2024-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/06/android_fw/55.%E9%BB%98%E8%AE%A4%E8%BE%93%E5%85%A5%E6%B3%95/" title="默认输入法">默认输入法</a><time datetime="2024-12-06T15:40:04.000Z" title="发表于 2024-12-06 15:40:04">2024-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/03/%E5%85%B6%E5%AE%83/22.gradle%E7%AC%94%E8%AE%B0/" title="gradle笔记">gradle笔记</a><time datetime="2024-12-03T17:48:28.000Z" title="发表于 2024-12-03 17:48:28">2024-12-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/02/%E5%85%B6%E5%AE%83/21.javadoc%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3/" title="javadoc生成文档">javadoc生成文档</a><time datetime="2024-12-02T16:41:51.000Z" title="发表于 2024-12-02 16:41:51">2024-12-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By Fireflies</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>