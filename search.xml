<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android启动流程</title>
    <url>/2024/07/18/android_fw/01.Android%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="android启动过程的日志和event"><a href="#android启动过程的日志和event" class="headerlink" title="android启动过程的日志和event"></a>android启动过程的日志和event</h2><p>event关键字 <code>boot_</code>, <code>wm_</code>,<code>uc_</code>,<code>BootAnimation</code>,<code>FinishBooting</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boot_progress_start</span><br><span class="line">boot_progress_preload_start</span><br><span class="line">boot_progress_preload_end</span><br><span class="line">boot_progress_system_run</span><br><span class="line">boot_progress_pms_start</span><br><span class="line">boot_progress_pms_system_scan_start</span><br><span class="line">boot_progress_pms_data_scan_start</span><br><span class="line">boot_progress_pms_scan_end</span><br><span class="line">boot_progress_pms_ready</span><br><span class="line">boot_progress_ams_ready</span><br><span class="line"></span><br><span class="line">uc_send_user_broadcast: [0,android.intent.action.USER_FOREGROUND]</span><br><span class="line">uc_send_user_broadcast: [0,android.intent.action.USER_SWITCHED]</span><br><span class="line"></span><br><span class="line">ActivityManagerServiceTiming: FinishBooting</span><br><span class="line">boot_progress_enable_screen</span><br><span class="line">wm_boot_animation_done</span><br><span class="line">ActivityManagerServiceTiming: FinishBooting</span><br><span class="line"></span><br><span class="line">uc_finish_user_boot</span><br><span class="line">uc_send_user_broadcast: [0,android.intent.action.LOCKED_BOOT_COMPLETED]</span><br><span class="line">uc_finish_user_unlocking</span><br><span class="line">uc_send_user_broadcast: [0,android.intent.action.USER_UNLOCKED]</span><br><span class="line">uc_finish_user_unlocked_completed</span><br><span class="line">UserController: Posting BOOT_COMPLETED user #0</span><br><span class="line">uc_send_user_broadcast: [0,android.intent.action.BOOT_COMPLETED]</span><br><span class="line">UserController: Finished processing BOOT_COMPLETED for u0</span><br></pre></td></tr></table></figure>

<h2 id="launcher的启动"><a href="#launcher的启动" class="headerlink" title="launcher的启动"></a>launcher的启动</h2><p>在system server中最后启动完OtherServices时，会去调用AMS的systemReady，<br>在systemeady中有一个goingCallback的Runnable，<br>Runnable内部会去调用SystemServiceManager的startBootPhase去通知各个SystemService去处理各个阶段的逻辑</p>
<p>在AAOS中有一个CarServiceHelperService的SystemService，<br>在onBootPhase中会去setupAndStartUsers –&gt; setupAndStartUsersDirectly</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void setupAndStartUsersDirectly(@NonNull TimingsTraceAndSlog t,</span><br><span class="line">        @Nullable String userLocales) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (mInitialized) &#123;</span><br><span class="line">            Slog.wtf(TAG, &quot;Already initialized&quot;, new Exception());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mInitialized = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInitialUserSetter.set(newInitialUserInfoBuilder(InitialUserSetter.TYPE_DEFAULT_BEHAVIOR)</span><br><span class="line">            .setUserLocales(userLocales)</span><br><span class="line">            .build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InitialUserSetter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Sets the initial user.</span><br><span class="line"> */</span><br><span class="line">public void set(@NonNull InitialUserInfo info) &#123;</span><br><span class="line">    Preconditions.checkArgument(info != null, &quot;info cannot be null&quot;);</span><br><span class="line"></span><br><span class="line">    switch (info.type) &#123;</span><br><span class="line">        case TYPE_DEFAULT_BEHAVIOR:</span><br><span class="line">            executeDefaultBehavior(info, /* fallback= */ false);</span><br><span class="line">            break;</span><br><span class="line">        case TYPE_SWITCH:</span><br><span class="line">            try &#123;</span><br><span class="line">                switchUser(info, /* fallback= */ true);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                fallbackDefaultBehavior(info, /* fallback= */ true,</span><br><span class="line">                        &quot;Exception switching user: &quot; + e);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case TYPE_CREATE:</span><br><span class="line">            try &#123;</span><br><span class="line">                createAndSwitchUser(info, /* fallback= */ true);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                fallbackDefaultBehavior(info, /* fallback= */ true,</span><br><span class="line">                        &quot;Exception createUser user with name &quot;</span><br><span class="line">                                + UserHelper.safeName(info.newUserName) + &quot; and flags &quot;</span><br><span class="line">                                + UserHalHelper.userFlagsToString(info.newUserFlags) + &quot;: &quot;</span><br><span class="line">                                + e);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case TYPE_REPLACE_GUEST:</span><br><span class="line">            try &#123;</span><br><span class="line">                replaceUser(info, /* fallback= */ true);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                fallbackDefaultBehavior(info, /* fallback= */ true,</span><br><span class="line">                        &quot;Exception replace guest user: &quot; + e);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalArgumentException(&quot;invalid InitialUserInfo type: &quot; + info.type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void executeDefaultBehavior(@NonNull InitialUserInfo info, boolean fallback) &#123;</span><br><span class="line">    //这里内部是去调用了UserManager的接口获取判断是否有可以切换到前台的user</span><br><span class="line">    if (!mHelper.hasInitialUser()) &#123;</span><br><span class="line">        if (DBG) Log.d(TAG, &quot;executeDefaultBehavior(): no initial user, creating it&quot;);</span><br><span class="line">        createAndSwitchUser(new Builder(TYPE_CREATE)</span><br><span class="line">                .setNewUserName(mNewUserName)</span><br><span class="line">                .setNewUserFlags(UserFlags.ADMIN)</span><br><span class="line">                .setSupportsOverrideUserIdProperty(info.supportsOverrideUserIdProperty)</span><br><span class="line">                .setUserLocales(info.userLocales)</span><br><span class="line">                .build(), fallback);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (DBG) Log.d(TAG, &quot;executeDefaultBehavior(): switching to initial user&quot;);</span><br><span class="line">        int userId = mHelper.getInitialUser(info.supportsOverrideUserIdProperty);</span><br><span class="line">        switchUser(new Builder(TYPE_SWITCH)</span><br><span class="line">                .setSwitchUserId(userId)</span><br><span class="line">                .setSupportsOverrideUserIdProperty(info.supportsOverrideUserIdProperty)</span><br><span class="line">                .setReplaceGuest(info.replaceGuest)</span><br><span class="line">                .build(), fallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">private void switchUser(@NonNull InitialUserInfo info, boolean fallback) &#123;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    unlockSystemUserIfNecessary(actualUserId);</span><br><span class="line"></span><br><span class="line">    //这里会获取当前的user</span><br><span class="line">    int currentUserId = ActivityManager.getCurrentUser();</span><br><span class="line">    if (actualUserId != currentUserId) &#123;</span><br><span class="line">        //如果和实际要切换到前台的不一致，就会去启动</span><br><span class="line">        if (!startForegroundUser(actualUserId)) &#123;</span><br><span class="line">            fallbackDefaultBehavior(info, fallback,</span><br><span class="line">                    &quot;am.switchUser(&quot; + actualUserId + &quot;) failed&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mHelper.setLastActiveUser(actualUserId);</span><br><span class="line">    &#125;</span><br><span class="line">    notifyListener(actualUser);</span><br><span class="line"></span><br><span class="line">    if (actualUserId != userId) &#123;</span><br><span class="line">        Slog.i(TAG, &quot;Removing old guest &quot; + userId);</span><br><span class="line">        if (!mUm.removeUser(userId)) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Could not remove old guest &quot; + userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">@VisibleForTesting</span><br><span class="line">boolean startForegroundUser(@UserIdInt int userId) &#123;</span><br><span class="line">    if (UserHelper.isHeadlessSystemUser(userId)) &#123;</span><br><span class="line">        // System User doesn&#x27;t associate with real person, can not be switched to.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        return ActivityManager.getService().startUserInForegroundWithListener(userId, null);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        Log.w(TAG, &quot;failed to start user &quot; + userId, e);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>后续的接口逻辑：<br>AMS<br>    startUserInForegroundWithListener<br>UserControllerstartUser<br>    startUserInternal &#x3D;&gt; startUserInternal &#x3D;&gt; moveUserToForeground<br>ActivityTaskManagerInternal<br>    startHomeActivity<br>RootWindowContainer<br>    startHomeOnDisplay</p>
<p>这时是启动的FallbackHome,在FallbackHome中去监听了ACTION_USER_UNLOCKED广播，收到广播后会去找HomeInfo</p>
]]></content>
  </entry>
  <entry>
    <title>Binder笔记</title>
    <url>/2024/07/26/android_fw/02.Binder%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Binder服务端的创建启动流程"><a href="#Binder服务端的创建启动流程" class="headerlink" title="Binder服务端的创建启动流程"></a>Binder服务端的创建启动流程</h2>]]></content>
  </entry>
  <entry>
    <title>模块编译</title>
    <url>//pages/e38b28/</url>
    <content><![CDATA[<h2 id="编译sepolicy"><a href="#编译sepolicy" class="headerlink" title="编译sepolicy"></a>编译sepolicy</h2><p>指令：<code>make selinux_policy</code></p>
<p>生成路径:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">out\target\product\msmnile_gvmq\system\etc\selinux</span><br><span class="line">out\target\product\msmnile_gvmq\system\system_ext\etc\selinux</span><br><span class="line">out\target\product\msmnile_gvmq\system\product\etc\selinux</span><br><span class="line">out\target\product\msmnile_gvmq\vendor\etc\selinux</span><br></pre></td></tr></table></figure>

<p>备份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bak_dir=bak</span><br><span class="line">system_ext_dir=$bak_dir/out/target/product/msmnile_gvmq/system_ext/etc</span><br><span class="line">system_dir=$bak_dir/out/target/product/msmnile_gvmq/system/etc</span><br><span class="line">system_product_dir=$bak_dir/out/target/product/msmnile_gvmq/system/product/etc</span><br><span class="line">vendor_dir=$bak_dir/out/target/product/msmnile_gvmq/vendor/etc</span><br><span class="line"></span><br><span class="line">adb wait-for-device</span><br><span class="line">adb shell &quot;su root setenforce 0&quot;</span><br><span class="line">adb shell setenforce 0</span><br><span class="line">adb root</span><br><span class="line">adb remount</span><br><span class="line"></span><br><span class="line">rm -rf $bak_dir</span><br><span class="line"></span><br><span class="line">mkdir -p $system_ext_dir</span><br><span class="line">mkdir -p $system_dir</span><br><span class="line">mkdir -p $system_product_dir</span><br><span class="line">mkdir -p $vendor_dir</span><br><span class="line"></span><br><span class="line">adb pull /system_ext/etc/selinux $system_ext_dir</span><br><span class="line">adb pull /system/etc/selinux $system_dir</span><br><span class="line">adb pull /system/product/etc/selinux $system_product_dir</span><br><span class="line">adb pull /vendor/etc/selinux $vendor_dir</span><br></pre></td></tr></table></figure>


<p>替换:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir=/home/lifeifei/workspace/changan_75a322/lagvm/lagvm/LINUX/android</span><br><span class="line">adb wait-for-device</span><br><span class="line">adb shell &quot;su root setenforce 0&quot;</span><br><span class="line">adb shell setenforce 0</span><br><span class="line">adb root</span><br><span class="line">adb remount</span><br><span class="line"></span><br><span class="line">adb push $dir/out/target/product/msmnile_gvmq/system/system_ext/etc/selinux /system_ext/etc/</span><br><span class="line">adb push $dir/out/target/product/msmnile_gvmq/system/etc/selinux /system/etc/</span><br><span class="line">adb push $dir/out/target/product/msmnile_gvmq/system/product/etc/selinux /system/product/etc/</span><br><span class="line">adb push $dir/out/target/product/msmnile_gvmq/vendor/etc/selinux /vendor/etc/</span><br><span class="line"></span><br><span class="line">adb shell sync</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="编译framework"><a href="#编译framework" class="headerlink" title="编译framework"></a>编译framework</h2><p>指令: <code>make framework-minus-apex</code></p>
<p>参考：</p>
<p><a href="https://blog.csdn.net/superlee1125/article/details/115491698">Android11快速编译并替换framework.jar</a></p>
<p><a href="https://blog.csdn.net/qq_27494201/article/details/125222294">Android 解决push framework.jar 无法开机</a></p>
<h2 id="编译services"><a href="#编译services" class="headerlink" title="编译services"></a>编译services</h2><p>指令: <code>make services</code></p>
<p>替换:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET DIR=W:\home\feifei\workspace\changan_75a121\lagvm\lagvm\LINUX\android\out\target\product\msmnile_gvmq\system\framework</span><br><span class="line">adb root</span><br><span class="line">adb remount</span><br><span class="line">adb push %DIR%\services.jar /system/framework/</span><br><span class="line">adb push %DIR%\services.jar.bprof /system/framework/</span><br><span class="line">adb push %DIR%\services.jar.prof /system/framework/</span><br><span class="line"></span><br><span class="line">adb push %DIR%\oat\arm64\services.art /system/framework/oat/arm64/</span><br><span class="line">adb push %DIR%\oat\arm64\services.odex /system/framework/oat/arm64/</span><br><span class="line">adb push %DIR%\oat\arm64\services.vdex /system/framework/oat/arm64/</span><br><span class="line"></span><br><span class="line">adb shell sync</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<h2 id="编译system-img"><a href="#编译system-img" class="headerlink" title="编译system.img"></a>编译system.img</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make systemimage</span><br></pre></td></tr></table></figure>

<p>对应的img可以在<code>build/make/core/Makefile</code>中查看</p>
]]></content>
  </entry>
  <entry>
    <title>APP系统签名</title>
    <url>//pages/293eea/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.cnblogs.com/guanxinjing/p/11410915.html">https://www.cnblogs.com/guanxinjing/p/11410915.html</a></p>
<p><a href="https://www.jb51.net/article/183046.htm">https://www.jb51.net/article/183046.htm</a></p>
<p><a href="https://blog.csdn.net/weixin_43738701/article/details/108846231">https://blog.csdn.net/weixin_43738701/article/details/108846231</a></p>
<p>首先要准备keytool-importkeypair工具，和签名所需的系统签名文件。</p>
<p>下载keytool-importkeypair</p>
<p><a href="https://github.com/getfatday/keytool-importkeypair">https://github.com/getfatday/keytool-importkeypair</a></p>
<p>签名文件</p>
<blockquote>
<p>build&#x2F;target&#x2F;product&#x2F;security&#x2F; platform.x509.pem、platform.pk8</p>
</blockquote>
<p>使用Android studio 生成自己的jks文件</p>
<p>keytool-importkeypair -k [jks文件名] -p [jks的密码] -pk8 platform.pk8 -cert platform.x509.pem -alias [导入的签名的别名]</p>
<h2 id="最终签名推荐方法"><a href="#最终签名推荐方法" class="headerlink" title="最终签名推荐方法"></a>最终签名推荐方法</h2><p><strong>最后发现，Android SDK已经提供了签名工具</strong>：</p>
<p>在SDK的 build-tools&#x2F;对应sdk目录&#x2F;下有 apksigner.bat</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">详细用法可以</span><br><span class="line">apksigner -h</span><br><span class="line">校验签名可以</span><br><span class="line">apksigner verify -v xxx.apk</span><br><span class="line">系统签名</span><br><span class="line">apksigner sign --key platform.pk8 --cert platform.x509.pem --out signed.apk xxx.apk</span><br><span class="line">系统签名导入keystore之后，用keysore来签名</span><br><span class="line">apksigner sign --ks test.jks --ks-key-alias platform --out signed.apk xxx.apk</span><br></pre></td></tr></table></figure>
<p>可以参考 <a href="https://developer.android.google.cn/tools/apksigner?hl=zh-cn#usage-sign">https://developer.android.google.cn/tools/apksigner?hl=zh-cn#usage-sign</a></p>
<h2 id="查看签名文件中的签名"><a href="#查看签名文件中的签名" class="headerlink" title="查看签名文件中的签名"></a>查看签名文件中的签名</h2><p>需要输入签名文件的密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keytool -list -v -keystore platform.jks</span><br></pre></td></tr></table></figure>
<h2 id="查看pem证书签名"><a href="#查看pem证书签名" class="headerlink" title="查看pem证书签名"></a>查看pem证书签名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in platform.x509.pem -text -noout</span><br></pre></td></tr></table></figure>
<h2 id="查看apk签名"><a href="#查看apk签名" class="headerlink" title="查看apk签名"></a>查看apk签名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apksigner verify --print-certs *.apk</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>HIDL</title>
    <url>/2023/10/23/android_fw/110.HIDL/</url>
    <content><![CDATA[<h1 id="关于HAL"><a href="#关于HAL" class="headerlink" title="关于HAL"></a>关于HAL</h1><p>HAL的全称 Hardware abstraction layer，即硬件抽象层</p>
<p>在Android 8 及之后的版本，较低级别的层采用新的、更加模块化的架构来重新编写的。运行 Android 8.0 及更高版本的设备必须支持以 HIDL 编写的 HAL，但下面列出了一些例外情况<br>这些HAL可以是绑定式或者直通式，在Android 11 中 HAL支持用AIDL来编写，所有AIDL编写的HAL都是绑定式的。</p>
<ul>
<li><p>绑定式： 以HAL接口定义语言（HIDL）或者 Android接口定义语言（AIDL）来表示的HAL，这些HAL替代了早期android版本中使用的传动HAL和遗留HAL，<br>  在绑定式HAL中，Android Framework和HAL之间通过binder来进行进程间通信，所有搭载Android 8或后续版本进行发布的设备必须仅支持绑定式。</p>
</li>
<li><p>直通式： 以HIDL封装的传统HAL或旧版HAL。这些HAL封装了现有的HAL，可在绑定模式和Same-Process（直通）模式下使用。<br>  升级到Android 8.0 的设备可以使用直通式 HAL。</p>
</li>
</ul>
<p>另外官方列出了一个表格，列出了例外情况：可以参考官网连接：<a href="https://source.android.google.cn/docs/core/architecture/hal#passthrough">https://source.android.google.cn/docs/core/architecture/hal#passthrough</a></p>
<h1 id="关于HIDL"><a href="#关于HIDL" class="headerlink" title="关于HIDL"></a>关于HIDL</h1><p>HIDL 全称 HAL 接口定义语言，是用于指定 HAL 和其用户之间的接口的一种接口描述语言，HIDL允许指定类型和方法调用，将其汇集到接口和软件包中，<br>从更广泛的意义上来说，HIDL 是指用于在可以独立编译的代码库之间进行通信的系统。从 Android 10 开始，HIDL 已废弃，Android 将在所有位置改用 AIDL。</p>
<p>HIDL用于进程间通信，使用 HDL 创建的 HAL 称为绑定式 HAL，因为它们可以使用 Binder 进程间通信 (IPC) 调用与其他架构层进行通信，绑定式 HAL 在独立于使用它们的客户端的进程中运行。<br>对于必须与进程相关联的library，还可以使用透传模式（在 Java 中不受支持）。</p>
<h1 id="关于HAL的目录结构"><a href="#关于HAL的目录结构" class="headerlink" title="关于HAL的目录结构"></a>关于HAL的目录结构</h1><ul>
<li>ROOT-DIRECTORY        (hardware&#x2F;interfaces 或者 vendor&#x2F;VENDOR&#x2F;interfaces)<ul>
<li>MODULE            模块<ul>
<li>SUBMODULE     （可选）模块下的子模块<ul>
<li>VERSION   版本</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>软件包的名称也有命名规范</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PACKAGE.MODULE[.SUBMODULE[.SUBMODULE[…]]]@VERSION</span><br></pre></td></tr></table></figure>
<ul>
<li>PACKAGE 是映射到 ROOT-DIRECTORY 的软件包。具体来说，PACKAGE 是：<br>  android.hardware（如果是核心 HIDL 软件包）（映射到 hardware&#x2F;interfaces）。<br>  vendor.VENDOR.hardware（如果是供应商软件包），其中 VENDOR 是指 SoC 供应商或原始设备制造商 OEM&#x2F;原始设计制造商 (ODM)（映射到 vendor&#x2F;VENDOR&#x2F;interfaces）。</li>
<li>MODULE[.SUBMODULE[.SUBMODULE[…]]]@VERSION 与目录结构中所述结构内的文件夹名称完全相同。</li>
<li>软件包名称应为小写。如果软件包名称包含多个字词，这些字词应当用作子模块或以 snake_case 形式书写。</li>
<li>不允许使用空格。</li>
</ul>
<h1 id="HIDL（C-）"><a href="#HIDL（C-）" class="headerlink" title="HIDL（C++）"></a>HIDL（C++）</h1><p>参考官网:<a href="https://source.android.google.cn/docs/core/architecture/hidl-cpp?hl=zh-cn">https://source.android.google.cn/docs/core/architecture/hidl-cpp?hl=zh-cn</a></p>
]]></content>
  </entry>
  <entry>
    <title>关于loadlibrary</title>
    <url>/2023/11/01/android_fw/111.loadLibrary/</url>
    <content><![CDATA[<h1 id="添加log调试loadlibrary"><a href="#添加log调试loadlibrary" class="headerlink" title="添加log调试loadlibrary"></a>添加log调试loadlibrary</h1><ol>
<li>修改 <code>java_vm_ext.cc</code>的JavaVMExt::LoadNativeLibrary<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOG(INFO) &lt;&lt; &quot;LoadNativeLibrary path = &quot; &lt;&lt; path;</span><br></pre></td></tr></table></figure></li>
<li>编译<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make libart</span><br></pre></td></tr></table></figure></li>
<li>备份so<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">bak_dir=libart</span><br><span class="line"></span><br><span class="line">if [ -d $bak_dir ]</span><br><span class="line">then</span><br><span class="line">    zenity --question --text &quot;备份已存在，是否删除原有备份，重新备份?&quot;</span><br><span class="line">    if [ $? -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        rm -rf $bak_dir</span><br><span class="line">    else</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">mkdir -p $bak_dir/lib</span><br><span class="line">mkdir -p $bak_dir/lib64</span><br><span class="line"></span><br><span class="line">adb shell &quot;su root setenforce 0&quot;</span><br><span class="line">adb shell setenforce 0</span><br><span class="line">adb root</span><br><span class="line">adb remount</span><br><span class="line">adb pull /system/apex/com.android.art.debug/lib/libart.so $bak_dir/lib/</span><br><span class="line">adb pull /system/apex/com.android.art.debug/lib64/libart.so $bak_dir/lib64/</span><br><span class="line"></span><br><span class="line">echo -e &quot;finish\n&quot;</span><br></pre></td></tr></table></figure></li>
<li>替换so<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">adb wait-for-device</span><br><span class="line">libso=/home/lifeifei/workspace/changan_75a322/lagvm/lagvm/LINUX/android/out/target/product/msmnile_gvmq/system/apex/com.android.art.release/lib/libart.so</span><br><span class="line">lib64so=/home/lifeifei/workspace/changan_75a322/lagvm/lagvm/LINUX/android/out/target/product/msmnile_gvmq/system/apex/com.android.art.release/lib64/libart.so</span><br><span class="line"></span><br><span class="line">adb shell &quot;su root setenforce 0&quot;</span><br><span class="line">adb shell setenforce 0</span><br><span class="line">adb root</span><br><span class="line">adb remount</span><br><span class="line"></span><br><span class="line">adb push $libso /system/apex/com.android.art.debug/lib/</span><br><span class="line">adb push $lib64so /system/apex/com.android.art.debug/lib64/</span><br><span class="line"></span><br><span class="line">adb shell sync</span><br><span class="line"></span><br><span class="line">adb shell stop</span><br><span class="line">adb shell start</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>java层调用System.loadLibrary</p>
<p>System.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void loadLibrary(String libname) &#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runtime.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void loadLibrary0(Class&lt;?&gt; fromClass, String libname) &#123;</span><br><span class="line">    ClassLoader classLoader = ClassLoader.getClassLoader(fromClass);</span><br><span class="line">    loadLibrary0(classLoader, fromClass, libname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private synchronized void loadLibrary0(ClassLoader loader, Class&lt;?&gt; callerClass, String libname) &#123;</span><br><span class="line">    if (libname.indexOf((int)File.separatorChar) != -1) &#123;</span><br><span class="line">        throw new UnsatisfiedLinkError(</span><br><span class="line">&quot;Directory separator should not appear in library name: &quot; + libname);</span><br><span class="line">    &#125;</span><br><span class="line">    String libraryName = libname;</span><br><span class="line">    // Android-note: BootClassLoader doesn&#x27;t implement findLibrary(). http://b/111850480</span><br><span class="line">    // Android&#x27;s class.getClassLoader() can return BootClassLoader where the RI would</span><br><span class="line">    // have returned null; therefore we treat BootClassLoader the same as null here.</span><br><span class="line">    if (loader != null &amp;&amp; !(loader instanceof BootClassLoader)) &#123;</span><br><span class="line">        String filename = loader.findLibrary(libraryName);</span><br><span class="line">        if (filename == null &amp;&amp;</span><br><span class="line">                (loader.getClass() == PathClassLoader.class ||</span><br><span class="line">                 loader.getClass() == DelegateLastClassLoader.class)) &#123;</span><br><span class="line">            // Don&#x27;t give up even if we failed to find the library in the native lib paths.</span><br><span class="line">            // The underlying dynamic linker might be able to find the lib in one of the linker</span><br><span class="line">            // namespaces associated with the current linker namespace. In order to give the</span><br><span class="line">            // dynamic linker a chance, proceed to load the library with its soname, which</span><br><span class="line">            // is the fileName.</span><br><span class="line">            // Note that we do this only for PathClassLoader  and DelegateLastClassLoader to</span><br><span class="line">            // minimize the scope of this behavioral change as much as possible, which might</span><br><span class="line">            // cause problem like b/143649498. These two class loaders are the only</span><br><span class="line">            // platform-provided class loaders that can load apps. See the classLoader attribute</span><br><span class="line">            // of the application tag in app manifest.</span><br><span class="line">            filename = System.mapLibraryName(libraryName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (filename == null) &#123;</span><br><span class="line">            // It&#x27;s not necessarily true that the ClassLoader used</span><br><span class="line">            // System.mapLibraryName, but the default setup does, and it&#x27;s</span><br><span class="line">            // misleading to say we didn&#x27;t find &quot;libMyLibrary.so&quot; when we</span><br><span class="line">            // actually searched for &quot;liblibMyLibrary.so.so&quot;.</span><br><span class="line">            throw new UnsatisfiedLinkError(loader + &quot; couldn&#x27;t find \&quot;&quot; +</span><br><span class="line">                                           System.mapLibraryName(libraryName) + &quot;\&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String error = nativeLoad(filename, loader);</span><br><span class="line">        if (error != null) &#123;</span><br><span class="line">            throw new UnsatisfiedLinkError(error);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We know some apps use mLibPaths directly, potentially assuming it&#x27;s not null.</span><br><span class="line">    // Initialize it here to make sure apps see a non-null value.</span><br><span class="line">    getLibPaths();</span><br><span class="line">    String filename = System.mapLibraryName(libraryName);</span><br><span class="line">    String error = nativeLoad(filename, loader, callerClass);</span><br><span class="line">    if (error != null) &#123;</span><br><span class="line">        throw new UnsatisfiedLinkError(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>ART学习笔记</title>
    <url>/2023/11/02/android_fw/112.ART/</url>
    <content><![CDATA[<h2 id="涉及到的目录"><a href="#涉及到的目录" class="headerlink" title="涉及到的目录"></a>涉及到的目录</h2><p>在aosp根目录下：</p>
<ul>
<li>art 目录 </li>
<li>libcore 目录</li>
<li>libnativehelper 目录</li>
<li></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>AOSP nativie层头文件路径</title>
    <url>//pages/755d7a/</url>
    <content><![CDATA[<p>binder：android\frameworks\native\libs\binder\include</p>
<p>utils：android\system\core\libutils\include</p>
<p>log: android\system\core\liblog\include</p>
]]></content>
  </entry>
  <entry>
    <title>Android多用户中的URI</title>
    <url>//pages/1e224e/</url>
    <content><![CDATA[<p>多用户情况下，ContentProvider也会提供不同用户的数据，通过resover去查询的时候默认是查询当前进程的用户对应的provider下的数据。</p>
<p>跨用户查询时需要在Uri的authority上做区别</p>
<p>Uri的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;authority&gt;&lt;absolute path&gt;?&lt;query&gt;#&lt;fragment&gt;</span><br></pre></td></tr></table></figure>

<p>ContentProvider的Uri格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content://&lt;authority&gt;&lt;absolute path&gt;?&lt;query&gt;#&lt;fragment&gt;</span><br></pre></td></tr></table></figure>

<p>其中authority的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ userinfo &#x27;@&#x27; ] host [ &#x27;:&#x27; port ]</span><br></pre></td></tr></table></figure>

<p><strong>所以可以通过uri中的authority指定userId来查询指定用户的provider。</strong></p>
<p>如 <code>content://10@testprovider/data</code> 指定userid为10</p>
<p><strong>另外有系统签名的APP可以通过ContentProvider.maybeAddUserId方法来获取指定用户的uri</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Uri uri = ContentProvider.maybeAddUserId(uri, userId);</span><br></pre></td></tr></table></figure>
<p>其实maybeAddUserId内部也是通过字符串拼接userid生成新的uri</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">public static Uri maybeAddUserId(Uri uri, int userId) &#123;</span><br><span class="line">    if (uri == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else if (userId != -2 &amp;&amp; &quot;content&quot;.equals(uri.getScheme()) &amp;&amp; !uriHasUserId(uri)) &#123;</span><br><span class="line">        Builder builder = uri.buildUpon();</span><br><span class="line">        builder.encodedAuthority(&quot;&quot; + userId + &quot;@&quot; + uri.getEncodedAuthority());</span><br><span class="line">        return builder.build();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考:</p>
<p><a href="https://developer.android.google.cn/reference/java/net/URI?hl=en#uri-syntax-and-components">Android Developers官网 URI</a></p>
<p><a href="https://blog.csdn.net/wanghg_ty/article/details/79089391">android 多用户笔记</a></p>
]]></content>
  </entry>
  <entry>
    <title>NotificationManagerService</title>
    <url>//pages/033d2d/</url>
    <content><![CDATA[<h2 id="分析Android11开始无法后台弹出Toast的原因"><a href="#分析Android11开始无法后台弹出Toast的原因" class="headerlink" title="分析Android11开始无法后台弹出Toast的原因"></a>分析Android11开始无法后台弹出Toast的原因</h2><p>toast调用的就是NotificationManagerService中的<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java#2817">enqueueToast</a></p>
<p>其中有限制了自定义toast的弹窗，判断当前的pkg是否被block，如果是block就不让弹出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean isAppRenderedToast = (callback != null);</span><br><span class="line">        if (isAppRenderedToast &amp;&amp; !isSystemToast &amp;&amp; !isPackageInForegroundForToast(pkg,</span><br><span class="line">                callingUid)) &#123;</span><br><span class="line">            boolean block;</span><br><span class="line">            long id = Binder.clearCallingIdentity();</span><br><span class="line">            try &#123;</span><br><span class="line">                // CHANGE_BACKGROUND_CUSTOM_TOAST_BLOCK is gated on targetSdk, so block will be</span><br><span class="line">                // false for apps with targetSdk &lt; R. For apps with targetSdk R+, text toasts</span><br><span class="line">                // are not app-rendered, so isAppRenderedToast == true means it&#x27;s a custom</span><br><span class="line">                // toast.</span><br><span class="line">                //这里判断是否block，如果block了就不让弹出自定义toast，</span><br><span class="line">                //而这里判断的依据是判断 CHANGE_BACKGROUND_CUSTOM_TOAST_BLOCK 这个id是否被启用，启用就会block</span><br><span class="line">                block = mPlatformCompat.isChangeEnabledByPackageName(</span><br><span class="line">                        CHANGE_BACKGROUND_CUSTOM_TOAST_BLOCK, pkg,</span><br><span class="line">                        callingUser.getIdentifier());</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                // Shouldn&#x27;t happen have since it&#x27;s a local local</span><br><span class="line">                Slog.e(TAG, &quot;Unexpected exception while checking block background custom toasts&quot;</span><br><span class="line">                        + &quot; change&quot;, e);</span><br><span class="line">                block = false;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(id);</span><br><span class="line">            &#125;</span><br><span class="line">            if (block) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Blocking custom toast from package &quot; + pkg</span><br><span class="line">                        + &quot; due to package not in the foreground&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">/**</span><br><span class="line"> * Apps that post custom toasts in the background will have those blocked. Apps can</span><br><span class="line"> * still post toasts created with</span><br><span class="line"> * &#123;@link android.widget.Toast#makeText(Context, CharSequence, int)&#125; and its variants while</span><br><span class="line"> * in the background.</span><br><span class="line"> * 看注释和注解，在Q版本之后，这个id就会被启用，所以targetSDK在Q之后，也就是R开始，后台自定义Toast会受限，不会弹出</span><br><span class="line"> */</span><br><span class="line">@ChangeId</span><br><span class="line">@EnabledAfter(targetSdkVersion = Build.VERSION_CODES.Q)</span><br><span class="line">private static final long CHANGE_BACKGROUND_CUSTOM_TOAST_BLOCK = 128611929L;</span><br></pre></td></tr></table></figure>

<p>继续看 <code>mPlatformCompat.isChangeEnabledByPackageName</code>,IPlatformCompat的实现类是PlatformCompat，这个方法的具体实现<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/compat/PlatformCompat.java#123">如下</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean isChangeEnabledByPackageName(long changeId, String packageName,</span><br><span class="line">        @UserIdInt int userId) &#123;</span><br><span class="line">    checkCompatChangeReadAndLogPermission();</span><br><span class="line">    //先获取App信息，没有获取到，默认认为启用新特性</span><br><span class="line">    ApplicationInfo appInfo = getApplicationInfo(packageName, userId);</span><br><span class="line">    if (appInfo == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return isChangeEnabled(changeId, appInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean isChangeEnabled(long changeId, ApplicationInfo appInfo) &#123;</span><br><span class="line">    checkCompatChangeReadAndLogPermission();</span><br><span class="line">    return isChangeEnabledInternal(changeId, appInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Internal version of the above method. Does not perform costly permission check.</span><br><span class="line"> */</span><br><span class="line">public boolean isChangeEnabledInternal(long changeId, ApplicationInfo appInfo) &#123;</span><br><span class="line">	//通过CompatConfig这个类去检查是否针对app启用了新特性</span><br><span class="line">    if (mCompatConfig.isChangeEnabled(changeId, appInfo)) &#123;</span><br><span class="line">        reportChange(changeId, appInfo.uid,</span><br><span class="line">                ChangeReporter.STATE_ENABLED);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    reportChange(changeId, appInfo.uid,</span><br><span class="line">            ChangeReporter.STATE_DISABLED);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//而CompatConfig是在PlatformCompat的构造方法中创建的</span><br><span class="line">public PlatformCompat(Context context) &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mChangeReporter = new ChangeReporter(</span><br><span class="line">            ChangeReporter.SOURCE_SYSTEM_SERVER);</span><br><span class="line">    mCompatConfig = CompatConfig.create(new AndroidBuildClassifier(), mContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看一下CompatConfig这个类，发现这个类在构造方法中去读取了指定目录下的xml配置文件，将xml解析成 CompatConfig。而这个CompactConfig中就包含了所有的CompatChange。有一个疑问点，这个CompatChange只看到解析，没有看到在那里生成的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static CompatConfig create(AndroidBuildClassifier androidBuildClassifier, Context context) &#123;</span><br><span class="line">	//创建一个CompatConfig</span><br><span class="line">    CompatConfig config = new CompatConfig(androidBuildClassifier, context);</span><br><span class="line">    //从/etc/compatconfig目录下读取配置，并初始化</span><br><span class="line">    config.initConfigFromLib(Environment.buildPath(</span><br><span class="line">            Environment.getRootDirectory(), &quot;etc&quot;, &quot;compatconfig&quot;));</span><br><span class="line">    //从/system_etc/etc/compatconfig目录下读取配置，并初始化</span><br><span class="line">    config.initConfigFromLib(Environment.buildPath(</span><br><span class="line">            Environment.getRootDirectory(), &quot;system_ext&quot;, &quot;etc&quot;, &quot;compatconfig&quot;));</span><br><span class="line"></span><br><span class="line">    List&lt;ApexManager.ActiveApexInfo&gt; apexes = ApexManager.getInstance().getActiveApexInfos();</span><br><span class="line">    for (ApexManager.ActiveApexInfo apex : apexes) &#123;</span><br><span class="line">        config.initConfigFromLib(Environment.buildPath(</span><br><span class="line">                apex.apexDirectory, &quot;etc&quot;, &quot;compatconfig&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    config.invalidateCache();</span><br><span class="line">    return config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void initConfigFromLib(File libraryDir) &#123;</span><br><span class="line">    if (!libraryDir.exists() || !libraryDir.isDirectory()) &#123;</span><br><span class="line">        Slog.d(TAG, &quot;No directory &quot; + libraryDir + &quot;, skipping&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //遍历目录下的所有文件，读取配置</span><br><span class="line">    for (File f : libraryDir.listFiles()) &#123;</span><br><span class="line">        Slog.d(TAG, &quot;Found a config file: &quot; + f.getPath());</span><br><span class="line">        //TODO(b/138222363): Handle duplicate ids across config files.</span><br><span class="line">        readConfig(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private void readConfig(File configFile) &#123;</span><br><span class="line">    try (InputStream in = new BufferedInputStream(new FileInputStream(configFile))) &#123;</span><br><span class="line">        for (Change change : XmlParser.read(in).getCompatChange()) &#123;</span><br><span class="line">            Slog.d(TAG, &quot;Adding: &quot; + change.toString());</span><br><span class="line">            //通过XmlParser将xml文件解析成Change对象，然后封装成CompatChange对象</span><br><span class="line">            addChange(new CompatChange(change));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException | DatatypeConfigurationException | XmlPullParserException e) &#123;</span><br><span class="line">        Slog.e(TAG, &quot;Encountered an error while reading/parsing compat config file&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Add a change. This is intended to be used by code that reads change config from the</span><br><span class="line"> * filesystem. This should be done at system startup time.</span><br><span class="line"> *</span><br><span class="line"> * @param change The change to add. Any change with the same ID will be overwritten.</span><br><span class="line"> */</span><br><span class="line">void addChange(CompatChange change) &#123;</span><br><span class="line">    synchronized (mChanges) &#123;</span><br><span class="line">        mChanges.put(change.getId(), change);</span><br><span class="line">        invalidateCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@VisibleForTesting</span><br><span class="line">CompatConfig(AndroidBuildClassifier androidBuildClassifier, Context context) &#123;</span><br><span class="line">    mOverrideValidator = new OverrideValidatorImpl(androidBuildClassifier, context, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Find if a given change is enabled for a given application.</span><br><span class="line"> * 查询指定的app是否启用了指定的新特性</span><br><span class="line"> *</span><br><span class="line"> * @param changeId The ID of the change in question</span><br><span class="line"> * @param app      App to check for</span><br><span class="line"> * @return &#123;@code true&#125; if the change is enabled for this app. Also returns &#123;@code true&#125; if the</span><br><span class="line"> * change ID is not known, as unknown changes are enabled by default.</span><br><span class="line"> */</span><br><span class="line">boolean isChangeEnabled(long changeId, ApplicationInfo app) &#123;</span><br><span class="line">    synchronized (mChanges) &#123;</span><br><span class="line">    	//通过特性id取到 新特性</span><br><span class="line">        CompatChange c = mChanges.get(changeId);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            // we know nothing about this change: default behaviour is enabled.</span><br><span class="line">            //没有找到该特性，那就默认启用</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //取出来的CompatChange，判断一下指定的app是否启用</span><br><span class="line">        return c.isEnabled(app);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在知道，Toast时，会去判断<strong>限制后台自定义toast</strong>这个新特性（CompatChange）是否启用，判断的逻辑是读取xml配置文件，从文件中解析出CompatChange列表，但目前没有看到这个配置文件是如何生成的。</p>
<p>但接着看<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/compat/CompatChange.java#82">CompatChange</a>这个类，里面的注释写着：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param change an object generated by services/core/xsd/platform-compat-config.xsd</span><br><span class="line"> * change对象是通过 services/core/xsd/platform-compat-config.xsd 生成的</span><br><span class="line"> */</span><br><span class="line">public CompatChange(Change change) &#123;</span><br><span class="line">    super(change.getId(), change.getName(), change.getEnableAfterTargetSdk(),</span><br><span class="line">            change.getDisabled(), change.getLoggingOnly(), change.getDescription());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>去看platform-compat-config.xsd，注释里又写着这是个模板，真正生成xml的是<a href="http://aospxref.com/android-11.0.0_r21/xref/tools/platform-compat/java/android/processor/compat/changeid/ChangeIdProcessor.java#51">com.android.compat.annotation.ChangeIdProcessor</a>,所以配置文件是在编译时生成的，是根据注解来生成的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- This defines the format of the XML file generated by</span><br><span class="line">  ~ com.android.compat.annotation.ChangeIdProcessor annotation processor (from</span><br><span class="line">  ~ tools/platform-compat), and is parsed in com/android/server/compat/CompatConfig.java.</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，就看最关键的一步，CompatChange是如何判断指定app是否启用该特性的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Find if this change is enabled for the given package, taking into account any overrides that</span><br><span class="line">    * exist.</span><br><span class="line">    *</span><br><span class="line">    * @param app Info about the app in question</span><br><span class="line">    * @return &#123;@code true&#125; if the change should be enabled for the package.</span><br><span class="line">    */</span><br><span class="line">   boolean isEnabled(ApplicationInfo app) &#123;</span><br><span class="line">   	//判断map中是否有指定的app重写的启用禁用值，如果app重写过，就用重写后的启用状态</span><br><span class="line">       if (mPackageOverrides != null &amp;&amp; mPackageOverrides.containsKey(app.packageName)) &#123;</span><br><span class="line">           return mPackageOverrides.get(app.packageName);</span><br><span class="line">       &#125;</span><br><span class="line">       //判断是否禁用，禁用就直接返回</span><br><span class="line">       if (getDisabled()) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       //判断app的targetSdk是否大于开始启用的sdk，大于开始启用的sdk就会启用</span><br><span class="line">       if (getEnableAfterTargetSdk() != -1) &#123;</span><br><span class="line">           return app.targetSdkVersion &gt; getEnableAfterTargetSdk();</span><br><span class="line">       &#125;</span><br><span class="line">       //默认启用</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="后台弹出Toast的方法"><a href="#后台弹出Toast的方法" class="headerlink" title="后台弹出Toast的方法"></a>后台弹出Toast的方法</h2><p>所以在Toast之前，</p>
<ol>
<li>先去判断<strong>限制后台自定义toast</strong>新特性在当前app中是否重写过启用状态，重写过就用重写的状态，</li>
<li>没有重写，判断是否禁用，禁用就直接返回</li>
<li>没有禁用，判断app的targetSdk是否大于注解中指定的sdk，大于则启用</li>
<li>以上条件都不满足，默认启用</li>
</ol>
<p>想要让app后台弹toast就有几种方式：</p>
<ol>
<li>降低app的targetSdk，不能大于29</li>
<li>修改 NotificationManagerService中CHANGE_BACKGROUND_CUSTOM_TOAST_BLOCK的注解，将开始启用的sdk值改得比app的targetSdk更大</li>
<li>NotificationManagerService的CHANGE_BACKGROUND_CUSTOM_TOAST_BLOCK添加@Disabled注解，禁用该特性</li>
<li>重写指定app的启用状态</li>
</ol>
<p>目前看来重写指定app的启用状态，影响范围最小，重写启用状态，需要调用CompatChange的addPackageOverride方法，往上找，看有没有什么api，最后发现在PlatformCompat中有<code>setOverrides(CompatibilityChangeConfig overrides, String packageName)</code>来重新设置特性启用状态，但是传入的参数是多个特性的复合体，使用CompatConfig的addOverride控制更精确，可以在PlatformCompat中对CompatConfig构造完成时，修改一下指定app的启用状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Force the enabled state of this change for a given package name. The change will only take</span><br><span class="line"> * effect after that packages process is killed and restarted.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Note, this method is not thread safe so callers must ensure thread safety.</span><br><span class="line"> *</span><br><span class="line"> * @param pname Package name to enable the change for.</span><br><span class="line"> * @param enabled Whether or not to enable the change.</span><br><span class="line"> */</span><br><span class="line">void addPackageOverride(String pname, boolean enabled) &#123;</span><br><span class="line">    if (getLoggingOnly()) &#123;</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">                &quot;Can&#x27;t add overrides for a logging only change &quot; + toString());</span><br><span class="line">    &#125;</span><br><span class="line">    if (mPackageOverrides == null) &#123;</span><br><span class="line">        mPackageOverrides = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mPackageOverrides.put(pname, enabled);</span><br><span class="line">    notifyListener(pname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>修改Android默认语言</title>
    <url>//pages/0f7a5e/</url>
    <content><![CDATA[<figure class="highlight plaintext"><figcaption><span>看到：默认语言是```PRODUCT_LOCALES``中的定义的第一个locale</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">~~~</span><br><span class="line"># Accepts a whitespace separated list of product locales such as</span><br><span class="line"># (en_US en_AU en_GB...) and returns the first locale in the list with</span><br><span class="line"># underscores replaced with hyphens. In the example above, this will</span><br><span class="line"># return &quot;en-US&quot;.</span><br><span class="line">#接受由空格分隔的产品区域设置列表，例如(en_US en_AU en_GB…)并返回列表中的第一个下划线替换为连字符语言环境。在上面的例子中，这将会返回“en-US”。</span><br><span class="line">define get-default-product-locale</span><br><span class="line">$(strip $(subst _,-, $(firstword $(1))))</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">PRODUCT_DEFAULT_LOCALE=&quot;$(call get-default-product-locale,$(PRODUCT_LOCALES))&quot; \</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">并且Makefile中会去执行```build/make/tools/buildinfo.sh```,在```build/make/tools/buildinfo.sh```中会将默认语言写到只读属性（ro.product.locale）</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">if [ -n &quot;$PRODUCT_DEFAULT_LOCALE&quot; ] ; then</span><br><span class="line">  echo &quot;ro.product.locale=$PRODUCT_DEFAULT_LOCALE&quot;</span><br><span class="line">fi</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">**所以在最终的mk中修改PRODUCT_LOCALES这个宏定义就可以修改默认语言**</span><br><span class="line"></span><br><span class="line">mk中一些赋值符号的区别：注意&quot;=&quot;并不是实时赋值，而是递归赋值</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">= 是最基本的赋值</span><br><span class="line">:= 是覆盖之前的值</span><br><span class="line">?= 是如果没有被赋值过就赋予等号后面的值</span><br><span class="line">+= 是添加等号后面的值</span><br><span class="line"></span><br><span class="line">而 = 与 := 的区别在于，= 会在makefile 展开后再决定变量的值，即最后被指定的值</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br><span class="line">            x = foo</span><br><span class="line">            y = $(x) bar</span><br><span class="line">            x = xyz</span><br><span class="line"></span><br><span class="line">      在上例中，y的值将会是 xyz bar ，而不是 foo bar 。</span><br><span class="line"></span><br><span class="line">而:= 表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</span><br><span class="line">在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">语言显示控制</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;PhoneLanguagePreferenceController.java</p>
<pre><code>@Override
public boolean isAvailable() &#123;
    return mContext.getResources().getBoolean(R.bool.config_show_phone_language)
            &amp;&amp; mContext.getAssets().getLocales().length &gt; 1;
&#125;
</code></pre>
<p>&#x2F;&#x2F;AbstractPreferenceController.java<br>    &#x2F;**<br>     * Displays preference in this controller.<br>     <em>&#x2F;<br>    public void displayPreference(PreferenceScreen screen) {<br>        final String prefKey &#x3D; getPreferenceKey();<br>        if (TextUtils.isEmpty(prefKey)) {<br>            Log.w(TAG, “Skipping displayPreference because key is empty:” + getClass().getName());<br>            return;<br>        }<br>        if (isAvailable()) {<br>            setVisible(screen, prefKey, true &#x2F;</em> visible <em>&#x2F;);<br>            if (this instanceof Preference.OnPreferenceChangeListener) {<br>                final Preference preference &#x3D; screen.findPreference(prefKey);<br>                preference.setOnPreferenceChangeListener(<br>                        (Preference.OnPreferenceChangeListener) this);<br>            }<br>        } else {<br>            setVisible(screen, prefKey, false &#x2F;</em> visible *&#x2F;);<br>        }<br>    }</p>
<pre><code>
在系统语言设置列表中多出一个```([XB])cibarA```的选项

因为LanguagePickerPreferenceController.java中针对userdebug版本的ROM添加了测试RTL的伪语言环境：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Add a pseudo locale in debug build for testing RTL.</span><br><span class="line"> *</span><br><span class="line"> * @param localeInfos the set of &#123;@link LocaleStore.LocaleInfo&#125; to which the locale is added.</span><br><span class="line"> */</span><br><span class="line">private void maybeAddPseudoLocale(Set&lt;LocaleStore.LocaleInfo&gt; localeInfos) &#123;</span><br><span class="line">    if (Build.IS_USERDEBUG) &#123;</span><br><span class="line">        // The ar-XB pseudo-locale is RTL.</span><br><span class="line">        localeInfos.add(LocaleStore.getLocaleInfo(new Locale(&quot;ar&quot;, &quot;XB&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>OemLockService</title>
    <url>//pages/385f7b/</url>
    <content><![CDATA[<h2 id="OemLockService的启动流程"><a href="#OemLockService的启动流程" class="headerlink" title="OemLockService的启动流程"></a>OemLockService的启动流程</h2><p>OemLockService是在SystemServer的startOtherServices中启动的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         //读取属性值，判断是否有数据锁</span><br><span class="line">         final boolean hasPdb = !SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals(&quot;&quot;);</span><br><span class="line">         final boolean hasGsi = SystemProperties.getInt(GSI_RUNNING_PROP, 0) &gt; 0;</span><br><span class="line">         if (hasPdb &amp;&amp; !hasGsi) &#123;</span><br><span class="line">             t.traceBegin(&quot;StartPersistentDataBlock&quot;);</span><br><span class="line">             mSystemServiceManager.startService(PersistentDataBlockService.class);</span><br><span class="line">             t.traceEnd();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         t.traceBegin(&quot;StartTestHarnessMode&quot;);</span><br><span class="line">         mSystemServiceManager.startService(TestHarnessModeService.class);</span><br><span class="line">         t.traceEnd();</span><br><span class="line">//有数据锁  或者 Vendor实现了IOemLock.hal,才去启动OemLockService</span><br><span class="line">         if (hasPdb || OemLockService.isHalPresent()) &#123;</span><br><span class="line">             // Implementation depends on pdb or the OemLock HAL</span><br><span class="line">             t.traceBegin(&quot;StartOemLockService&quot;);</span><br><span class="line">             mSystemServiceManager.startService(OemLockService.class);</span><br><span class="line">             t.traceEnd();</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看是否启用OemLockService"><a href="#查看是否启用OemLockService" class="headerlink" title="查看是否启用OemLockService"></a>查看是否启用OemLockService</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell &quot;service list |grep oem_lock&quot;</span><br></pre></td></tr></table></figure>


<h2 id="OemLock解锁"><a href="#OemLock解锁" class="headerlink" title="OemLock解锁"></a>OemLock解锁</h2><p>OemLock解锁，直接调用OemLockManager.setOemUnlockAllowedByUser(true)即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OemLockManager oemLockManager = getSystemService(OemLockManager.class);</span><br><span class="line">      oemLockManager.setOemUnlockAllowedByUser(true);</span><br></pre></td></tr></table></figure>



<p>实际上是调用的OemLockService的setOemUnlockAllowedByUser</p>
<p>OemLockService.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     // The user has the final say so if they allow unlock, then the device allows the bootloader</span><br><span class="line">     // to OEM unlock it.</span><br><span class="line">     @Override</span><br><span class="line">     public void setOemUnlockAllowedByUser(boolean allowedByUser) &#123;</span><br><span class="line">         if (ActivityManager.isUserAMonkey()) &#123;</span><br><span class="line">             // Prevent a monkey from changing this</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">//检查权限</span><br><span class="line">         enforceManageUserOemUnlockPermission();</span><br><span class="line">         //检查是否是主用户</span><br><span class="line">         enforceUserIsAdmin();</span><br><span class="line"></span><br><span class="line">         final long token = Binder.clearCallingIdentity();</span><br><span class="line">         try &#123;</span><br><span class="line">             if (!isOemUnlockAllowedByAdmin()) &#123;</span><br><span class="line">                 throw new SecurityException(&quot;Admin does not allow OEM unlock&quot;);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             if (!mOemLock.isOemUnlockAllowedByCarrier()) &#123;</span><br><span class="line">                 throw new SecurityException(&quot;Carrier does not allow OEM unlock&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">	//OEM解锁，这个mOemLock是在构造方法中，通过getOemLock创建的。</span><br><span class="line">             mOemLock.setOemUnlockAllowedByDevice(allowedByUser);</span><br><span class="line">             //这里是去调用的PersistentDataBlockService的forceOemUnlockEnabled，对文件写入了一些标记</span><br><span class="line">             setPersistentDataBlockOemUnlockAllowedBit(allowedByUser);</span><br><span class="line">         &#125; finally &#123;</span><br><span class="line">             Binder.restoreCallingIdentity(token);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> /** Select the OEM lock implementation */</span><br><span class="line"> private static OemLock getOemLock(Context context) &#123;</span><br><span class="line"> 	//先去取vendor实现的IOemLock，没有就用PersistentDataBlockLock</span><br><span class="line">     final IOemLock oemLockHal = VendorLock.getOemLockHalService();</span><br><span class="line">     if (oemLockHal != null) &#123;</span><br><span class="line">         Slog.i(TAG, &quot;Using vendor lock via the HAL&quot;);</span><br><span class="line">         return new VendorLock(context, oemLockHal);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         Slog.i(TAG, &quot;Using persistent data block based lock&quot;);</span><br><span class="line">         return new PersistentDataBlockLock(context);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>PersistentDataBlockLock.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">void setOemUnlockAllowedByDevice(boolean allowedByDevice) &#123;</span><br><span class="line">    // The method name is misleading as it really just means whether or not the device can be</span><br><span class="line">    // unlocked but doesn&#x27;t actually do any unlocking.</span><br><span class="line">    final PersistentDataBlockManager pdbm = (PersistentDataBlockManager)</span><br><span class="line">            mContext.getSystemService(Context.PERSISTENT_DATA_BLOCK_SERVICE);</span><br><span class="line">    if (pdbm == null) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;PersistentDataBlock is not supported on this device&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    pdbm.setOemUnlockEnabled(allowedByDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PersistentDataBlockService.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    public void setOemUnlockEnabled(boolean enabled) throws SecurityException &#123;</span><br><span class="line">        // do not allow monkey to flip the flag</span><br><span class="line">        if (ActivityManager.isUserAMonkey()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        enforceOemUnlockWritePermission();</span><br><span class="line">        enforceIsAdmin();</span><br><span class="line"></span><br><span class="line">        if (enabled) &#123;</span><br><span class="line">            // Do not allow oem unlock to be enabled if it&#x27;s disallowed by a user restriction.</span><br><span class="line">            enforceUserRestriction(UserManager.DISALLOW_OEM_UNLOCK);</span><br><span class="line">            enforceUserRestriction(UserManager.DISALLOW_FACTORY_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            doSetOemUnlockEnabledLocked(enabled);</span><br><span class="line">            computeAndWriteDigestLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void forceOemUnlockEnabled(boolean enabled) &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            doSetOemUnlockEnabledLocked(enabled);</span><br><span class="line">            computeAndWriteDigestLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">private void doSetOemUnlockEnabledLocked(boolean enabled) &#123;</span><br><span class="line">    FileOutputStream outputStream;</span><br><span class="line">    try &#123;</span><br><span class="line">        outputStream = new FileOutputStream(new File(mDataBlockFile));</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        Slog.e(TAG, &quot;partition not available&quot;, e);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        FileChannel channel = outputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        channel.position(getBlockDeviceSize() - 1);</span><br><span class="line"></span><br><span class="line">        ByteBuffer data = ByteBuffer.allocate(1);</span><br><span class="line">        data.put(enabled ? (byte) 1 : (byte) 0);</span><br><span class="line">        data.flip();</span><br><span class="line">        channel.write(data);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        Slog.e(TAG, &quot;unable to access persistent partition&quot;, e);</span><br><span class="line">        return;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	//Oem解锁后，会将解锁状态写入属性值 sys.oem_unlock_allowed</span><br><span class="line">        SystemProperties.set(OEM_UNLOCK_PROP, enabled ? &quot;1&quot; : &quot;0&quot;);</span><br><span class="line">        IoUtils.closeQuietly(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>AccessibilityService</title>
    <url>//pages/4f2f9f/</url>
    <content><![CDATA[<h1 id="AccessibilityService–无障碍服务"><a href="#AccessibilityService–无障碍服务" class="headerlink" title="AccessibilityService–无障碍服务"></a>AccessibilityService–无障碍服务</h1><p>所有的自定义无障碍服务有systemserver中的AccessibilityManagerService来管理</p>
<p>自定义无障碍服务继承自 AccessibilityService。</p>
<h2 id="自定义无障碍服务"><a href="#自定义无障碍服务" class="headerlink" title="自定义无障碍服务"></a>自定义无障碍服务</h2><p>参考官方文档：<a href="https://developer.android.google.cn/guide/topics/ui/accessibility/service?hl=zh-cn#create">https://developer.android.google.cn/guide/topics/ui/accessibility/service?hl=zh-cn#create</a></p>
<ol>
<li>自定义一个无障碍服务，继承自AccessibilityService<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CusABSService extends AccessibilityService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAccessibilityEvent(AccessibilityEvent event) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onInterrupt() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在AndroidManifest中声明服务：权限、action、配置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;application&gt;</span><br><span class="line"></span><br><span class="line">      &lt;service</span><br><span class="line">          android:name=&quot;com.test.utils.CusABSService&quot;</span><br><span class="line">          android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt; &lt;!-- 1. 服务权限 --&gt;</span><br><span class="line">          &lt;intent-filter&gt;</span><br><span class="line">              &lt;!--2. 服务必须要包含的action --&gt;</span><br><span class="line">              &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt;</span><br><span class="line">          &lt;/intent-filter&gt;</span><br><span class="line">          &lt;!--3. 自定义无障碍服务的配置 --&gt;</span><br><span class="line">          &lt;meta-data</span><br><span class="line">              android:name=&quot;android.accessibilityservice&quot;</span><br><span class="line">              android:resource=&quot;@xml/accessibility_service_config&quot; /&gt;</span><br><span class="line">      &lt;/service&gt;</span><br><span class="line"></span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>
accessibility_service_config.xml:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:description=&quot;自定义无障碍服务&quot;</span><br><span class="line">    &lt;!-- android:packageNames=&quot;com.test.utils.helper&quot; --&gt;</span><br><span class="line">    android:accessibilityEventTypes=&quot;typeAllMask&quot;</span><br><span class="line">    android:accessibilityFlags=&quot;flagDefault|flagRetrieveInteractiveWindows|flagRequestFilterKeyEvents&quot;</span><br><span class="line">    android:accessibilityFeedbackType=&quot;feedbackGeneric&quot;</span><br><span class="line">    android:notificationTimeout=&quot;100&quot;</span><br><span class="line">    android:canPerformGestures=&quot;true&quot;</span><br><span class="line">    android:canRetrieveWindowContent=&quot;true&quot;</span><br><span class="line">    android:canRequestFilterKeyEvents=&quot;true&quot;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="无障碍服务启动流程"><a href="#无障碍服务启动流程" class="headerlink" title="无障碍服务启动流程"></a>无障碍服务启动流程</h2><p>简单梳理一下自定义无障碍服务启动的流程：</p>
<p>systemserver起来后会初始化AccessibilityManagerService，AccessibilityManagerService会去<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java#3311">监听SettingsProvider中已启用的无障碍服务的uri变化</a>，收到变化后会去读取该uri，然后<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java#updateServicesLocked">更新无障碍服务</a>, 在更新时会去检查settingsprovider中设置的无障碍服务是否已经成功启用，没有启用的会创建一个AccessibilityServiceConnection对象，通过AccessibilityServiceConnection去<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/accessibility/java/com/android/server/accessibility/AccessibilityServiceConnection.java#94">连接要启用的无障碍服务</a>，通过bindServiceAsUser去连接自定义的无障碍服务，会将连接状态保存在AccessibilityUserState对象中【<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/accessibility/java/com/android/server/accessibility/AccessibilityServiceConnection.java#108">连接中</a>、<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/accessibility/java/com/android/server/accessibility/AccessibilityServiceConnection.java#171">连接成功</a>、<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/accessibility/java/com/android/server/accessibility/AccessibilityServiceConnection.java#312">连接断开</a>】</p>
<p>自定义的无障碍服务，继承自AccessibilityService，而在AccessibilityService的onBinder中返回的是一个 IAccessibilityServiceClientWrapper对象，AccessibilityManagerService连接上自定义的无障碍服务后，会通过binder来调用IAccessibilityServiceClientWrapper的init方法，init最终会回调到AccessibilityService的dispatchServiceConnected()，最终在自定义无障碍服务中收到onServiceConnected回调。</p>
<ol>
<li><p>SystemServer中启动AccessibilityManagerService</p>
</li>
<li><p>在AccessibilityManagerService中注册了广播和Uri变化监听（包含了Settings secure中的enabled_accessibility_services）</p>
<p>可以通过<code>settings list secure|grep enabled_accessibility_services</code>来查看启用的无障碍服务</p>
</li>
<li><p>AccessibilityManagerService会在enabled_accessibility_services值变化时，更新所有无障碍服务的状态</p>
</li>
<li><p>enabled_accessibility_services中新加了服务，AccessibilityManagerService会去启用该无障碍服务</p>
<ul>
<li><p>创建一个AccessibilityServiceConnection，在内部通过bindServiceAsUser去bind自定义的无障碍服务</p>
</li>
<li><p>bind状态会保存到AccessibilityUserState中</p>
</li>
<li><p>bind成功时，返回的是IAccessibilityServiceClientWrapper（AccessibilityService中继承IAccessibilityServiceClient.Stub的内部类），</p>
<p>AccessibilityServiceConnection会通过binder回调AccessibilityService的dispatchServiceConnected，最终在自定义无障碍服务中收到onServiceConnected回调</p>
</li>
</ul>
</li>
<li><p>enabled_accessibility_services中移除了服务，AccessibilityManagerService会去unbind该无障碍服务</p>
</li>
</ol>
<p><a href="https://developer.android.google.cn/reference/android/accessibilityservice/AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS">https://developer.android.google.cn/reference/android/accessibilityservice/AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS</a></p>
<h2 id="无障碍服务监听KeyEvent事件"><a href="#无障碍服务监听KeyEvent事件" class="headerlink" title="无障碍服务监听KeyEvent事件"></a>无障碍服务监听KeyEvent事件</h2><p>无障碍服务要监听KeyEvent需要配置flags和属性值,可以参考<a href="https://developer.android.google.cn/reference/android/accessibilityservice/AccessibilityServiceInfo#attr_android:canRequestFilterKeyEvents">官方文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android:accessibilityFlags=&quot;flagRequestFilterKeyEvents&quot;</span><br><span class="line">android:canRequestFilterKeyEvents=&quot;true&quot;</span><br></pre></td></tr></table></figure>

<h2 id="获取无障碍事件TYPE-WINDOWS-CHANGEDE"><a href="#获取无障碍事件TYPE-WINDOWS-CHANGEDE" class="headerlink" title="获取无障碍事件TYPE_WINDOWS_CHANGEDE"></a>获取无障碍事件TYPE_WINDOWS_CHANGEDE</h2><p>无障碍服务 收集  TYPE_WINDOWS_CHANGEDE，需要 FLAG_RETRIEVE_INTERACTIVE_WINDOWS 这个flag</p>
<p>AccessibilityManagerService源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void updateWindowsForAccessibilityCallbackLocked(AccessibilityUserState userState) &#123;</span><br><span class="line">    // We observe windows for accessibility only if there is at least</span><br><span class="line">    // one bound service that can retrieve window content that specified</span><br><span class="line">    // it is interested in accessing such windows. For services that are</span><br><span class="line">    // binding we do an update pass after each bind event, so we run this</span><br><span class="line">    // code and register the callback if needed.</span><br><span class="line"></span><br><span class="line">    boolean observingWindows = mUiAutomationManager.canRetrieveInteractiveWindowsLocked();</span><br><span class="line">    List&lt;AccessibilityServiceConnection&gt; boundServices = userState.mBoundServices;</span><br><span class="line">    final int boundServiceCount = boundServices.size();</span><br><span class="line">    for (int i = 0; !observingWindows &amp;&amp; (i &lt; boundServiceCount); i++) &#123;</span><br><span class="line">        AccessibilityServiceConnection boundService = boundServices.get(i);</span><br><span class="line">        if (boundService.canRetrieveInteractiveWindowsLocked()) &#123;</span><br><span class="line">            userState.setAccessibilityFocusOnlyInActiveWindow(false);</span><br><span class="line">            observingWindows = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    userState.setAccessibilityFocusOnlyInActiveWindow(true);</span><br><span class="line"></span><br><span class="line">    // Gets all valid displays and start tracking windows of each display if there is at least</span><br><span class="line">    // one bound service that can retrieve window content.</span><br><span class="line">    final ArrayList&lt;Display&gt; displays = getValidDisplayList();</span><br><span class="line">    for (int i = 0; i &lt; displays.size(); i++) &#123;</span><br><span class="line">        final Display display = displays.get(i);</span><br><span class="line">        if (display != null) &#123;</span><br><span class="line">            if (observingWindows) &#123;</span><br><span class="line">                mA11yWindowManager.startTrackingWindows(display.getDisplayId());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mA11yWindowManager.stopTrackingWindows(display.getDisplayId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于无障碍服务crash标记"><a href="#关于无障碍服务crash标记" class="headerlink" title="关于无障碍服务crash标记"></a>关于无障碍服务crash标记</h2><p>无障碍管理服务会记录异常断开的自定义无障碍服务，对应的app重启后不会再去启动其对应的自定义无障碍服务：<br>AccessibilityManagerService.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                //在收到ContentProvider数据变化时，先去读取settingsprovider的值，数据变化了才做后续更新操作</span><br><span class="line">                if (readEnabledAccessibilityServicesLocked(userState)) &#123;</span><br><span class="line">                    //这里是遍历所有无障碍服务，无障碍服务之前异常断开，并且目前也没有启用，就将其从mCrashedServices移除</span><br><span class="line">                    userState.updateCrashedServicesIfNeededLocked();</span><br><span class="line">                    onUserStateChangedLocked(userState);</span><br><span class="line">                &#125; </span><br><span class="line"></span><br><span class="line">private boolean readEnabledAccessibilityServicesLocked(AccessibilityUserState userState) &#123;</span><br><span class="line">    mTempComponentNameSet.clear();</span><br><span class="line">    readComponentNamesFromSettingLocked(Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,</span><br><span class="line">            userState.mUserId, mTempComponentNameSet);</span><br><span class="line">    //从settingsprovider读取的启用的无障碍服务列表 和 当前缓存的已启用无障碍服务列表不一致，更新一下返回true</span><br><span class="line">    if (!mTempComponentNameSet.equals(userState.mEnabledServices)) &#123;</span><br><span class="line">        userState.mEnabledServices.clear();</span><br><span class="line">        userState.mEnabledServices.addAll(mTempComponentNameSet);</span><br><span class="line">        mTempComponentNameSet.clear();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    mTempComponentNameSet.clear();</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void updateServicesLocked(AccessibilityUserState userState) &#123;</span><br><span class="line">    Map&lt;ComponentName, AccessibilityServiceConnection&gt; componentNameToServiceMap =</span><br><span class="line">            userState.mComponentNameToServiceMap;</span><br><span class="line">    //....</span><br><span class="line">    for (int i = 0, count = userState.mInstalledServices.size(); i &lt; count; i++) &#123;</span><br><span class="line">        AccessibilityServiceInfo installedService = userState.mInstalledServices.get(i);</span><br><span class="line">        ComponentName componentName = ComponentName.unflattenFromString(</span><br><span class="line">                installedService.getId());</span><br><span class="line"></span><br><span class="line">        AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);</span><br><span class="line"></span><br><span class="line">        //...</span><br><span class="line"></span><br><span class="line">        // Skip the component since it may be in process or crashed.</span><br><span class="line">        if (userState.getBindingServicesLocked().contains(componentName)</span><br><span class="line">                || userState.getCrashedServicesLocked().contains(componentName)) &#123;</span><br><span class="line">            Slog.i(LOG_TAG, userState.mUserId + &quot;, skip &quot; + componentName + &quot;, reason : in bind process or crashed.&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (userState.mEnabledServices.contains(componentName)</span><br><span class="line">                &amp;&amp; !mUiAutomationManager.suppressingAccessibilityServicesLocked()) &#123;</span><br><span class="line">            if (service == null) &#123;</span><br><span class="line">                service = new AccessibilityServiceConnection(userState, mContext, componentName,</span><br><span class="line">                        installedService, sIdCounter++, mMainHandler, mLock, mSecurityPolicy,</span><br><span class="line">                        this, mWindowManagerService, getSystemActionPerformer(),</span><br><span class="line">                        mA11yWindowManager, mActivityTaskManagerService);</span><br><span class="line">            &#125; else if (userState.mBoundServices.contains(service)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            Slog.i(LOG_TAG, userState.mUserId + &quot;, enable &quot; + componentName);</span><br><span class="line">            service.bindLocked();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (service != null) &#123;</span><br><span class="line">                Slog.i(LOG_TAG, userState.mUserId + &quot;, disable &quot; + componentName);</span><br><span class="line">                service.unbindLocked();</span><br><span class="line">                removeShortcutTargetForUnboundServiceLocked(userState, service);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AccessibilityUserState.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;ComponentName&gt; getCrashedServicesLocked() &#123;</span><br><span class="line">    return mCrashedServices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void serviceDisconnectedLocked(AccessibilityServiceConnection serviceConnection) &#123;</span><br><span class="line">    removeServiceLocked(serviceConnection);</span><br><span class="line">    //和自定义无障碍服务断开，会将自定义无障碍服务添加到mCrashedServices</span><br><span class="line">    mCrashedServices.add(serviceConnection.getComponentName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Remove service from crashed service list if users disable it.</span><br><span class="line"> */</span><br><span class="line">void updateCrashedServicesIfNeededLocked() &#123;</span><br><span class="line">    //遍历所有的无障碍服务</span><br><span class="line">    for (int i = 0, count = mInstalledServices.size(); i &lt; count; i++) &#123;</span><br><span class="line">        final AccessibilityServiceInfo installedService = mInstalledServices.get(i);</span><br><span class="line">        final ComponentName componentName = ComponentName.unflattenFromString(</span><br><span class="line">                installedService.getId());</span><br><span class="line">        //无障碍服务之前异常断开，并且目前也没有启用，就将其从mCrashedServices移除</span><br><span class="line">        if (mCrashedServices.contains(componentName)</span><br><span class="line">                &amp;&amp; !mEnabledServices.contains(componentName)) &#123;</span><br><span class="line">            // Remove it from mCrashedServices since users toggle the switch bar to retry.</span><br><span class="line">            mCrashedServices.remove(componentName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，自定义无障碍服务异常断开后，只需要调用一下禁用，就可以将其从mCrashedServices中移除，再此打开就能正常运行。<br>但实际有一种情况，自定义无障碍服务的进程被force stop：<br>AccessibilityManagerService.java中监听了forceStop的app：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onHandleForceStop(Intent intent, String[] packages,</span><br><span class="line">        int uid, boolean doit) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        final int userId = getChangingUserId();</span><br><span class="line">        // Only the profile parent can install accessibility services.</span><br><span class="line">        // Therefore we ignore packages from linked profiles.</span><br><span class="line">        if (userId != mCurrentUserId) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        final AccessibilityUserState userState = getUserStateLocked(userId);</span><br><span class="line"></span><br><span class="line">        //开始遍历所有启用的自定义无障碍服务</span><br><span class="line">        final Iterator&lt;ComponentName&gt; it = userState.mEnabledServices.iterator();</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            final ComponentName comp = it.next();</span><br><span class="line">            final String compPkg = comp.getPackageName();</span><br><span class="line">            //取出forceStop的包名</span><br><span class="line">            for (String pkg : packages) &#123;</span><br><span class="line">                if (compPkg.equals(pkg)) &#123;</span><br><span class="line">                    if (!doit) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //forceStop的app，会将其从已启用的无障碍服务列表中移除</span><br><span class="line">                    it.remove();</span><br><span class="line">                    userState.getBindingServicesLocked().remove(comp);</span><br><span class="line">                    //并且更新SettingsProvider中的值，此时settingsProvider中的值和本地缓存记录的已启用的无障碍服务列表一致</span><br><span class="line">                    persistComponentNamesToSettingLocked(</span><br><span class="line">                            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,</span><br><span class="line">                            userState.mEnabledServices, userId);</span><br><span class="line">                    onUserStateChangedLocked(userState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>forceStop的app，在无障碍管理服务中进行了处理：从mEnabledServices中移除，更新SettingsProvider中的已启用无障碍服务。</strong></p>
<p><strong>因此，后续手动进行禁用无效，因为settingsprovider中的值和mEnabledServices中一致，数据没有变化</strong></p>
<p>解决方案：只需要让SettingsProvider中的值发生变化，并且mEnabledServices中不包含对应的无障碍服务，就可以清除crash标记</p>
<p>通过handler，连续间隔一定时间（如500ms）切换一次开关状态，直到无障碍服务连接成功</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity启动流程</title>
    <url>/2024/08/28/android_fw/200.Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>启动Activity从startActivity开始,<br>在APP端最终都是调用Instrumentation.execStartActivity来启动Activity,<br>在execStartActivity中去通过ATMS去启动Activity<br>ContextImpl.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void startActivity(Intent intent, Bundle options) &#123;</span><br><span class="line">    //......</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">            getOuterContext(), mMainThread.getApplicationThread(), null,</span><br><span class="line">            (Activity) null, intent, -1, options);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">    //......</span><br><span class="line">    if (options != null) &#123;</span><br><span class="line">        startActivityForResult(intent, -1, options);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Note we want to go through this call for compatibility with</span><br><span class="line">        // applications that may have overridden the method.</span><br><span class="line">        startActivityForResult(intent, -1);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,</span><br><span class="line">        @Nullable Bundle options) &#123;</span><br><span class="line">    //......</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        if (ar != null) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                ar.getResultData());</span><br><span class="line">        &#125;        </span><br><span class="line">    //......</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>Instrumentation.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ActivityResult execStartActivity()&#123;</span><br><span class="line">    //......</span><br><span class="line">    try &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData(who);</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        int result = ActivityTaskManager.getService().startActivity(whoThread,</span><br><span class="line">                who.getBasePackageName(), who.getAttributionTag(), intent,</span><br><span class="line">                intent.resolveTypeIfNeeded(who.getContentResolver()), token,</span><br><span class="line">                target != null ? target.mEmbeddedID : null, requestCode, 0, null, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着就到了ATMS中去startActivity,层层调用会去调用startActivityAsUser,<br>方法内部通过ActivityStarter去启动的Activity</p>
<p>ActivityTaskManagerService.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">        @Nullable String callingFeatureId, Intent intent, String resolvedType,</span><br><span class="line">        IBinder resultTo, String resultWho, int requestCode, int startFlags,</span><br><span class="line">        ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) &#123;</span><br><span class="line">    assertPackageMatchesCallingUid(callingPackage);</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startActivityAsUser&quot;);</span><br><span class="line"></span><br><span class="line">    userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), &quot;startActivityAsUser&quot;);</span><br><span class="line"></span><br><span class="line">    // TODO: Switch to user app stacks here.</span><br><span class="line">    return getActivityStartController().obtainStarter(intent, &quot;startActivityAsUser&quot;)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setCallingFeatureId(callingFeatureId)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setUserId(userId)</span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityStarter.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int execute() &#123;</span><br><span class="line">    try &#123;        </span><br><span class="line">        //......</span><br><span class="line">        //这里会去对inten进行匹配,找对应的Activity,涉及到和PMS的交互</span><br><span class="line">        //找到后会对intent的mComponent赋值</span><br><span class="line">        if (mRequest.activityInfo == null) &#123;</span><br><span class="line">            mRequest.resolveActivity(mSupervisor);</span><br><span class="line">        &#125;</span><br><span class="line">        //......</span><br><span class="line">        synchronized (mService.mGlobalLock) &#123;   </span><br><span class="line">            //......</span><br><span class="line">            //处理Activity跳转请求         </span><br><span class="line">            res = executeRequest(mRequest);  </span><br><span class="line">            //......</span><br><span class="line">        &#125;          </span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int executeRequest(Request request) &#123;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line">    //根据信息创建ActivityRecord保存Activity相关信息</span><br><span class="line">    final ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, callingFeatureId, intent, resolvedType, aInfo,</span><br><span class="line">            mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode,</span><br><span class="line">            request.componentSpecified, voiceSession != null, mSupervisor, checkedOptions,</span><br><span class="line">            sourceRecord);</span><br><span class="line">    //......</span><br><span class="line">    //传入ActivityRecord,准备启动</span><br><span class="line">    mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,</span><br><span class="line">            request.voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask,</span><br><span class="line">            restrictedBgActivity, intentGrants);</span><br><span class="line">    //......        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int startActivityUnchecked()&#123;</span><br><span class="line">    //......</span><br><span class="line">    try &#123;</span><br><span class="line">        mService.deferWindowLayout();</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, &quot;startActivityInner&quot;);</span><br><span class="line">        result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        startedActivityStack = handleStartResult(r, result);</span><br><span class="line">        mService.continueWindowLayout();</span><br><span class="line">    &#125;       </span><br><span class="line">    //......</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">int startActivityInner()&#123;</span><br><span class="line">    //初始化变量，会将传入的参数值赋值到对应的全局变量</span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor, restrictedBgActivity);</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    mIntent.setFlags(mLaunchFlags);</span><br><span class="line">    //这里去获取activity是否有对应可以复用的task</span><br><span class="line">    final Task reusedTask = getReusableTask();</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    //根据复用task来计算目标task</span><br><span class="line">    final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask();</span><br><span class="line">    //目标task为空就需要新创建task</span><br><span class="line">    final boolean newTask = targetTask == null;</span><br><span class="line">    mTargetTask = targetTask;</span><br><span class="line"></span><br><span class="line">    computeLaunchParams(r, sourceRecord, targetTask);</span><br><span class="line"></span><br><span class="line">    // 检查是否允许启动</span><br><span class="line">    int startResult = isAllowedToStart(r, newTask, targetTask);</span><br><span class="line">    if (startResult != START_SUCCESS) &#123;</span><br><span class="line">        return startResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ActivityRecord targetTaskTop = newTask</span><br><span class="line">            ? null : targetTask.getTopNonFinishingActivity();</span><br><span class="line">    if (targetTaskTop != null) &#123;</span><br><span class="line">        // 针对可以复用的task,进行复用.</span><br><span class="line">        startResult = recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);</span><br><span class="line">        if (startResult != START_SUCCESS) &#123;</span><br><span class="line">            return startResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mAddingToTask = true;</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    //新启动的app，没有可复用的task，调用computeTargetTask去获取可用的task</span><br><span class="line">    final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask();</span><br><span class="line">    final boolean newTask = targetTask == null;</span><br><span class="line">    mTargetTask = targetTask;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    //这里实际调用mRootWindowContainer.getLaunchStack</span><br><span class="line">    if (mTargetStack == null) &#123;</span><br><span class="line">        mTargetStack = getLaunchStack(mStartActivity, mLaunchFlags, targetTask, mOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    if (!mAvoidMoveToFront &amp;&amp; mDoResume) &#123;</span><br><span class="line">        //在这里会将stack移到栈顶</span><br><span class="line">        mTargetStack.getStack().moveToFront(&quot;reuseOrNewTask&quot;, targetTask);</span><br><span class="line">        if (mOptions != null) &#123;</span><br><span class="line">            if (mOptions.getTaskAlwaysOnTop()) &#123;</span><br><span class="line">                mTargetStack.setAlwaysOnTop(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!mTargetStack.isTopStackInDisplayArea() &amp;&amp; mService.mInternal.isDreaming()) &#123;</span><br><span class="line">            // Launching underneath dream activity (fullscreen, always-on-top). Run the launch-</span><br><span class="line">            // -behind transition so the Activity gets created and starts in visible state.</span><br><span class="line">            mLaunchTaskBehind = true;</span><br><span class="line">            r.mLaunchTaskBehind = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (newTask) &#123;</span><br><span class="line">        EventLogTags.writeWmCreateTask(mStartActivity.mUserId,</span><br><span class="line">                mStartActivity.getTask().mTaskId);</span><br><span class="line">    &#125;</span><br><span class="line">    mStartActivity.logStartActivity(</span><br><span class="line">            EventLogTags.WM_CREATE_ACTIVITY, mStartActivity.getTask());</span><br><span class="line"></span><br><span class="line">    mTargetStack.mLastPausedActivity = null;</span><br><span class="line"></span><br><span class="line">    mRootWindowContainer.sendPowerHintForLaunchStartIfNeeded(</span><br><span class="line">            false /* forceSend */, mStartActivity);</span><br><span class="line">    //在stack中处理activity的顺序</span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity,</span><br><span class="line">            topStack != null ? topStack.getTopNonFinishingActivity() : null, newTask,</span><br><span class="line">            mKeepCurTransition, mOptions);</span><br><span class="line">    if (mDoResume) &#123;</span><br><span class="line">        final ActivityRecord topTaskActivity =</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        if (!mTargetStack.isTopActivityFocusable()</span><br><span class="line">                || (topTaskActivity != null &amp;&amp; topTaskActivity.isTaskOverlay()</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            // If the activity is not focusable, we can&#x27;t resume it, but still would like to</span><br><span class="line">            // make sure it becomes visible as it starts (this will also trigger entry</span><br><span class="line">            // animation). An example of this are PIP activities.</span><br><span class="line">            // Also, we don&#x27;t want to resume activities in a task that currently has an overlay</span><br><span class="line">            // as the starting activity just needs to be in the visible paused state until the</span><br><span class="line">            // over is removed.</span><br><span class="line">            // Passing &#123;@code null&#125; as the start parameter ensures all activities are made</span><br><span class="line">            // visible.</span><br><span class="line">            mTargetStack.ensureActivitiesVisible(null /* starting */,</span><br><span class="line">                    0 /* configChanges */, !PRESERVE_WINDOWS);</span><br><span class="line">            // Go ahead and tell window manager to execute app transition for this activity</span><br><span class="line">            // since the app transition will not be triggered through the resume channel.</span><br><span class="line">            mTargetStack.getDisplay().mDisplayContent.executeAppTransition();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If the target stack was not previously focusable (previous top running activity</span><br><span class="line">            // on that stack was not visible) then any prior calls to move the stack to the</span><br><span class="line">            // will not update the focused stack.  If starting the new activity now allows the</span><br><span class="line">            // task stack to be focusable, then ensure that we now update the focused stack</span><br><span class="line">            // accordingly.</span><br><span class="line">            if (mTargetStack.isTopActivityFocusable()</span><br><span class="line">                    &amp;&amp; !mRootWindowContainer.isTopDisplayFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(&quot;startActivityInner&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //这里将对应的activity和stack聚焦移到前台</span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities(</span><br><span class="line">                    mTargetStack, mStartActivity, mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mRootWindowContainer.updateUserStack(mStartActivity.mUserId, mTargetStack);</span><br><span class="line"></span><br><span class="line">    // Update the recent tasks list immediately when the activity starts</span><br><span class="line">    mSupervisor.mRecentTasks.add(mStartActivity.getTask());</span><br><span class="line">    mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(),</span><br><span class="line">            mPreferredWindowingMode, mPreferredTaskDisplayArea, mTargetStack);</span><br><span class="line"></span><br><span class="line">    return START_SUCCESS;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>白名单模式</title>
    <url>//pages/01cd0f/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>AppWidgetService</title>
    <url>//pages/fce6de/</url>
    <content><![CDATA[<p><a href="https://developer.android.google.cn/develop/ui/views/appwidgets/overview">https://developer.android.google.cn/develop/ui/views/appwidgets/overview</a></p>
<p>AppWidgetManager<br>IAppWidgetService -&gt; AppWidgetServiceImpl</p>
<p>wiget 的展示获取主要通过 AppWidgetManager 来进行操作。<br>目前比较关键的2个方法：</p>
<ul>
<li>getInstalledProvidersForProfile 根据profileId获取widgetId</li>
<li>bindAppWidgetId                 bind指定profile的widget</li>
</ul>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>SystemServer的startOtherServices中<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/java/com/android/server/SystemServer.java#1758">启动</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final String APPWIDGET_SERVICE_CLASS =</span><br><span class="line">&quot;com.android.server.appwidget.AppWidgetService&quot;;</span><br><span class="line"></span><br><span class="line">if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)</span><br><span class="line">        || context.getResources().getBoolean(R.bool.config_enableAppWidgetService)) &#123;</span><br><span class="line">    t.traceBegin(&quot;StartAppWidgetService&quot;);</span><br><span class="line">    mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);</span><br><span class="line">    t.traceEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AppWidgetService继承自SystemService，主要看onStart()方法,实际就是调用了AppWidgetServiceImpl的onStart()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public AppWidgetService(Context context) &#123;</span><br><span class="line">    super(context);</span><br><span class="line">    mImpl = new AppWidgetServiceImpl(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onStart() &#123;</span><br><span class="line">    mImpl.onStart();</span><br><span class="line">    publishBinderService(Context.APPWIDGET_SERVICE, mImpl);</span><br><span class="line">    AppWidgetBackupBridge.register(mImpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而AppWidgetServiceImpl的onStart()中获取了一些manager保存为成员变量，主要业务是去注册监听了一系列广播</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void onStart() &#123;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    computeMaximumWidgetBitmapMemory();</span><br><span class="line">    registerBroadcastReceiver();</span><br><span class="line">    registerOnCrossProfileProvidersChangedListener();</span><br><span class="line"></span><br><span class="line">    LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在收到广播时，会调用 <code>ensureGroupStateLoadedLocked()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) &#123;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    //主要关注这个方法，加载widget provider</span><br><span class="line">    loadGroupWidgetProvidersLocked(newProfileIds);</span><br><span class="line">    loadGroupStateLocked(newProfileIds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void loadGroupWidgetProvidersLocked(int[] profileIds) &#123;</span><br><span class="line">    List&lt;ResolveInfo&gt; allReceivers = null;</span><br><span class="line">    Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);</span><br><span class="line"></span><br><span class="line">    final int profileCount = profileIds.length;</span><br><span class="line">    for (int i = 0; i &lt; profileCount; i++) &#123;</span><br><span class="line">        final int profileId = profileIds[i];</span><br><span class="line"></span><br><span class="line">        //这里就是取查询action包含ACTION_APPWIDGET_UPDATE的广播</span><br><span class="line">        List&lt;ResolveInfo&gt; receivers = queryIntentReceivers(intent, profileId);</span><br><span class="line">        if (receivers != null &amp;&amp; !receivers.isEmpty()) &#123;</span><br><span class="line">            if (allReceivers == null) &#123;</span><br><span class="line">                allReceivers = new ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            allReceivers.addAll(receivers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int N = (allReceivers == null) ? 0 : allReceivers.size();</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        ResolveInfo receiver = allReceivers.get(i);</span><br><span class="line">        addProviderLocked(receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>另外在调用bindAppWidgetId中，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean bindAppWidgetId(String callingPackage, int appWidgetId,</span><br><span class="line">        int providerProfileId, ComponentName providerComponent, Bundle options) &#123;</span><br><span class="line">    //......      </span><br><span class="line"></span><br><span class="line">        // Send an update now -- We need this update now, and just for this appWidgetId.</span><br><span class="line">        // It&#x27;s less critical when the next one happens, so when we schedule the next one,</span><br><span class="line">        // we add updatePeriodMillis to its start time. That time will have some slop,</span><br><span class="line">        // but that&#x27;s okay.</span><br><span class="line">        //这里发送ACTION_APPWIDGET_UPDATE广播</span><br><span class="line">        sendUpdateIntentLocked(provider, new int[] &#123;appWidgetId&#125;);</span><br><span class="line"></span><br><span class="line">        // Schedule the future updates.</span><br><span class="line">        //这里是根据updatePeriodMillis来定时发送更新广播</span><br><span class="line">        registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets));</span><br><span class="line"></span><br><span class="line">        saveGroupStateAsync(userId);</span><br><span class="line"></span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;Bound widget &quot; + appWidgetId + &quot; to provider &quot; + provider.id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void registerForBroadcastsLocked(Provider provider, int[] appWidgetIds) &#123;</span><br><span class="line">    if (provider.info.updatePeriodMillis &gt; 0) &#123;</span><br><span class="line">        // if this is the first instance, set the alarm. otherwise,</span><br><span class="line">        // rely on the fact that we&#x27;ve already set it and that</span><br><span class="line">        // PendingIntent.getBroadcast will update the extras.</span><br><span class="line">        boolean alreadyRegistered = provider.broadcast != null;</span><br><span class="line">        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);</span><br><span class="line">        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);</span><br><span class="line">        intent.setComponent(provider.info.provider);</span><br><span class="line">        long token = Binder.clearCallingIdentity();</span><br><span class="line">        try &#123;</span><br><span class="line">            provider.broadcast = PendingIntent.getBroadcastAsUser(mContext, 1, intent,</span><br><span class="line">                    PendingIntent.FLAG_UPDATE_CURRENT, provider.info.getProfile());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!alreadyRegistered) &#123;</span><br><span class="line">            // Set the alarm outside of our locks; we&#x27;ve latched the first-time</span><br><span class="line">            // invariant and established the PendingIntent safely.</span><br><span class="line">            final long period = Math.max(provider.info.updatePeriodMillis, MIN_UPDATE_PERIOD);</span><br><span class="line">            final PendingIntent broadcast = provider.broadcast;</span><br><span class="line">            mSaveStateHandler.post(() -&gt;</span><br><span class="line">                //通过AlarmManager来定时发送广播，setInexactRepeating时间并不精确，不保证到时间一定会执行</span><br><span class="line">                mAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,</span><br><span class="line">                        SystemClock.elapsedRealtime() + period, period, broadcast)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="widget的更新"><a href="#widget的更新" class="headerlink" title="widget的更新"></a>widget的更新</h2><p>调用AppWidgetManager中的updateAppWidget()，内部会去调用AppWidgetServiceImpl的updateAppWidgetProvider()</p>
<p>会去读取缓存数据 &#x2F;data&#x2F;system&#x2F;users&#x2F;10&#x2F;appwidgets.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AppWidgetId&#123;6:Host&#123;HostId&#123;user:0, app:1000, hostId:1001, pkg:com.android.systemui&#125;&#125;:Provider&#123;ProviderId&#123;user:10, app:1000, cmp:ComponentInfo&#123;com.wt.scene/com.wt.scene.systemui.widget.ScenesWidgetProvider&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Widget主要包含appWidgetId，host，provider<br>    host中主要有hostid，uid，和pkg<br>    provider是只appwidget，保存的是app端的widget信息，提供appwidget的进程的uid(通过uid计算出userid，appid）和component</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>DreamManagerService</title>
    <url>//pages/753ec4/</url>
    <content><![CDATA[<h2 id="DreamManagerService"><a href="#DreamManagerService" class="headerlink" title="DreamManagerService"></a>DreamManagerService</h2><p>DreamManagerService是处理屏保的系统服务</p>
<h2 id="涉及到的几个类"><a href="#涉及到的几个类" class="headerlink" title="涉及到的几个类"></a>涉及到的几个类</h2><table>
<thead>
<tr>
<th>类名</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/dreams/DreamController.java">DreamManagerService</a></td>
<td>屏保服务的实现类</td>
</tr>
<tr>
<td><a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java#121">PowerManagerService</a></td>
<td>和DreamManagerService有部分交互</td>
</tr>
<tr>
<td><a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/dreams/DreamController.java">DreamController</a></td>
<td>控制屏保服务的具业务操作类</td>
</tr>
<tr>
<td><a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/core/java/android/service/dreams/DreamService.java#61">DreamService</a></td>
<td>Service的子类，自定义的屏保需要继承自它</td>
</tr>
<tr>
<td><a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/core/java/android/service/dreams/DreamActivity.java">DreamActivity</a></td>
<td>屏保展示页</td>
</tr>
</tbody></table>
<h2 id="DreamManagerService启动流程"><a href="#DreamManagerService启动流程" class="headerlink" title="DreamManagerService启动流程"></a>DreamManagerService启动流程</h2><p>DreamManagerService是继承自SystemService，那么一般就是在SystemServer中启动的(SystemService由SystemServiceManager管理，SystemServiceManager是在SystemServer中初始化的）</p>
<p>DreamManagerService是在SystemServer中的startOtherServices中<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/java/com/android/server/SystemServer.java#1858">启动</a>的</p>
<p>启动时将IDreamManager的实例对象加入到了ServiceManager，服务名称<code>dreams</code></p>
<h2 id="触发屏保"><a href="#触发屏保" class="headerlink" title="触发屏保"></a>触发屏保</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram

% 调用DreamManagerService的dream方法 %
note over DreamManagerService:dream()
note over DreamManagerService:requestDreamInternal()
DreamManagerService-&gt;&gt;PowerManagerService:nap()
PowerManagerService-&gt;&gt;DreamManagerService:startDream() 
DreamManagerService-&gt;&gt;DreamController:startDream()
DreamController-&gt;&gt;DreamService:bindServiceAsUser()

DreamService--&gt;&gt;DreamController:返回DreamServiceWrapper对象
DreamController-&gt;&gt;DreamService:attach()
note over DreamService:ActivityTaskManager.getService().startDreamActivity()
  </pre></div>

<ol>
<li>调用DreamManagerService的dream()，进入requestDreamInternal()方法，内部去调用PowerManagerService的nap()方法</li>
<li>在PowerManagerService的napInternal方法中调用updatePowerStateLocked()更新电源状态，<br>一系列逻辑处理后，主要在updateDreamLocked()中发送消息到内部Handler，执行handleSandman()方法，在handleSandman中又调用DreamManagerService的startDream()。</li>
<li>回到DreamManagerService的startDream()，实际调用了DreamController的startDream()。</li>
<li>在DreamController中bind了DreamService，在onServiceConnected中调用了DreamService中实现的attach，attach中去ActivityTaskManagerService的startDreamActivity()去启动DreamActivity,并通过intent传递了binder对象</li>
<li>在DreamActivity的onCreate()方法中取到了DreamService的binder对象(DreamServiceWrapper)，回调DreamService的binder中实现的onActivityCreated，在DreamService中保存了Activity信息</li>
</ol>
<h2 id="结束屏保"><a href="#结束屏保" class="headerlink" title="结束屏保"></a>结束屏保</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram

note over DreamManagerService:awaken()
note over DreamManagerService:requestAwakenInternal()
note over DreamManagerService:stopDreamLocked(false &#x2F;*immediate*&#x2F;, &quot;request awaken&quot;)
DreamManagerService-&gt;&gt;DreamController:stopDream()
note over DreamManagerService,DreamController:immediate &#x3D; false
DreamController-&gt;&gt;DreamService:wakeUp()
note over DreamService:onWakeUp()
DreamService--&gt;&gt;DreamService:finish()
note over DreamService:finish()中调用activity.finishAndRemoveTask()，关闭屏保页
DreamService-&gt;&gt;DreamManagerService:finishSelf()
note over DreamManagerService:stopDreamLocked(true &#x2F;*immediate*&#x2F;, &quot;finished self&quot;)
DreamManagerService-&gt;&gt;DreamController:stopDream()
note over DreamManagerService,DreamController:immediate &#x3D; true
DreamController-&gt;&gt;DreamService:detach()
DreamController-&gt;&gt;DreamService:unbindService()

  </pre></div>

<ol>
<li>调用DreamManagerService的awaken()，进入requestAwakenInternal()方法，最终调用的stopDreamLocked(false &#x2F;<em>immediate</em>&#x2F;, “request awaken”)方法</li>
<li>stopDreamLocked()中去调用DreamController的stopDream()方法</li>
<li>当stopDream()入参的immediate为false时，调用的是DreamService中的wakeUp()方法，触发onWakeUp()-&gt;finish()</li>
<li>在finish()中取到之前保存的DreamActivity,调用activity.finishAndRemoveTask()，关闭屏保页</li>
<li>然后调用DreamManagerService的finishSelf(mDreamToken, true &#x2F;<em>immediate</em>&#x2F;)，会再走一次stopDreamLocked()，<br> 去清除DreamManagerService中保存的相关数据，然后进入DreamController的stopDream()方法</li>
<li>当stopDream()入参的immediate为true时，调用的是DreamService中的detach()</li>
<li>最后DreamController执行unbind DreamService。</li>
</ol>
<p>注：<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java#1277">DreamActivity的ActivityType是ACTIVITY_TYPE_DREAM</a> </p>
<p>isValidLaunchStack</p>
<h2 id="记录一次屏保无法退出的现象"><a href="#记录一次屏保无法退出的现象" class="headerlink" title="记录一次屏保无法退出的现象"></a>记录一次屏保无法退出的现象</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>进入屏保页后，点击屏保无响应，无法退出，无法回到桌面，通过adb直接下发指令启动Activity也无法成功（stack 不在栈顶，在栈顶下面一层）</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>后面发现DreamActivity的ActivityType是ACTIVITY_TYPE_DREAM，普通APP的ActivityType是ACTIVITY_TYPE_STANDARD，<br>由于要启动的Activity的栈和顶层栈的类型不同，所以无法打开。</p>
<p>但是DreamService中实现了Window.Callback，并将DreamActivity的Window.Callback设置成了DreamService，<br>而DreamService实现的Window.Callback,对dispatchTouchEvent做了处理，会去调用wakeUp()退出屏保，所以正常情况下，触摸屏幕就会退出屏保。</p>
<p>最后发现有其他进程在打开屏保时，刚好去唤醒屏幕，将DreamService中的mFinished标志置为了true，<br>后续屏保页成功显示后，由于mFinished已经置为true，执行解锁时无法进入解锁逻辑。屏保一直无法退出。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>DreamService中添加字段mActivityCreated记录屏保页是否成功启动，未启动前不执行解锁操作</p>
<p>具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//flag add by LiFeifei to check DreamActivity is created</span><br><span class="line">private boolean mActivityCreated = false;</span><br><span class="line"></span><br><span class="line">public final void finish() &#123;</span><br><span class="line">    if (mDebug) Slog.v(TAG, &quot;finish(): mFinished=&quot; + mFinished);</span><br><span class="line"></span><br><span class="line">    // add by LiFeifei START (if DreamActivity haven&#x27;t created,ignore finish)</span><br><span class="line">    Slog.d(TAG,&quot;finish activity=&quot; + mActivity);</span><br><span class="line">    if (!mActivityCreated) &#123;</span><br><span class="line">        Slog.d(TAG,&quot;activity not created yet, abort finish.&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // add by Lifeifei END</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /** @hide */</span><br><span class="line">    void onActivityCreated(DreamActivity a) &#123;</span><br><span class="line">        mActivity = a;</span><br><span class="line">        onWindowCreated(a.getWindow());</span><br><span class="line"></span><br><span class="line">        //add by Lifeifei START, mark DreamActivity create success</span><br><span class="line">        Slog.d(TAG,&quot;onActivityCreated&quot;);</span><br><span class="line">        mActivityCreated = true;</span><br><span class="line">        //add by Lifeifei END</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>UserController</title>
    <url>//pages/e58274/</url>
    <content><![CDATA[<p>finishUserUnlocked<br>    发送了Intent.ACTION_USER_UNLOCKED 广播 通知 用户unlocked<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Dispatch unlocked to external apps</span><br><span class="line">final Intent unlockedIntent = new Intent(Intent.ACTION_USER_UNLOCKED);</span><br><span class="line">unlockedIntent.putExtra(Intent.EXTRA_USER_HANDLE, userId);</span><br><span class="line">unlockedIntent.addFlags(</span><br><span class="line">        Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">mInjector.broadcastIntent(unlockedIntent, null, null, 0, null,</span><br><span class="line">        null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, SYSTEM_UID,</span><br><span class="line">        Binder.getCallingUid(), Binder.getCallingPid(), userId);</span><br></pre></td></tr></table></figure><br>finishUserUnlockedCompleted</p>
<pre><code>通过SystemServiceManager去遍历所有SystemService，回调onUserUnlocked
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mHandler.obtainMessage(USER_UNLOCKED_MSG, userId, 0).sendToTarget();</span><br></pre></td></tr></table></figure>
然后会发送BOOT_COMPLETED广播（有序广播）
</code></pre>
<p>mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, null);<br>UserManager.isUserUnlocked</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>AdbService</title>
    <url>/2024/12/25/android_fw/26.AdbService/</url>
    <content><![CDATA[<h2 id="AdbService启动流程"><a href="#AdbService启动流程" class="headerlink" title="AdbService启动流程"></a>AdbService启动流程</h2><p>在systemServer的startOtherServices中启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final String ADB_SERVICE_CLASS =</span><br><span class="line">        &quot;com.android.server.adb.AdbService$Lifecycle&quot;;</span><br><span class="line"></span><br><span class="line">        // Start ADB Debugging Service</span><br><span class="line">        t.traceBegin(&quot;StartAdbService&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            mSystemServiceManager.startService(ADB_SERVICE_CLASS);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            Slog.e(TAG, &quot;Failure starting AdbService&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        t.traceEnd();</span><br></pre></td></tr></table></figure>
<p>启动时初始化了AdbService，添加了一个binder服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void onStart() &#123;</span><br><span class="line">    mAdbService = new AdbService(getContext());</span><br><span class="line">    publishBinderService(Context.ADB_SERVICE, mAdbService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AdbService的初始化"><a href="#AdbService的初始化" class="headerlink" title="AdbService的初始化"></a>AdbService的初始化</h2><p>主要就是监听了一下Setting Provider中的Global中的adb_enabled和adb_wifi_enabled这2个值的变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private AdbService(Context context) &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mContentResolver = context.getContentResolver();</span><br><span class="line">    mDebuggingManager = new AdbDebuggingManager(context);</span><br><span class="line"></span><br><span class="line">    initAdbState();</span><br><span class="line">    LocalServices.addService(AdbManagerInternal.class, new AdbManagerInternalImpl());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void initAdbState() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Use the normal bootmode persistent prop to maintain state of adb across</span><br><span class="line">         * all boot modes.</span><br><span class="line">         */</span><br><span class="line">        mIsAdbUsbEnabled = containsFunction(</span><br><span class="line">                SystemProperties.get(USB_PERSISTENT_CONFIG_PROPERTY, &quot;&quot;),</span><br><span class="line">                UsbManager.USB_FUNCTION_ADB);</span><br><span class="line">        mIsAdbWifiEnabled = &quot;1&quot;.equals(</span><br><span class="line">                SystemProperties.get(WIFI_PERSISTENT_CONFIG_PROPERTY, &quot;0&quot;));</span><br><span class="line"></span><br><span class="line">        // register observer to listen for settings changes</span><br><span class="line">        mObserver = new AdbSettingsObserver();</span><br><span class="line">        mContentResolver.registerContentObserver(</span><br><span class="line">                Settings.Global.getUriFor(Settings.Global.ADB_ENABLED),</span><br><span class="line">                false, mObserver);</span><br><span class="line">        mContentResolver.registerContentObserver(</span><br><span class="line">                Settings.Global.getUriFor(Settings.Global.ADB_WIFI_ENABLED),</span><br><span class="line">                false, mObserver);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        Slog.e(TAG, &quot;Error in initAdbState&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>看看在AdbSettingsObserver中监听到值变化做的事情,就是根据值去调用setAdbEnabled方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void onChange(boolean selfChange, @NonNull Uri uri, @UserIdInt int userId) &#123;</span><br><span class="line">    if (mAdbUsbUri.equals(uri)) &#123;</span><br><span class="line">        boolean shouldEnable = (Settings.Global.getInt(mContentResolver,</span><br><span class="line">                Settings.Global.ADB_ENABLED, 0) &gt; 0);</span><br><span class="line">        FgThread.getHandler().sendMessage(obtainMessage(</span><br><span class="line">                AdbService::setAdbEnabled, AdbService.this, shouldEnable,</span><br><span class="line">                    AdbTransportType.USB));</span><br><span class="line">    &#125; else if (mAdbWifiUri.equals(uri)) &#123;</span><br><span class="line">        boolean shouldEnable = (Settings.Global.getInt(mContentResolver,</span><br><span class="line">                Settings.Global.ADB_WIFI_ENABLED, 0) &gt; 0);</span><br><span class="line">        FgThread.getHandler().sendMessage(obtainMessage(</span><br><span class="line">                AdbService::setAdbEnabled, AdbService.this, shouldEnable,</span><br><span class="line">                    AdbTransportType.WIFI));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void setAdbEnabled(boolean enable, byte transportType) &#123;</span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, &quot;setAdbEnabled(&quot; + enable + &quot;), mIsAdbUsbEnabled=&quot; + mIsAdbUsbEnabled</span><br><span class="line">                + &quot;, mIsAdbWifiEnabled=&quot; + mIsAdbWifiEnabled + &quot;, transportType=&quot;</span><br><span class="line">                    + transportType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (transportType == AdbTransportType.USB &amp;&amp; enable != mIsAdbUsbEnabled) &#123;</span><br><span class="line">        mIsAdbUsbEnabled = enable;</span><br><span class="line">    &#125; else if (transportType == AdbTransportType.WIFI &amp;&amp; enable != mIsAdbWifiEnabled) &#123;</span><br><span class="line">        mIsAdbWifiEnabled = enable;</span><br><span class="line">        if (mIsAdbWifiEnabled) &#123;</span><br><span class="line">            if (!AdbProperties.secure().orElse(false) &amp;&amp; mDebuggingManager == null) &#123;</span><br><span class="line">                // Start adbd. If this is secure adb, then we defer enabling adb over WiFi.</span><br><span class="line">                SystemProperties.set(WIFI_PERSISTENT_CONFIG_PROPERTY, &quot;1&quot;);</span><br><span class="line">                mConnectionPortPoller =</span><br><span class="line">                        new AdbDebuggingManager.AdbConnectionPortPoller(mPortListener);</span><br><span class="line">                mConnectionPortPoller.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Stop adb over WiFi.</span><br><span class="line">            SystemProperties.set(WIFI_PERSISTENT_CONFIG_PROPERTY, &quot;0&quot;);</span><br><span class="line">            if (mConnectionPortPoller != null) &#123;</span><br><span class="line">                mConnectionPortPoller.cancelAndWait();</span><br><span class="line">                mConnectionPortPoller = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // No change</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (enable) &#123;</span><br><span class="line">        //通过ctl属性去启动adbd进程</span><br><span class="line">        startAdbd();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //通过ctl属性去停止adbd进程</span><br><span class="line">        stopAdbd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (IAdbTransport transport : mTransports.values()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            transport.onAdbEnabled(enable, transportType);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Unable to send onAdbEnabled to transport &quot; + transport.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mDebuggingManager != null) &#123;</span><br><span class="line">        mDebuggingManager.setAdbEnabled(enable, transportType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>获取前台APP</title>
    <url>//pages/d17832/</url>
    <content><![CDATA[<p>获取前台APP</p>
<h2 id="方法一：AMS的getFocusedStackInfo"><a href="#方法一：AMS的getFocusedStackInfo" class="headerlink" title="方法一：AMS的getFocusedStackInfo()"></a>方法一：AMS的getFocusedStackInfo()</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ol>
<li>需要系统签名</li>
</ol>
<p><strong>如果不满足前提条件，反射获取getFocusedStackInfo方法会失败。</strong></p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String getForegroundAPPWay1() &#123;</span><br><span class="line">    Log.d(TAG, &quot;getForegroundAPPWay1&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取ActivityManager的getService方法</span><br><span class="line">        Method getService = ActivityManager.class.getDeclaredMethod(&quot;getService&quot;);</span><br><span class="line">        //调用ActivityManager的getService方法获取AMS</span><br><span class="line">        IActivityManager activityManagerService = (IActivityManager) getService.invoke(null);</span><br><span class="line">        if (activityManagerService == null) &#123;</span><br><span class="line">            Log.d(TAG, &quot;AMS is null&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //通过AMS获取stackInfo实例</span><br><span class="line">        Object focusedStackInfo = activityManagerService.getFocusedStackInfo();</span><br><span class="line">        //获取stackInfo类</span><br><span class="line">        Class&lt;?&gt; stackInfoClass = Class.forName(&quot;android.app.ActivityManager$StackInfo&quot;);</span><br><span class="line">        Field visible = stackInfoClass.getDeclaredField(&quot;visible&quot;);</span><br><span class="line">        boolean isVisible = (boolean) visible.get(focusedStackInfo);</span><br><span class="line">        if (isVisible) &#123;</span><br><span class="line">            Field topActivityFiled = stackInfoClass.getDeclaredField(&quot;topActivity&quot;);</span><br><span class="line">            ComponentName topActivity = (ComponentName) topActivityFiled.get(focusedStackInfo);</span><br><span class="line">            if (topActivity == null) &#123;</span><br><span class="line">                Log.d(TAG, &quot;topActivity is null&quot;);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return topActivity.getPackageName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (ClassNotFoundException | RemoteException | NoSuchFieldException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：ActivityManager的getRunningAppProcesses"><a href="#方法二：ActivityManager的getRunningAppProcesses" class="headerlink" title="方法二：ActivityManager的getRunningAppProcesses()"></a>方法二：ActivityManager的getRunningAppProcesses()</h2><h3 id="前提条件-1"><a href="#前提条件-1" class="headerlink" title="前提条件"></a>前提条件</h3><ol>
<li>需要系统签名</li>
<li>需要指定sharedUserId <code>android:sharedUserId=&quot;android.uid.system&quot;</code></li>
</ol>
<p><strong>如果不满足前提条件获取到的RunningAppProcessInfo只有自己的进程。</strong></p>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String getForegroundAPPWay1() &#123;</span><br><span class="line">    Log.d(TAG, &quot;getForegroundAPPWay1&quot;);</span><br><span class="line">    String fgProcess = &quot;&quot;;</span><br><span class="line">    ActivityManager activityManager = getSystemService(ActivityManager.class);</span><br><span class="line">    List&lt;ActivityManager.RunningAppProcessInfo&gt; runningAppProcesses = activityManager.getRunningAppProcesses();</span><br><span class="line">    for (ActivityManager.RunningAppProcessInfo runningAppProcess : runningAppProcesses) &#123;</span><br><span class="line">        boolean isFocused = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取RunningAppProcessInfo的isFocused字段</span><br><span class="line">            Field focused = ActivityManager.RunningAppProcessInfo.class.getDeclaredField(&quot;isFocused&quot;);</span><br><span class="line">            focused.setAccessible(true);</span><br><span class="line">            isFocused = (boolean) focused.get(runningAppProcess);</span><br><span class="line">            if (isFocused) &#123;</span><br><span class="line">                fgProcess = runningAppProcess.processName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return fgProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Widget之AppWidgetHost</title>
    <url>//pages/62cb3b/</url>
    <content><![CDATA[<h2 id="AppWidgetHost"><a href="#AppWidgetHost" class="headerlink" title="AppWidgetHost"></a>AppWidgetHost</h2><p>AppWidgetHost就是用来提供与widget的交互的类。</p>
<h2 id="关键类和名词"><a href="#关键类和名词" class="headerlink" title="关键类和名词"></a>关键类和名词</h2><table>
<thead>
<tr>
<th>名词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AppWidgetHost</td>
<td>用来提供与widget的交互的类，AppWidgetHost必须有一个唯一ID。</td>
</tr>
<tr>
<td>App widget ID</td>
<td>每个小部件实例在绑定时被分配一个唯一的ID(参见bindAppWidgetIdIfAllowed()，唯一ID由host通过allocateAppWidgetId()获取。这个ID在小部件的整个生命周期内都是持久化的，也就是说，直到从host上删除它为止。任何特定状态(比如小部件的大小和位置)都应该由host所在的进程持久化，并与应用程序小部件ID相关联。</td>
</tr>
<tr>
<td>App widget host view</td>
<td>可以将AppWidgetHostView看作一个容器，每当需要显示小部件时，小部件就被包装在这个容器中。每次host对小部件进行绘制时，小部件都会与AppWidgetHostView关联</td>
</tr>
<tr>
<td>Options bundle</td>
<td>AppWidgetHost使用Options bundle向AppWidgetProvider传递关于小部件如何显示的信息(例如，大小范围列表，以及小部件是在锁屏还是主屏上)。这些信息允许AppWidgetProvider根据小部件的显示方式和位置来定制小部件的内容和外观。您可以使用updateAppWidgetOptions()和updateAppWidgetSize()来修改widget的选项。这两个方法都会触发AppWidgetProvider的onAppWidgetOptionsChanged()回调</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Toast</title>
    <url>//pages/4b117f/</url>
    <content><![CDATA[<h2 id="Toast流程"><a href="#Toast流程" class="headerlink" title="Toast流程"></a>Toast流程</h2><p>常用<code>Toast.makeText(this, &quot;test&quot;, Toast.LENGTH_SHORT).show();</code><br>主要就看makeText和show方法</p>
<h3 id="makeText"><a href="#makeText" class="headerlink" title="makeText"></a>makeText</h3><p>makeText实际会去构造一个内部类TN对象，TN内部持有一个ToastPresenter对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Toast makeText(@NonNull Context context, @Nullable Looper looper,</span><br><span class="line">        @NonNull CharSequence text, @Duration int duration) &#123;</span><br><span class="line">    //android Q之后的</span><br><span class="line">    if (Compatibility.isChangeEnabled(CHANGE_TEXT_TOASTS_IN_THE_SYSTEM)) &#123;</span><br><span class="line">        Toast result = new Toast(context, looper);</span><br><span class="line">        result.mText = text;</span><br><span class="line">        result.mDuration = duration;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Toast result = new Toast(context, looper);</span><br><span class="line">        View v = ToastPresenter.getTextToastView(context, text);</span><br><span class="line">        result.mNextView = v;</span><br><span class="line">        result.mDuration = duration;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Toast(@NonNull Context context, @Nullable Looper looper) &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mToken = new Binder();</span><br><span class="line">    looper = getLooper(looper);</span><br><span class="line">    mHandler = new Handler(looper);</span><br><span class="line">    mCallbacks = new ArrayList&lt;&gt;();</span><br><span class="line">    mTN = new TN(context, context.getPackageName(), mToken,</span><br><span class="line">            mCallbacks, looper);</span><br><span class="line">    mTN.mY = context.getResources().getDimensionPixelSize(</span><br><span class="line">            com.android.internal.R.dimen.toast_y_offset);</span><br><span class="line">    mTN.mGravity = context.getResources().getInteger(</span><br><span class="line">            com.android.internal.R.integer.config_toastDefaultGravity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    TN(Context context, String packageName, Binder token, List&lt;Callback&gt; callbacks,</span><br><span class="line">            @Nullable Looper looper) &#123;</span><br><span class="line">        IAccessibilityManager accessibilityManager = IAccessibilityManager.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(Context.ACCESSIBILITY_SERVICE));</span><br><span class="line">        mPresenter = new ToastPresenter(context, accessibilityManager, getService(),</span><br><span class="line">                packageName);</span><br><span class="line">        mParams = mPresenter.getLayoutParams();</span><br><span class="line">        mPackageName = packageName;</span><br><span class="line">        mToken = token;</span><br><span class="line">        mCallbacks = callbacks;</span><br><span class="line"></span><br><span class="line">        mHandler = new Handler(looper, null) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                switch (msg.what) &#123;</span><br><span class="line">                    case SHOW: &#123;</span><br><span class="line">                        IBinder token = (IBinder) msg.obj;</span><br><span class="line">                        handleShow(token);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    case HIDE: &#123;</span><br><span class="line">                        handleHide();</span><br><span class="line">                        // Don&#x27;t do this in handleHide() because it is also invoked by</span><br><span class="line">                        // handleShow()</span><br><span class="line">                        mNextView = null;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    case CANCEL: &#123;</span><br><span class="line">                        handleHide();</span><br><span class="line">                        // Don&#x27;t do this in handleHide() because it is also invoked by</span><br><span class="line">                        // handleShow()</span><br><span class="line">                        mNextView = null;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            getService().cancelToast(mPackageName, mToken);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="show"><a href="#show" class="headerlink" title="show"></a>show</h3><p>调用show的时候实际是去调用systemserver中的NotificationManagerService的enqueueToast：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void show() &#123;</span><br><span class="line">    if (Compatibility.isChangeEnabled(CHANGE_TEXT_TOASTS_IN_THE_SYSTEM)) &#123;</span><br><span class="line">        checkState(mNextView != null || mText != null, &quot;You must either set a text or a view&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mNextView == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;setView must have been called&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INotificationManager service = getService();</span><br><span class="line">    String pkg = mContext.getOpPackageName();</span><br><span class="line">    TN tn = mTN;</span><br><span class="line">    tn.mNextView = mNextView;</span><br><span class="line">    final int displayId = mContext.getDisplayId();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (Compatibility.isChangeEnabled(CHANGE_TEXT_TOASTS_IN_THE_SYSTEM)) &#123;</span><br><span class="line">            if (mNextView != null) &#123;</span><br><span class="line">                // It&#x27;s a custom toast</span><br><span class="line">                service.enqueueToast(pkg, mToken, tn, mDuration, displayId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // It&#x27;s a text toast</span><br><span class="line">                ITransientNotificationCallback callback =</span><br><span class="line">                        new CallbackBinder(mCallbacks, mHandler);</span><br><span class="line">                service.enqueueTextToast(pkg, mToken, mText, mDuration, displayId, callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            service.enqueueToast(pkg, mToken, tn, mDuration, displayId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        // Empty</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NotificationManagerService"><a href="#NotificationManagerService" class="headerlink" title="NotificationManagerService"></a>NotificationManagerService</h2><p>在NotificationManagerService的enqueueToast中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    private void enqueueToast(String pkg, IBinder token, @Nullable CharSequence text,</span><br><span class="line">            @Nullable ITransientNotification callback, int duration, int displayId,</span><br><span class="line">            @Nullable ITransientNotificationCallback textCallback) &#123;                     </span><br><span class="line">                &#123;    //......</span><br><span class="line">                    Binder windowToken = new Binder();</span><br><span class="line">                    mWindowManagerInternal.addWindowToken(windowToken, TYPE_TOAST, displayId);</span><br><span class="line">                    record = getToastRecord(callingUid, callingPid, pkg, token, text, callback,</span><br><span class="line">                            duration, windowToken, displayId, textCallback);</span><br><span class="line">                    mToastQueue.add(record);</span><br><span class="line">                    //.....</span><br><span class="line">                &#125;</span><br><span class="line">                if (index == 0) &#123;</span><br><span class="line">                    showNextToastLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">void showNextToastLocked() &#123;</span><br><span class="line">    ToastRecord record = mToastQueue.get(0);</span><br><span class="line">    while (record != null) &#123;</span><br><span class="line">        if (record.show()) &#123;</span><br><span class="line">            scheduleDurationReachedLocked(record);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int index = mToastQueue.indexOf(record);</span><br><span class="line">        if (index &gt;= 0) &#123;</span><br><span class="line">            mToastQueue.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        record = (mToastQueue.size() &gt; 0) ? mToastQueue.get(0) : null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Handler</title>
    <url>//pages/99f85c/</url>
    <content><![CDATA[<h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>一个线程中一个Looper，一个Looper持有一个MessageQueue.</p>
<p>在创建Handler时，指定关联的Looper，<br>handler在sendMessage时，会调用对应Looper中的MessageQueue的<code>enqueueMessage()</code>将消息插入到队列</p>
<p>Looper会循环调用MessageQueue的<code>next()</code>取消息，再通过调用msg对应handler的<code>dispatchMessage()</code>，<br>将msg交给handler处理。</p>
<h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>Looper的源码并不多，主要逻辑在<code>loop()</code>方法中，<br>主要逻辑就是在当前线程中开启循环，不停的从Looper的MessageQueue中取消息处理。<br>所以调用loop()后，loop后面的代码只有等到Looper退出才能执行。</p>
<p>Looper的用法就是调用静态方法: <code>Looper.prepare()</code> 和 <code>Looper.loop()</code><br>prepare就是初始化Looper:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    //构造一个MessageQueue</span><br><span class="line">    mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>loop方法就是开始循环从MessageQueue中取消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">    //......</span><br><span class="line">    //开始死循环取消息处理</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //从MessageQueue中取消息</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">        final Printer logging = me.mLogging;</span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        // Make sure the observer won&#x27;t change while processing a transaction.</span><br><span class="line">        final Observer observer = sObserver;</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //调用msg对应的handler的dispatchMessage</span><br><span class="line">            //msg的target是在handler enqueueMessage时，将hander赋值给target</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            if (observer != null) &#123;</span><br><span class="line">                observer.messageDispatched(token, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">        &#125; catch (Exception exception) &#123;</span><br><span class="line">            if (observer != null) &#123;</span><br><span class="line">                observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">            &#125;</span><br><span class="line">            throw exception;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">            if (traceTag != 0) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure that during the course of dispatching the</span><br><span class="line">        // identity of the thread wasn&#x27;t corrupted.</span><br><span class="line">        final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        if (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                    + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                    + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                    + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>MessageQueue是在Looper初始化的时候创建的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要关注的方法就 <code>next()</code> 和 <code>enqueueMessage()</code>,<br>next()是取数据，enqueueMessage是向队列中添加消息<br>默认的消息都是同步消息，异步消息需要通过调用Message的setAsynchronous来设置</p>
<p>看看next取消息的逻辑，就是从队列中取消息，遇到同步消息屏障时，不取同步消息，取消息屏障后的第一个异步消息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">    // Return here if the message loop has already quit and been disposed.</span><br><span class="line">    // This can happen if the application tries to restart a looper after quit</span><br><span class="line">    // which is not supported.</span><br><span class="line">    final long ptr = mPtr;</span><br><span class="line">    if (ptr == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">    int nextPollTimeoutMillis = 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果 nextPollTimeoutMillis = -1，一直阻塞不会超时。</span><br><span class="line">        // 如果 nextPollTimeoutMillis = 0，不会阻塞，立即返回。</span><br><span class="line">        // 如果 nextPollTimeoutMillis &gt; 0，最长阻塞nextPollTimeoutMillis毫秒(超时)，如果期间有程序唤醒会立即返回。</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // Try to retrieve the next message.  Return if found.</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = null;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            //这里是判断当前的消息是否是同步消息屏障</span><br><span class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                //遇到同步消息屏障，就遍历找到屏障后的第一个异步消息</span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            if (msg != null) &#123;</span><br><span class="line">                //取到待处理的消息</span><br><span class="line">                //没到处理时间，计算一下时间，再去取消息</span><br><span class="line">                if (now &lt; msg.when) &#123;</span><br><span class="line">                    // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //处理时间满足</span><br><span class="line">                    // Got a message.</span><br><span class="line">                    mBlocked = false;</span><br><span class="line">                    if (prevMsg != null) &#123;</span><br><span class="line">                        //将前一个消息指向当前消息的下一个（将当前消息从队列移除）</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //当前消息就是队列的头部，直接将列头指向下一个消息 （将当前消息从队列移除）</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = null;</span><br><span class="line">                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    return msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // No more messages.</span><br><span class="line">                nextPollTimeoutMillis = -1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Process the quit message now that all pending messages have been handled.</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If first time idle, then get the number of idlers to run.</span><br><span class="line">            // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">            // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">            if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                mBlocked = true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Run the idle handlers.</span><br><span class="line">        // We only ever reach this code block during the first iteration.</span><br><span class="line">        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">            boolean keep = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!keep) &#123;</span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">        pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">        // While calling an idle handler, a new message could have been delivered</span><br><span class="line">        // so go back and look again for a pending message without waiting.</span><br><span class="line">        nextPollTimeoutMillis = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步消息屏障,目的就是阻止同步消息的触发，就是插入了一条target为null的消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int postSyncBarrier(long when) &#123;</span><br><span class="line">    // Enqueue a new sync barrier token.</span><br><span class="line">    // We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        final int token = mNextBarrierToken++;</span><br><span class="line">        final Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = null;</span><br><span class="line">        //将队列头部的消息赋值给临时变量p</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        //消息屏障的时间不为0</span><br><span class="line">        if (when != 0) &#123;</span><br><span class="line">            //这里开始遍历消息，找到消息处理时间在消息屏障之后的那一个消息，赋值给p</span><br><span class="line">            while (p != null &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将消息屏障插入到 找到的消息之前</span><br><span class="line">        if (prev != null) &#123; // invariant: p == prev.next</span><br><span class="line">            //MessageQuene不为空时，走到这里，</span><br><span class="line">            //将消息屏障插入到前一条消息 和 后一条消息之间</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //MessageQuene中没有消息时，队列头就是消息屏障</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>handler在初始化时传入对应的Looper，如果不传，默认是当前线程的Looper。<br>后续handler发送消息时，都是调用的<code>sendMessageAtTime</code>,内部调用了私有方法enqueueMessage(),<br>内部实际调用的对应的MessageQuene的enqueueMessage();</p>
<p>另外主要看一下<code>dispatchMessage()</code>,looper中取到Message后就是调用对应的handler的dispatchMessage，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void dispatchMessage(@NonNull Message msg) &#123;</span><br><span class="line">    //如果Message设置了callback，就不会再回调handler的handleMessage()了</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //另外，如果Handler在构造时传入了callback，并且在callback中返回的true，也不会再回调handler的handleMessage()</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>Message没什么复杂的逻辑，就是一个序列化的实体类，保存了消息数据和对应需要处理的Handler。<br>在调用Handler的sendMessage时，会在handler的enqueueMessage()中对Message的target进行赋值，将message和handler关联起来</p>
<p>Handler中的enqueueMessage(),将msg和handler关联起来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,</span><br><span class="line">        long uptimeMillis) &#123;</span><br><span class="line">    msg.target = this;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Service</title>
    <url>//pages/a7afb0/</url>
    <content><![CDATA[<h2 id="bindService流程"><a href="#bindService流程" class="headerlink" title="bindService流程"></a>bindService流程</h2><p>ContextImpl.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean bindService(Intent service, ServiceConnection conn, int flags) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    return bindServiceCommon(service, conn, flags, null, mMainThread.getHandler(), null,</span><br><span class="line">            getUser());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags,</span><br><span class="line">        String instanceName, Handler handler, Executor executor, UserHandle user) &#123;</span><br><span class="line">    //......</span><br><span class="line">    try &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null</span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess(this);</span><br><span class="line">        //这里才是关键，调用AMS的bindIsolatedService</span><br><span class="line">        int res = ActivityManager.getService().bindIsolatedService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, instanceName, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            throw new SecurityException(</span><br><span class="line">                    &quot;Not allowed to bind to service &quot; + service);</span><br><span class="line">        &#125;</span><br><span class="line">        return res != 0;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看AMS中的bindIsolatedService：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int bindIsolatedService(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">        String resolvedType, IServiceConnection connection, int flags, String instanceName,</span><br><span class="line">        String callingPackage, int userId) throws TransactionTooLargeException &#123;</span><br><span class="line">    //......前面是一些校验</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        return mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, instanceName, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>AppOpsManager</title>
    <url>/2024/03/13/android_fw/53.AppOpsManager/</url>
    <content><![CDATA[<h2 id="AppOpsManager中变量说明"><a href="#AppOpsManager中变量说明" class="headerlink" title="AppOpsManager中变量说明"></a>AppOpsManager中变量说明</h2><ol>
<li><code>_NUM_OP</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final int _NUM_OP</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>OPSTR_* 字符床常量</li>
</ol>
<p>sOpToSwitch, sOpToString, sOpNames, sOpToPerms, sOpDefault</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>新增自体</title>
    <url>/2024/03/18/android_fw/54.%E6%96%B0%E5%A2%9E%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<h1 id="字体的初始化"><a href="#字体的初始化" class="headerlink" title="字体的初始化"></a>字体的初始化</h1><p>在<code>frameworks/base/graphics/java/android/graphics/fonts/SystemFonts.java</code>中静态代码块中初始化了系统字体</p>
<p>SystemFonts.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    final ArrayMap&lt;String, FontFamily[]&gt; systemFallbackMap = new ArrayMap&lt;&gt;();</span><br><span class="line">    final ArrayList&lt;Font&gt; availableFonts = new ArrayList&lt;&gt;();</span><br><span class="line">    //解析字oem自定义的字体</span><br><span class="line">    final FontCustomizationParser.Result oemCustomization =</span><br><span class="line">            readFontCustomization(&quot;/product/etc/fonts_customization.xml&quot;, &quot;/product/fonts/&quot;);</span><br><span class="line">    //构建系统默认字体，解析/system/etc/fonts.xml来构建，字体文件在/system/fonts/下</span><br><span class="line">    sAliases = buildSystemFallback(&quot;/system/etc/fonts.xml&quot;, &quot;/system/fonts/&quot;,</span><br><span class="line">            oemCustomization, systemFallbackMap, availableFonts);</span><br><span class="line"></span><br><span class="line">    //将字体库包裹成不可编辑的集合</span><br><span class="line">    sSystemFallbackMap = Collections.unmodifiableMap(systemFallbackMap);</span><br><span class="line">    sAvailableFonts = Collections.unmodifiableList(availableFonts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Build the system fallback from xml file.</span><br><span class="line"> *</span><br><span class="line"> * @param xmlPath A full path string to the fonts.xml file.</span><br><span class="line"> * @param fontDir A full path string to the system font directory. This must end with</span><br><span class="line"> *                slash(&#x27;/&#x27;).</span><br><span class="line"> * @param fallbackMap An output system fallback map. Caller must pass empty map.</span><br><span class="line"> * @return a list of aliases</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">@VisibleForTesting</span><br><span class="line">public static FontConfig.Alias[] buildSystemFallback(@NonNull String xmlPath,</span><br><span class="line">        @NonNull String fontDir,</span><br><span class="line">        @NonNull FontCustomizationParser.Result oemCustomization,</span><br><span class="line">        @NonNull ArrayMap&lt;String, FontFamily[]&gt; fallbackMap,</span><br><span class="line">        @NonNull ArrayList&lt;Font&gt; availableFonts) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        final FileInputStream fontsIn = new FileInputStream(xmlPath);</span><br><span class="line">        final FontConfig fontConfig = FontListParser.parse(fontsIn, fontDir);</span><br><span class="line"></span><br><span class="line">        final HashMap&lt;String, ByteBuffer&gt; bufferCache = new HashMap&lt;String, ByteBuffer&gt;();</span><br><span class="line">        final FontConfig.Family[] xmlFamilies = fontConfig.getFamilies();</span><br><span class="line"></span><br><span class="line">        final ArrayMap&lt;String, ArrayList&lt;FontFamily&gt;&gt; fallbackListMap = new ArrayMap&lt;&gt;();</span><br><span class="line">        // First traverse families which have a &#x27;name&#x27; attribute to create fallback map.</span><br><span class="line">        // 遍历所有family标签对象</span><br><span class="line">        for (final FontConfig.Family xmlFamily : xmlFamilies) &#123;</span><br><span class="line">            final String familyName = xmlFamily.getName();</span><br><span class="line">            if (familyName == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //family标签中name属性不为空的会创建一个FontFamily对象并添加到fallbackListMap中的fallbackList中</span><br><span class="line">            //同时会将family标签下的font标签中的字体文件解析后放入availableFonts中</span><br><span class="line">            appendNamedFamily(xmlFamily, bufferCache, fallbackListMap, availableFonts);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; oemCustomization.mAdditionalNamedFamilies.size(); ++i) &#123;</span><br><span class="line">            appendNamedFamily(oemCustomization.mAdditionalNamedFamilies.get(i),</span><br><span class="line">                    bufferCache, fallbackListMap, availableFonts);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Then, add fallback fonts to the each fallback map.</span><br><span class="line">        // 再次遍历所有的family标签对象，会将第一个或者没有name属性的创建一个FontFamily对象并添加到fallbackListMap中的每一个fallbackList中</span><br><span class="line">        for (int i = 0; i &lt; xmlFamilies.length; i++) &#123;</span><br><span class="line">            final FontConfig.Family xmlFamily = xmlFamilies[i];</span><br><span class="line">            // The first family (usually the sans-serif family) is always placed immediately</span><br><span class="line">            // after the primary family in the fallback.</span><br><span class="line">            if (i == 0 || xmlFamily.getName() == null) &#123;</span><br><span class="line">                pushFamilyToFallback(xmlFamily, fallbackListMap, bufferCache, availableFonts);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Build the font map and fallback map.</span><br><span class="line">        // 这里只是将集合转换成数组</span><br><span class="line">        for (int i = 0; i &lt; fallbackListMap.size(); i++) &#123;</span><br><span class="line">            final String fallbackName = fallbackListMap.keyAt(i);</span><br><span class="line">            final List&lt;FontFamily&gt; familyList = fallbackListMap.valueAt(i);</span><br><span class="line">            final FontFamily[] families = familyList.toArray(new FontFamily[familyList.size()]);</span><br><span class="line"></span><br><span class="line">            fallbackMap.put(fallbackName, families);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ArrayList&lt;FontConfig.Alias&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.addAll(Arrays.asList(fontConfig.getAliases()));</span><br><span class="line">        list.addAll(oemCustomization.mAdditionalAliases);</span><br><span class="line">        return list.toArray(new FontConfig.Alias[list.size()]);</span><br><span class="line">    &#125; catch (IOException | XmlPullParserException e) &#123;</span><br><span class="line">        Log.e(TAG, &quot;Failed initialize system fallbacks.&quot;, e);</span><br><span class="line">        return ArrayUtils.emptyArray(FontConfig.Alias.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">private static void appendNamedFamily(@NonNull FontConfig.Family xmlFamily,</span><br><span class="line">                                      @NonNull HashMap&lt;String, ByteBuffer&gt; bufferCache,</span><br><span class="line">                                      @NonNull ArrayMap&lt;String, ArrayList&lt;FontFamily&gt;&gt; fallbackListMap,</span><br><span class="line">                                      @NonNull ArrayList&lt;Font&gt; availableFonts) &#123;</span><br><span class="line">    final String familyName = xmlFamily.getName();</span><br><span class="line">    final FontFamily family = createFontFamily(</span><br><span class="line">            familyName, Arrays.asList(xmlFamily.getFonts()),</span><br><span class="line">            xmlFamily.getLanguages(), xmlFamily.getVariant(), bufferCache, availableFonts);</span><br><span class="line">    if (family == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    final ArrayList&lt;FontFamily&gt; fallback = new ArrayList&lt;&gt;();</span><br><span class="line">    fallback.add(family);</span><br><span class="line">    //注意这个map的value是一个ArrayList，后续有逻辑会往这个list中加FontFamily</span><br><span class="line">    fallbackListMap.put(familyName, fallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要逻辑：解析<code>/system/etc/fonts.xml</code>,遍历所有<code>family</code>标签，找到其中有 <code>name</code>属性的<code>family</code>标签，<br>解析<code>family</code>标签下的<code>font</code>标签，在<code>/system/fonts/</code>下去找对应的字体进行mmap，mmap成功将字体封装成Font，放入FontFamily中，<br>然后将FontFamily保存到<code>ArrayMap&lt;String, ArrayList&lt;FontFamily&gt;&gt;</code>。<br>后续还会在次遍历所有<code>family</code>标签，将第一个<code>family</code>和没有<code>name</code>属性的<code>family</code>加入到之前创建好的<code>ArrayMap&lt;String, ArrayList&lt;FontFamily&gt;&gt;</code><br>的每个value（ArrayList<FontFamily>）中</p>
<h2 id="默认fallback的字体"><a href="#默认fallback的字体" class="headerlink" title="默认fallback的字体"></a>默认fallback的字体</h2><p>Typeface.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final String DEFAULT_FAMILY = &quot;sans-serif&quot;;</span><br><span class="line"></span><br><span class="line">//静态方法体</span><br><span class="line">static &#123;</span><br><span class="line">    final HashMap&lt;String, Typeface&gt; systemFontMap = new HashMap&lt;&gt;();</span><br><span class="line">    initSystemDefaultTypefaces(systemFontMap, SystemFonts.getRawSystemFallbackMap(),</span><br><span class="line">            SystemFonts.getAliases());</span><br><span class="line">    sSystemFontMap = Collections.unmodifiableMap(systemFontMap);</span><br><span class="line"></span><br><span class="line">    // We can&#x27;t assume DEFAULT_FAMILY available on Roboletric.</span><br><span class="line">    if (sSystemFontMap.containsKey(DEFAULT_FAMILY)) &#123;</span><br><span class="line">        //这里去DEFAULT_FAMILY对应的sSystemFontMap中的字体，赋值给sDefaultTypeface</span><br><span class="line">        setDefault(sSystemFontMap.get(DEFAULT_FAMILY));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Set up defaults and typefaces exposed in public API</span><br><span class="line">    DEFAULT         = create((String) null, 0);</span><br><span class="line">    DEFAULT_BOLD    = create((String) null, Typeface.BOLD);</span><br><span class="line">    SANS_SERIF      = create(&quot;sans-serif&quot;, 0);</span><br><span class="line">    SERIF           = create(&quot;serif&quot;, 0);</span><br><span class="line">    MONOSPACE       = create(&quot;monospace&quot;, 0);</span><br><span class="line"></span><br><span class="line">    sDefaults = new Typeface[] &#123;</span><br><span class="line">        DEFAULT,</span><br><span class="line">        DEFAULT_BOLD,</span><br><span class="line">        create((String) null, Typeface.ITALIC),</span><br><span class="line">        create((String) null, Typeface.BOLD_ITALIC),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // A list of generic families to be registered in native.</span><br><span class="line">    // https://www.w3.org/TR/css-fonts-4/#generic-font-families</span><br><span class="line">    String[] genericFamilies = &#123;</span><br><span class="line">        &quot;serif&quot;, &quot;sans-serif&quot;, &quot;cursive&quot;, &quot;fantasy&quot;, &quot;monospace&quot;, &quot;system-ui&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    for (String genericFamily : genericFamilies) &#123;</span><br><span class="line">        registerGenericFamilyNative(genericFamily, systemFontMap.get(genericFamily));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)</span><br><span class="line">private static void setDefault(Typeface t) &#123;</span><br><span class="line">    sDefaultTypeface = t;</span><br><span class="line">    nativeSetDefault(t.native_instance);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">public static Typeface create(String familyName, @Style int style) &#123;</span><br><span class="line">    return create(getSystemDefaultTypeface(familyName), style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Typeface getSystemDefaultTypeface(@NonNull String familyName) &#123;</span><br><span class="line">    Typeface tf = sSystemFontMap.get(familyName);</span><br><span class="line">    return tf == null ? Typeface.DEFAULT : tf;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>
<p>根据以上逻辑，在Typeface的静态方法体中会去初始化Typeface.DEFAULT，传入的familyName为null，<br>按照getSystemDefaultTypeface的逻辑取出的Typeface为Typeface.DEFAULT（此时还是为null），<br>然后调用了create,根据create的逻辑，返回的sDefaultTypeface，也就是说Typeface.DEFAULT就是sDefaultTypeface的值，<br>而sDefaultTypeface是由Typeface中的DEFAULT_FAMILY决定的，所以<strong>可以通过DEFAULT_FAMILY来修改默认fallback的字体</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Typeface create(Typeface family, @Style int style) &#123;</span><br><span class="line">    if ((style &amp; ~STYLE_MASK) != 0) &#123;</span><br><span class="line">        style = NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">    if (family == null) &#123;</span><br><span class="line">        family = sDefaultTypeface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Return early if we&#x27;re asked for the same face/style</span><br><span class="line">    if (family.mStyle == style) &#123;</span><br><span class="line">        return family;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final long ni = family.native_instance;</span><br><span class="line"></span><br><span class="line">    Typeface typeface;</span><br><span class="line">    synchronized (sStyledCacheLock) &#123;</span><br><span class="line">        SparseArray&lt;Typeface&gt; styles = sStyledTypefaceCache.get(ni);</span><br><span class="line"></span><br><span class="line">        if (styles == null) &#123;</span><br><span class="line">            styles = new SparseArray&lt;Typeface&gt;(4);</span><br><span class="line">            sStyledTypefaceCache.put(ni, styles);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            typeface = styles.get(style);</span><br><span class="line">            if (typeface != null) &#123;</span><br><span class="line">                return typeface;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        typeface = new Typeface(nativeCreateFromTypeface(ni, style));</span><br><span class="line">        styles.put(style, typeface);</span><br><span class="line">    &#125;</span><br><span class="line">    return typeface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;string name=&quot;config_headlineFontFamilyMedium&quot; translateable=&quot;false&quot;&gt;Quicksand-medium&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;config_bodyFontFamily&quot; translatable=&quot;false&quot;&gt;Quicksand&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;config_bodyFontFamilyMedium&quot; translatable=&quot;false&quot;&gt;Quicksand-medium&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">&lt;string name=&quot;font_family_display_4_material&quot;&gt;Quicksand-light&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;font_family_display_3_material&quot;&gt;Quicksand&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;font_family_display_2_material&quot;&gt;Quicksand&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;font_family_display_1_material&quot;&gt;Quicksand&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;font_family_headline_material&quot;&gt;Quicksand&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;font_family_title_material&quot;&gt;Quicksand-medium&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;font_family_subhead_material&quot;&gt;Quicksand&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;font_family_menu_material&quot;&gt;Quicksand&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;font_family_body_2_material&quot;&gt;Quicksand-medium&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;font_family_body_1_material&quot;&gt;Quicksand&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;font_family_caption_material&quot;&gt;Quicksand&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;font_family_button_material&quot;&gt;Quicksand-medium&lt;/string&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>默认输入法</title>
    <url>/2024/12/06/android_fw/55.%E9%BB%98%E8%AE%A4%E8%BE%93%E5%85%A5%E6%B3%95/</url>
    <content><![CDATA[<h2 id="输入法配置流程"><a href="#输入法配置流程" class="headerlink" title="输入法配置流程"></a>输入法配置流程</h2><p>在InputMethodManagerService中buildInputMethodListLocked会去扫描输入法并通过settingprovider保存<br>queryInputMethodServicesInternal</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>ActivityView</title>
    <url>/2024/12/11/android_fw/56.ActivityView/</url>
    <content><![CDATA[<h2 id="AOSP中的ActivityView"><a href="#AOSP中的ActivityView" class="headerlink" title="AOSP中的ActivityView"></a>AOSP中的ActivityView</h2><p>源码中有对ActivityView的解释:<br>ActivityView是一个task容器，允许在ActivityView中启动Activity<br>将Activity启动到这ActivityView中受到和 在虚拟屏中启动Activity中一样的限制。<br>查看了ActivityView的源码，它就是结合虚拟屏实现的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Task container that allows launching activities into itself.</span><br><span class="line"> * &lt;p&gt;Activity launching into this container is restricted by the same rules that apply to launching</span><br><span class="line"> * on VirtualDisplays.</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">@TestApi</span><br><span class="line">public class ActivityView extends ViewGroup implements android.window.TaskEmbedder.Host &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看ActivityView的构造方法,<br>默认不使用TaskOrganizer,而是使用虚拟屏实现。<br>ActivityView的逻辑很简单，就是创建了一个SurfaceView添加到ActivityView这个父容器中，<br>然后在Surface创建成功时，拿到对应的SurfaceControl去初始化虚拟屏相关的逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ActivityView(</span><br><span class="line">        @NonNull Context context, @NonNull AttributeSet attrs, int defStyle,</span><br><span class="line">        boolean singleTaskInstance, boolean usePublicVirtualDisplay,</span><br><span class="line">        boolean disableSurfaceViewBackgroundLayer, boolean useTrustedDisplay) &#123;</span><br><span class="line">    super(context, attrs, defStyle);</span><br><span class="line">    if (useTaskOrganizer()) &#123;</span><br><span class="line">        mTaskEmbedder = new TaskOrganizerTaskEmbedder(context, this);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //默认创建虚拟屏来嵌入task，将taskEmbedder暂时理解为任务嵌入器，就是将其它task中的Activity嵌入到自己进程</span><br><span class="line">        mTaskEmbedder = new VirtualDisplayTaskEmbedder(context, this, singleTaskInstance,</span><br><span class="line">                usePublicVirtualDisplay, useTrustedDisplay);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建一个SurfaceView加到ActivityView这个父容器（ViewGroup）中</span><br><span class="line">    mSurfaceView = new SurfaceView(context, null, 0, 0, disableSurfaceViewBackgroundLayer);</span><br><span class="line">    // Since ActivityView#getAlpha has been overridden, we should use parent class&#x27;s alpha</span><br><span class="line">    // as master to synchronize surface view&#x27;s alpha value.</span><br><span class="line">    mSurfaceView.setAlpha(super.getAlpha());</span><br><span class="line">    mSurfaceView.setUseAlpha();</span><br><span class="line">    mSurfaceCallback = new SurfaceCallback();</span><br><span class="line">    //在surfaceView创建及销毁过程也做了逻辑</span><br><span class="line">    mSurfaceView.getHolder().addCallback(mSurfaceCallback);</span><br><span class="line">    addView(mSurfaceView);</span><br><span class="line"></span><br><span class="line">    mOpened = true;</span><br><span class="line">    mGuard.open(&quot;release&quot;);</span><br><span class="line">&#125;</span><br><span class="line">protected boolean useTaskOrganizer() &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">private boolean initTaskEmbedder(SurfaceControl parent) &#123;</span><br><span class="line">    if (!mTaskEmbedder.initialize(parent)) &#123;</span><br><span class="line">        Log.e(TAG, &quot;Failed to initialize ActivityView&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">private class SurfaceCallback implements SurfaceHolder.Callback &#123;</span><br><span class="line">    private final DisplayInfo mTempDisplayInfo = new DisplayInfo();</span><br><span class="line">    private final DisplayMetrics mTempMetrics = new DisplayMetrics();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceCreated(SurfaceHolder surfaceHolder) &#123;</span><br><span class="line">        //surface创建成功，第一次任务处理器没有初始化</span><br><span class="line">        if (!mTaskEmbedder.isInitialized()) &#123;</span><br><span class="line">            //这里传入surfaceControl去init</span><br><span class="line">            initTaskEmbedder(mSurfaceView.getSurfaceControl());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mTmpTransaction.reparent(mTaskEmbedder.getSurfaceControl(),</span><br><span class="line">                    mSurfaceView.getSurfaceControl()).apply();</span><br><span class="line">        &#125;</span><br><span class="line">        mTaskEmbedder.resizeTask(getWidth(), getHeight());</span><br><span class="line">        //这里去将虚拟屏显示状态设为true</span><br><span class="line">        mTaskEmbedder.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceChanged(SurfaceHolder surfaceHolder, int format, int width, int height) &#123;</span><br><span class="line">        final Display display = getVirtualDisplay().getDisplay();</span><br><span class="line">        if (!display.getDisplayInfo(mTempDisplayInfo)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mTempDisplayInfo.getAppMetrics(mTempMetrics);</span><br><span class="line">        if (width != mTempMetrics.widthPixels || height != mTempMetrics.heightPixels) &#123;</span><br><span class="line">            mTaskEmbedder.resizeTask(width, height);</span><br><span class="line">            mTaskEmbedder.notifyBoundsChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceDestroyed(SurfaceHolder surfaceHolder) &#123;</span><br><span class="line">        mTaskEmbedder.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>接着看虚拟屏进行Activity显示相关的逻辑,在surfaceView创建成功时，调用了TaskEmbedder的initialize，<br>主要就是以ActivityView中的SurfaceView的SurfaceControl为父容器创建一个SurfaceControl作为虚拟屏的显示容器，<br>接着创建虚拟屏，将虚拟屏的displayContent中的surfaceControl的父容器设置为TaskEmbedder中创建的SurfaceControl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean initialize(SurfaceControl parent) &#123;</span><br><span class="line">    //在子类VirtualDisplayTaskEmbedder中判断的mVirtualDisplay是否不为空</span><br><span class="line">    if (isInitialized()) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Trying to initialize for the second time.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTransaction = new SurfaceControl.Transaction();</span><br><span class="line">    // Create a container surface to which the task content will be reparented</span><br><span class="line">    // 创建一个SurfaceControl容器用来作为虚拟屏的父容器</span><br><span class="line">    final String name = &quot;TaskEmbedder - &quot; + Integer.toHexString(System.identityHashCode(this));</span><br><span class="line">    mSurfaceControl = new SurfaceControl.Builder()</span><br><span class="line">            .setContainerLayer()</span><br><span class="line">            .setParent(parent)</span><br><span class="line">            .setName(name)</span><br><span class="line">            .setCallsite(&quot;TaskEmbedder.initialize&quot;)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    //接着调用子类VirtualDisplayTaskEmbedder中实现的onInitialize</span><br><span class="line">    if (!onInitialize()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mListener != null &amp;&amp; isInitialized()) &#123;</span><br><span class="line">        mListener.onInitialized();</span><br><span class="line">    &#125;</span><br><span class="line">    mOpened = true;</span><br><span class="line">    mGuard.open(&quot;release&quot;);</span><br><span class="line">    mTransaction.show(getSurfaceControl()).apply();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>VirtualDisplayTaskEmbedder.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onInitialize() &#123;</span><br><span class="line">    final DisplayManager displayManager = mContext.getSystemService(DisplayManager.class);</span><br><span class="line">    mDisplayDensityDpi = getBaseDisplayDensity();</span><br><span class="line"></span><br><span class="line">    int virtualDisplayFlags = VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY</span><br><span class="line">            | VIRTUAL_DISPLAY_FLAG_DESTROY_CONTENT_ON_REMOVAL;</span><br><span class="line">    if (mUsePublicVirtualDisplay) &#123;</span><br><span class="line">        virtualDisplayFlags |= VIRTUAL_DISPLAY_FLAG_PUBLIC;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mUseTrustedDisplay) &#123;</span><br><span class="line">        virtualDisplayFlags |= VIRTUAL_DISPLAY_FLAG_TRUSTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据父容器的宽高，创建了一个虚拟屏</span><br><span class="line">    mVirtualDisplay = displayManager.createVirtualDisplay(</span><br><span class="line">            DISPLAY_NAME + &quot;@&quot; + System.identityHashCode(this), mHost.getWidth(),</span><br><span class="line">            mHost.getHeight(), mDisplayDensityDpi, null, virtualDisplayFlags);</span><br><span class="line"></span><br><span class="line">    if (mVirtualDisplay == null) &#123;</span><br><span class="line">        Log.e(TAG, &quot;Failed to initialize TaskEmbedder&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // TODO: Find a way to consolidate these calls to the server.</span><br><span class="line">        final int displayId = getDisplayId();</span><br><span class="line">        final IWindowManager wm = WindowManagerGlobal.getWindowManagerService();</span><br><span class="line">        //调用WMS的reparentDisplayContent，将虚拟屏的父window设置为ActivityView的window，将父容器设置为TaskEmbedder创建的surfaceControl容器</span><br><span class="line">        WindowManagerGlobal.getWindowSession().reparentDisplayContent(</span><br><span class="line">                mHost.getWindow(), mSurfaceControl, displayId);</span><br><span class="line">        wm.dontOverrideDisplayInfo(displayId);</span><br><span class="line">        if (mSingleTaskInstance) &#123;</span><br><span class="line">            mContext.getSystemService(ActivityTaskManager.class)</span><br><span class="line">                    .setDisplayToSingleTaskInstance(displayId);</span><br><span class="line">        &#125;</span><br><span class="line">        setForwardedInsets(mForwardedInsets);</span><br><span class="line"></span><br><span class="line">        mTaskStackListener = new TaskStackListenerImpl();</span><br><span class="line">        mActivityTaskManager.registerTaskStackListener(mTaskStackListener);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        e.rethrowAsRuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return super.onInitialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>windowSoftInputMode</title>
    <url>//pages/9a0c04/</url>
    <content><![CDATA[<h2 id="window的显示"><a href="#window的显示" class="headerlink" title="window的显示"></a>window的显示</h2><p>在DisplayPolicy中，有一个layoutWindowLw方法，这个方法中会计算window的位置，<br>计算出WindowState中各种条件下的显示区域：</p>
<ul>
<li>Rect pf &#x3D; windowFrames.mParentFrame   通常表示整个屏幕的区域，即整个屏幕的大小。但可能需要将其名称与mDisplayFrame互换，以提高代码的清晰性。</li>
<li>Rect df &#x3D; windowFrames.mDisplayFrame  表示ActivityStack中的窗口所在的整个屏幕区域。通常与设备的屏幕区域相等。</li>
<li>Rect cf &#x3D; windowFrames.mContentFrame  当IME（如键盘）未显示时，等于mDecorFrame。当IME显示时，等于mDecorFrame减去IME占用的区域。</li>
<li>Rect vf &#x3D; windowFrames.mVisibleFrame  用于处理一些旧版应用程序的IME（输入法）显示提示文本的情况。即用于处理兼容旧版应用的情况。</li>
<li>Rect dcf &#x3D; windowFrames.mDecorFrame   表示除去状态栏和导航栏之外的屏幕区域。如果同时显示状态栏和导航栏，则mDecorFrame等于mStableFrame。</li>
<li>Rect sf &#x3D; windowFrames.mStableFrame   表示除去稳定不变的内边距之后的mDisplayFrame。该值始终保持不变，无论状态栏或导航栏是否可见。</li>
</ul>
<p>SOFT_INPUT_ADJUST_RESIZE</p>
<p>RootWindowContainer.performSurfacePlacement<br>RootWindowContainer.performSurfacePlacementNoTrace<br>RootWindowContainer.handleResizingWindows<br>    WindowState.reportResized<br>        mClient.resized (ViewRootImpl.W.resized)<br>            ViewRootImpl.dispatchResized</p>
<p>IME(输入法)似乎也被抽象成了insets：<br>ImeInsetsSourceProvider.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void scheduleShowImePostLayout(InsetsControlTarget imeTarget) &#123;</span><br><span class="line">    boolean targetChanged = mImeTargetFromIme != imeTarget</span><br><span class="line">            &amp;&amp; mImeTargetFromIme != null &amp;&amp; imeTarget != null &amp;&amp; mShowImeRunner != null</span><br><span class="line">            &amp;&amp; imeTarget.getWindow() != null &amp;&amp; mImeTargetFromIme.getWindow() != null</span><br><span class="line">            &amp;&amp; mImeTargetFromIme.getWindow().mActivityRecord</span><br><span class="line">                    == imeTarget.getWindow().mActivityRecord;</span><br><span class="line">    mImeTargetFromIme = imeTarget;</span><br><span class="line">    if (targetChanged) &#123;</span><br><span class="line">        // target changed, check if new target can show IME.</span><br><span class="line">        ProtoLog.d(WM_DEBUG_IME, &quot;IME target changed within ActivityRecord&quot;);</span><br><span class="line">        checkShowImePostLayout();</span><br><span class="line">        // if IME cannot be shown at this time, it is scheduled to be shown.</span><br><span class="line">        // once window that called IMM.showSoftInput() and DisplayContent&#x27;s ImeTarget match,</span><br><span class="line">        // it will be shown.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProtoLog.d(WM_DEBUG_IME, &quot;Schedule IME show for %s&quot;, mImeTargetFromIme.getWindow() == null</span><br><span class="line">            ? mImeTargetFromIme : mImeTargetFromIme.getWindow().getName());</span><br><span class="line">    mShowImeRunner = () -&gt; &#123;</span><br><span class="line">        ProtoLog.d(WM_DEBUG_IME, &quot;Run showImeRunner&quot;);</span><br><span class="line">        // Target should still be the same.</span><br><span class="line">        if (isImeTargetFromDisplayContentAndImeSame()) &#123;</span><br><span class="line">            final InsetsControlTarget target = mDisplayContent.mInputMethodControlTarget;</span><br><span class="line"></span><br><span class="line">            ProtoLog.i(WM_DEBUG_IME, &quot;call showInsets(ime) on %s&quot;,</span><br><span class="line">                    target.getWindow() != null ? target.getWindow().getName() : &quot;&quot;);</span><br><span class="line">            setImeShowing(true);</span><br><span class="line">            //这里去显示输入法，并消费insets</span><br><span class="line">            target.showInsets(WindowInsets.Type.ime(), true /* fromIme */);</span><br><span class="line">            if (target != mImeTargetFromIme &amp;&amp; mImeTargetFromIme != null) &#123;</span><br><span class="line">                ProtoLog.w(WM_DEBUG_IME,</span><br><span class="line">                        &quot;showInsets(ime) was requested by different window: %s &quot;,</span><br><span class="line">                        (mImeTargetFromIme.getWindow() != null</span><br><span class="line">                                ? mImeTargetFromIme.getWindow().getName() : &quot;&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        abortShowImePostLayout();</span><br><span class="line">    &#125;;</span><br><span class="line">    mDisplayContent.mWmService.requestTraversal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在WMS中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void hideIme(IBinder imeTargetWindowToken, int displayId) &#123;</span><br><span class="line">    synchronized (mGlobalLock) &#123;</span><br><span class="line">        WindowState imeTarget = mWindowMap.get(imeTargetWindowToken);</span><br><span class="line">        ProtoLog.d(WM_DEBUG_IME, &quot;hideIme target: %s &quot;, imeTarget);</span><br><span class="line">        DisplayContent dc = mRoot.getDisplayContent(displayId);</span><br><span class="line">        if (imeTarget != null) &#123;</span><br><span class="line">            imeTarget = imeTarget.getImeControlTarget().getWindow();</span><br><span class="line">            if (imeTarget != null) &#123;</span><br><span class="line">                dc = imeTarget.getDisplayContent();</span><br><span class="line">            &#125;</span><br><span class="line">            // If there was a pending IME show(), reset it as IME has been</span><br><span class="line">            // requested to be hidden.</span><br><span class="line">            dc.getInsetsStateController().getImeSourceProvider().abortShowImePostLayout();</span><br><span class="line">        &#125;</span><br><span class="line">        if (dc != null &amp;&amp; dc.mInputMethodControlTarget != null) &#123;</span><br><span class="line">            ProtoLog.d(WM_DEBUG_IME, &quot;hideIme Control target: %s &quot;,</span><br><span class="line">                    dc.mInputMethodControlTarget);</span><br><span class="line">            //这里去隐藏输入法，取消Insets</span><br><span class="line">            dc.mInputMethodControlTarget.hideInsets(</span><br><span class="line">                    WindowInsets.Type.ime(), true /* fromIme */);</span><br><span class="line">        &#125;</span><br><span class="line">        if (dc != null) &#123;</span><br><span class="line">            dc.getInsetsStateController().getImeSourceProvider().setImeShowing(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在DisplayPolicy中每次beginLayoutLw，都会对displayFrames进行初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void beginLayoutLw(DisplayFrames displayFrames, int uiMode) &#123;</span><br><span class="line">    //这里是各个frame进行初始化，初始化值都是整个屏幕区域</span><br><span class="line">    displayFrames.onBeginLayout();</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在layoutWindowLw中，如果WindowState是输入法，会对displayFrames的mContent和mCurrent这2个帧进行计算</p>
<p>windowFrames.mFrame？没法溯源</p>
<p>WindowFrames.calculateInsets<br>InsetUtils.insetsBetweenFrames</p>
<p>在WindowState的computeFrameLw中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void computeFrameLw() &#123;</span><br><span class="line">    //....</span><br><span class="line">    if (isFullscreenAndFillsDisplay || layoutInParentFrame()) &#123;</span><br><span class="line">        // We use the parent frame as the containing frame for fullscreen and child windows</span><br><span class="line">        //全屏铺满屏幕或着布局在父容器中的，会将windowFrames的mParentFrame赋值给mContainingFrame</span><br><span class="line">        windowFrames.mContainingFrame.set(windowFrames.mParentFrame);</span><br><span class="line">        layoutDisplayFrame = windowFrames.mDisplayFrame;</span><br><span class="line">        layoutContainingFrame = windowFrames.mParentFrame;</span><br><span class="line">        layoutXDiff = 0;</span><br><span class="line">        layoutYDiff = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //取出父容器显示区域的宽高</span><br><span class="line">    final int pw = windowFrames.mContainingFrame.width();</span><br><span class="line">    final int ph = windowFrames.mContainingFrame.height();</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    //取出window显示区域的宽高</span><br><span class="line">    final int fw = windowFrames.mFrame.width();</span><br><span class="line">    final int fh = windowFrames.mFrame.height();   </span><br><span class="line"></span><br><span class="line">    applyGravityAndUpdateFrame(windowFrames, layoutContainingFrame, layoutDisplayFrame);             </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>全屏相关</title>
    <url>//pages/2a27d6/</url>
    <content><![CDATA[<h2 id="设置全屏"><a href="#设置全屏" class="headerlink" title="设置全屏"></a>设置全屏</h2><p>在android 11之前，全屏是通过flag来进行控制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</span><br><span class="line">                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span><br><span class="line">                | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);</span><br></pre></td></tr></table></figure>
<p>从android 11开始，引入了一个新的类<code>WindowInsetsController</code>,全屏控制可以通过它来进行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WindowInsetsController windowInsetsController = getWindow().getDecorView().getWindowInsetsController();</span><br><span class="line">windowInsetsController.hide(WindowInsets.Type.navigationBars() | WindowInsets.Type.statusBars());</span><br><span class="line">windowInsetsController.setSystemBarsBehavior(WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE);</span><br></pre></td></tr></table></figure>

<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>setSystemUiVisibility是View的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line">public void setSystemUiVisibility(int visibility) &#123;</span><br><span class="line">    if (visibility != mSystemUiVisibility) &#123;</span><br><span class="line">        mSystemUiVisibility = visibility;</span><br><span class="line">        if (mParent != null &amp;&amp; mAttachInfo != null &amp;&amp; !mAttachInfo.mRecomputeGlobalAttributes) &#123;</span><br><span class="line">            mParent.recomputeViewAttributes(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是在方法中将mSystemUiVisibility的值重新赋值了一下,然后执行了ViewRootImpl的recomputeViewAttributes,这个方法将mRecomputeGlobalAttributes置为true，<br>然后在进行performTraversals()时，根据mRecomputeGlobalAttributes来重新收集属性值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean collectViewAttributes() &#123;</span><br><span class="line">    if (mAttachInfo.mRecomputeGlobalAttributes) &#123;</span><br><span class="line">        //Log.i(mTag, &quot;Computing view hierarchy attributes!&quot;);</span><br><span class="line">        mAttachInfo.mRecomputeGlobalAttributes = false;</span><br><span class="line">        //......</span><br><span class="line">        //先清空mSystemUiVisibility</span><br><span class="line">        mAttachInfo.mSystemUiVisibility = 0;</span><br><span class="line">        //......</span><br><span class="line">        //然后执行Decorview的dispatchCollectViewAttributes，内部会遍历所有的子view的mSystemUiVisibility</span><br><span class="line">        //将其全部与mAttachInfo.mSystemUiVisibility进行或操作</span><br><span class="line">        mView.dispatchCollectViewAttributes(mAttachInfo, 0);</span><br><span class="line">        //收集完后会将禁用的SystemUiVisibility给移除</span><br><span class="line">        mAttachInfo.mSystemUiVisibility &amp;= ~mAttachInfo.mDisabledSystemUiVisibility;</span><br><span class="line">        WindowManager.LayoutParams params = mWindowAttributes;</span><br><span class="line">        //将一些特定的flag给加上</span><br><span class="line">        mAttachInfo.mSystemUiVisibility |= getImpliedSystemUiVisibility(params);</span><br><span class="line">        //......</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外DecorView的mParent是ViewRootImpl，这个可以看源码，<br>在初始化ViewRootImpl时setView中就设置好了：<br>WindowManagerGlobal.java:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">        Display display, Window parentWindow, int userId) &#123;</span><br><span class="line">    //......</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = null;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        // do this last because it fires off messages to start doing things</span><br><span class="line">        try &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView, userId);</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            // BadTokenException or InvalidDisplayException, clean up.</span><br><span class="line">            if (index &gt;= 0) &#123;</span><br><span class="line">                removeViewLocked(index, true);</span><br><span class="line">            &#125;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ViewRootImpl的setView中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,</span><br><span class="line">        int userId) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mView == null) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line"></span><br><span class="line">            //......</span><br><span class="line"></span><br><span class="line">            // Schedule the first layout -before- adding to the window</span><br><span class="line">            // manager, to make sure we do the relayout before receiving</span><br><span class="line">            // any other events from the system.</span><br><span class="line">            requestLayout();</span><br><span class="line">            InputChannel inputChannel = null;</span><br><span class="line">            if ((mWindowAttributes.inputFeatures</span><br><span class="line">                    &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;</span><br><span class="line">                inputChannel = new InputChannel();</span><br><span class="line">            &#125;</span><br><span class="line">            mForceDecorViewVisibility = (mWindowAttributes.privateFlags</span><br><span class="line">                    &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">                mAttachInfo.mRecomputeGlobalAttributes = true;</span><br><span class="line">                collectViewAttributes();</span><br><span class="line">                adjustLayoutParamsForCompatibility(mWindowAttributes);</span><br><span class="line">                //这里最终是调用WMS的addWindow</span><br><span class="line">                res = mWindowSession.addToDisplayAsUser(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(), userId, mTmpFrame,</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mDisplayCutout, inputChannel,</span><br><span class="line">                        mTempInsets, mTempControls);</span><br><span class="line">                setFrame(mTmpFrame);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                mAdded = false;</span><br><span class="line">                mView = null;</span><br><span class="line">                mAttachInfo.mRootView = null;</span><br><span class="line">                inputChannel = null;</span><br><span class="line">                mFallbackEventHandler.setView(null);</span><br><span class="line">                unscheduleTraversals();</span><br><span class="line">                setAccessibilityFocus(null, null);</span><br><span class="line">                throw new RuntimeException(&quot;Adding window failed&quot;, e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (restore) &#123;</span><br><span class="line">                    attrs.restore();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //......</span><br><span class="line">            这里设置DecorView的Parent，ViewRootImpl，ViewRootImpl实现了ViewParent接口</span><br><span class="line">            view.assignParent(this);</span><br><span class="line">            //......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 performTraversals 中有 adjustLayoutParamsForCompatibility 会对window的LayoutParams进行兼容处理，将以前的systemUiVisibility转换成<br>最新的api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void adjustLayoutParamsForCompatibility(WindowManager.LayoutParams inOutParams) &#123;</span><br><span class="line">    if (sNewInsetsMode != NEW_INSETS_MODE_FULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int sysUiVis = inOutParams.systemUiVisibility | inOutParams.subtreeSystemUiVisibility;</span><br><span class="line">    final int flags = inOutParams.flags;</span><br><span class="line">    final int type = inOutParams.type;</span><br><span class="line">    final int adjust = inOutParams.softInputMode &amp; SOFT_INPUT_MASK_ADJUST;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    //新的api：WindowInsetsController.setSystemBarsBehavior会设置一个privateFlags 即 PRIVATE_FLAG_BEHAVIOR_CONTROLLED</span><br><span class="line">    //针对没有调用这个api的，做老版本兼容，判断systemUiVisibility的flag，做对应的处理</span><br><span class="line">    if ((inOutParams.privateFlags &amp; PRIVATE_FLAG_BEHAVIOR_CONTROLLED) == 0) &#123;</span><br><span class="line">        if ((sysUiVis &amp; SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0</span><br><span class="line">                || (flags &amp; FLAG_FULLSCREEN) != 0) &#123;</span><br><span class="line">            inOutParams.insetsFlags.behavior = BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE;</span><br><span class="line">        &#125; else if ((sysUiVis &amp; SYSTEM_UI_FLAG_IMMERSIVE) != 0) &#123;</span><br><span class="line">            inOutParams.insetsFlags.behavior = BEHAVIOR_SHOW_BARS_BY_SWIPE;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            inOutParams.insetsFlags.behavior = BEHAVIOR_SHOW_BARS_BY_TOUCH;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外在 controlInsetsForCompatibility 中通过 WindowInsetsController的hide和show来控制的全屏半屏。</p>
]]></content>
  </entry>
  <entry>
    <title>DisplayManagerService</title>
    <url>//pages/f6022c/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>InputManagerService梳理</title>
    <url>/2024/05/30/android_fw/67.InputManagerService/</url>
    <content><![CDATA[<h2 id="IMS的启动流程"><a href="#IMS的启动流程" class="headerlink" title="IMS的启动流程"></a>IMS的启动流程</h2><p>在SystemServer的startOtherServices中启动的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void startOtherServices(@NonNull TimingsTraceAndSlog t) &#123;</span><br><span class="line">        t.traceBegin(&quot;StartInputManagerService&quot;);</span><br><span class="line">        inputManager = new InputManagerService(context);</span><br><span class="line">        t.traceEnd();</span><br><span class="line"></span><br><span class="line">        t.traceBegin(&quot;StartInputManager&quot;);</span><br><span class="line">        inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());</span><br><span class="line">        inputManager.start();</span><br><span class="line">        t.traceEnd();</span><br><span class="line"></span><br><span class="line">        t.traceBegin(&quot;StartWiredAccessoryManager&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            // Listen for wired headset changes</span><br><span class="line">            inputManager.setWiredAccessoryCallbacks(</span><br><span class="line">                    new WiredAccessoryManager(context, inputManager));</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            reportWtf(&quot;starting WiredAccessoryManager&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        t.traceEnd();</span><br><span class="line"></span><br><span class="line">        t.traceBegin(&quot;MakeInputManagerServiceReady&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            // TODO(BT) Pass parameter to input manager</span><br><span class="line">            if (inputManagerF != null) &#123;</span><br><span class="line">                inputManagerF.systemRunning();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            reportWtf(&quot;Notifying InputManagerService running&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        t.traceEnd();                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IMS的构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public InputManagerService(Context context) &#123;</span><br><span class="line">    this.mContext = context;</span><br><span class="line">    this.mHandler = new InputManagerHandler(DisplayThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">    mStaticAssociations = loadStaticInputPortAssociations();</span><br><span class="line">    mUseDevInputEventForAudioJack =</span><br><span class="line">            context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack);</span><br><span class="line">    Slog.i(TAG, &quot;Initializing input manager, mUseDevInputEventForAudioJack=&quot;</span><br><span class="line">            + mUseDevInputEventForAudioJack);</span><br><span class="line">    //通过JNI初始化</span><br><span class="line">    mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue());</span><br><span class="line"></span><br><span class="line">    String doubleTouchGestureEnablePath = context.getResources().getString(</span><br><span class="line">            R.string.config_doubleTouchGestureEnableFile);</span><br><span class="line">    mDoubleTouchGestureEnableFile = TextUtils.isEmpty(doubleTouchGestureEnablePath) ? null :</span><br><span class="line">        new File(doubleTouchGestureEnablePath);</span><br><span class="line"></span><br><span class="line">    LocalServices.addService(InputManagerInternal.class, new LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>com_android_server_input_InputManagerService.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static jlong nativeInit(JNIEnv* env, jclass /* clazz */,</span><br><span class="line">        jobject serviceObj, jobject contextObj, jobject messageQueueObj) &#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    if (messageQueue == nullptr) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, &quot;MessageQueue is not initialized.&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建了一个NativeInputManager对象</span><br><span class="line">    NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());</span><br><span class="line">    im-&gt;incStrong(0);</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NativeInputManager : public virtual RefBase,</span><br><span class="line">    public virtual InputReaderPolicyInterface,</span><br><span class="line">    public virtual InputDispatcherPolicyInterface,</span><br><span class="line">    public virtual PointerControllerPolicyInterface &#123;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    sp&lt;InputManager&gt; mInputManager;</span><br><span class="line"></span><br><span class="line">    jobject mServiceObj;</span><br><span class="line">    sp&lt;Looper&gt; mLooper;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">        jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(true) &#123;</span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    mServiceObj = env-&gt;NewGlobalRef(serviceObj);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;</span><br><span class="line">        mLocked.pointerSpeed = 0;</span><br><span class="line">        mLocked.pointerGesturesEnabled = true;</span><br><span class="line">        mLocked.showTouches = false;</span><br><span class="line">        mLocked.pointerCapture = false;</span><br><span class="line">        mLocked.pointerDisplayId = ADISPLAY_ID_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    mInteractive = true;</span><br><span class="line">    //这里去初始化 inputflinger中的InputManager</span><br><span class="line">    mInputManager = new InputManager(this, this);</span><br><span class="line">    defaultServiceManager()-&gt;addService(String16(&quot;inputflinger&quot;),</span><br><span class="line">            mInputManager, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>libinputflinger.so什么时候加载的？在System Server启动的时候会先去加载libandroid_servers.so<br>libandroid_servers.so中依赖了libinputflinger.so</p>
<pre><code>    private void run() &#123;
        //......
        try &#123;
            // Initialize native services.
            System.loadLibrary(&quot;android_servers&quot;);
            //......
        &#125;
        //......
    &#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>SurfaceFlinger</title>
    <url>/2024/06/18/android_fw/68.SurfaceFlinger/</url>
    <content><![CDATA[<h2 id="SurfaceControlViewHost"><a href="#SurfaceControlViewHost" class="headerlink" title="SurfaceControlViewHost"></a>SurfaceControlViewHost</h2><p>SurfaceControlViewHost可用于跨进程渲染图像，可以对另一个进程的SurfaceView进行渲染</p>
<p>主要逻辑：<br>进程A持有一个SurfaceView，进程A通过aidl将SurfaceView.getHostToken取到的token等相关信息传给进程B</p>
<p>进程B根据相关信息创建一个SurfaceControlViewHost，然后调用SurfaceControlViewHost.setView将要绘制的view传递进去，<br>再调用SurfaceControlViewHost.getSurfacePackage获取到子界面，将子界面回传给进程A</p>
<p>最后进程A 通过SurfaceView.setChildSurfacePackage将进程B的子界面嵌入到SurfaceView中</p>
<p>更细节上的，去查看AOSP源码，<br>SurfaceView.getHostToken 获取的其实是 SurfaceView所在进程的 输入事件相关的token:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * A token used for constructing &#123;@link SurfaceControlViewHost&#125;. This token should</span><br><span class="line">     * be passed from the host process to the client process.</span><br><span class="line">     *</span><br><span class="line">     * @return The token</span><br><span class="line">     */</span><br><span class="line">    public @Nullable IBinder getHostToken() &#123;</span><br><span class="line">        final ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">        if (viewRoot == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return viewRoot.getInputToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ViewRootImpl.java：</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @return Returns a token used to identify the windows input channel.</span><br><span class="line">     */</span><br><span class="line">    public IBinder getInputToken() &#123;</span><br><span class="line">        if (mInputEventReceiver == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return mInputEventReceiver.getToken();</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>


<p>SurfaceControlViewHost中直接创建了一个SurfaceControl作为容器,<br>getSurfacePackage就是获取对这个SurfaceControl进行包装后的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Construct a new SurfaceControlViewHost. The root Surface will be</span><br><span class="line"> * allocated internally and is accessible via getSurfacePackage().</span><br><span class="line"> *</span><br><span class="line"> * The &#123;@param hostToken&#125; parameter, primarily used for ANR reporting,</span><br><span class="line"> * must be obtained from whomever will be hosting the embedded hierarchy.</span><br><span class="line"> * It&#x27;s accessible from &#123;@link SurfaceView#getHostToken&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param context The Context object for your activity or application.</span><br><span class="line"> * @param display The Display the hierarchy will be placed on.</span><br><span class="line"> * @param hostToken The host token, as discussed above.</span><br><span class="line"> */</span><br><span class="line">public SurfaceControlViewHost(@NonNull Context context, @NonNull Display display,</span><br><span class="line">        @Nullable IBinder hostToken) &#123;</span><br><span class="line">    mSurfaceControl = new SurfaceControl.Builder()</span><br><span class="line">            .setContainerLayer()</span><br><span class="line">            .setName(&quot;SurfaceControlViewHost&quot;)</span><br><span class="line">            .setCallsite(&quot;SurfaceControlViewHost&quot;)</span><br><span class="line">            .build();</span><br><span class="line">    mWm = new WindowlessWindowManager(context.getResources().getConfiguration(),</span><br><span class="line">            mSurfaceControl, hostToken);</span><br><span class="line">    mViewRoot = new ViewRootImpl(context, display, mWm);</span><br><span class="line">    mViewRoot.forceDisableBLAST();</span><br><span class="line">    mAccessibilityEmbeddedConnection = mViewRoot.getAccessibilityEmbeddedConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setView(@NonNull View view, int width, int height) &#123;</span><br><span class="line">    final WindowManager.LayoutParams lp =</span><br><span class="line">            new WindowManager.LayoutParams(width, height,</span><br><span class="line">                    WindowManager.LayoutParams.TYPE_APPLICATION, 0, PixelFormat.TRANSPARENT);</span><br><span class="line">    lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">    setView(view, lp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@TestApi</span><br><span class="line">public void setView(@NonNull View view, @NonNull WindowManager.LayoutParams attrs) &#123;</span><br><span class="line">    Objects.requireNonNull(view);</span><br><span class="line">    mViewRoot.setView(view, attrs, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public @Nullable SurfacePackage getSurfacePackage() &#123;</span><br><span class="line">    if (mSurfaceControl != null &amp;&amp; mAccessibilityEmbeddedConnection != null) &#123;</span><br><span class="line">        //其实就是将创建的SurfaceControl包了一层再返回</span><br><span class="line">        return new SurfacePackage(mSurfaceControl, mAccessibilityEmbeddedConnection);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static final class SurfacePackage implements Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    SurfacePackage(SurfaceControl sc, IAccessibilityEmbeddedConnection connection) &#123;</span><br><span class="line">        mSurfaceControl = sc;</span><br><span class="line">        mAccessibilityEmbeddedConnection = connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后再看看SurfaceView中的setChildSurfacePackage</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setChildSurfacePackage(@NonNull SurfaceControlViewHost.SurfacePackage p) &#123;</span><br><span class="line">    final SurfaceControl sc = p != null ? p.getSurfaceControl() : null;</span><br><span class="line">    final SurfaceControl lastSc = mSurfacePackage != null ?</span><br><span class="line">        mSurfacePackage.getSurfaceControl() : null;</span><br><span class="line">    if (mSurfaceControl != null &amp;&amp; lastSc != null) &#123;</span><br><span class="line">        mTmpTransaction.reparent(lastSc, null).apply();</span><br><span class="line">        mSurfacePackage.release();</span><br><span class="line">    &#125; else if (mSurfaceControl != null) &#123;</span><br><span class="line">        reparentSurfacePackage(mTmpTransaction, p);</span><br><span class="line">        mTmpTransaction.apply();</span><br><span class="line">    &#125;</span><br><span class="line">    mSurfacePackage = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void reparentSurfacePackage(SurfaceControl.Transaction t,</span><br><span class="line">        SurfaceControlViewHost.SurfacePackage p) &#123;</span><br><span class="line">    initEmbeddedHierarchyForAccessibility(p);</span><br><span class="line">    final SurfaceControl sc = p.getSurfaceControl();</span><br><span class="line">    //这里才是关键，将其它进程传递过来的SurfaceControl，父容器设置为自己SurfaceView所持有的SurfaceControl</span><br><span class="line">    t.reparent(sc, mSurfaceControl).show(sc);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h2 id="关于SurfaceControl的序列化"><a href="#关于SurfaceControl的序列化" class="headerlink" title="关于SurfaceControl的序列化"></a>关于SurfaceControl的序列化</h2><p>主要看SurfaceControl的源码中的处理逻辑,主要逻辑还是丢到native去处理的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void readFromParcel(Parcel in) &#123;</span><br><span class="line">    if (in == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;source must not be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mName = in.readString8();</span><br><span class="line">    mWidth = in.readInt();</span><br><span class="line">    mHeight = in.readInt();</span><br><span class="line"></span><br><span class="line">    long object = 0;</span><br><span class="line">    if (in.readInt() != 0) &#123;</span><br><span class="line">        object = nativeReadFromParcel(in);</span><br><span class="line">    &#125;</span><br><span class="line">    assignNativeObject(object, &quot;readFromParcel&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">    dest.writeString8(mName);</span><br><span class="line">    dest.writeInt(mWidth);</span><br><span class="line">    dest.writeInt(mHeight);</span><br><span class="line">    if (mNativeObject == 0) &#123;</span><br><span class="line">        dest.writeInt(0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dest.writeInt(1);</span><br><span class="line">    &#125;</span><br><span class="line">    nativeWriteToParcel(mNativeObject, dest);</span><br><span class="line"></span><br><span class="line">    if ((flags &amp; Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到主要就是 <code>nativeReadFromParcel</code>和<code>nativeWriteToParcel``方法，继续追 </code>android_view_SurfaceControl&#96;&#96;&#96;,发现调用的C++层SurfaceControl的writeToParcel和readFromParcel:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void nativeWriteToParcel(JNIEnv* env, jclass clazz,</span><br><span class="line">        jlong nativeObject, jobject parcelObj) &#123;</span><br><span class="line">    Parcel* parcel = parcelForJavaObject(env, parcelObj);</span><br><span class="line">    if (parcel == NULL) &#123;</span><br><span class="line">        doThrowNPE(env);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    SurfaceControl* const self = reinterpret_cast&lt;SurfaceControl *&gt;(nativeObject);</span><br><span class="line">    if (self != nullptr) &#123;</span><br><span class="line">        self-&gt;writeToParcel(parcel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static jlong nativeReadFromParcel(JNIEnv* env, jclass clazz, jobject parcelObj) &#123;</span><br><span class="line">    Parcel* parcel = parcelForJavaObject(env, parcelObj);</span><br><span class="line">    if (parcel == NULL) &#123;</span><br><span class="line">        doThrowNPE(env);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;SurfaceControl&gt; surface = SurfaceControl::readFromParcel(parcel);</span><br><span class="line">    if (surface == nullptr) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    surface-&gt;incStrong((void *)nativeCreate);</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>PackageInstaller</title>
    <url>//pages/762af4/</url>
    <content><![CDATA[<h2 id="PackageInstallerService"><a href="#PackageInstallerService" class="headerlink" title="PackageInstallerService"></a>PackageInstallerService</h2><p>PackageInstallerService的初始化是在PKMS的构造函数中跟着一起初始化的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public PackageManagerService(Injector injector, boolean onlyCore, boolean factoryTest) &#123;</span><br><span class="line">    //......</span><br><span class="line">        mInstallerService = new PackageInstallerService(mContext, this, apexParserSupplier);        </span><br><span class="line">        //......</span><br><span class="line">    //......            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>应用层安装apk，调用PackageInstaller的commit。</p>
<p>app端主要逻辑是通过PackageInstaller创建一个Session，然后openSession，通过session拿到输出流，<br>将apk文件写入到session，最后进行commit。</p>
<p>在framework中的安装流程，主要从Session开始，客户端的session对应framework中的服务端PackageInstallerSession<br>来看看PackageInstallerSession的commit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void commit(@NonNull IntentSender statusReceiver, boolean forTransfer) &#123;</span><br><span class="line">    if (hasParentSessionId()) &#123;</span><br><span class="line">        throw new IllegalStateException(</span><br><span class="line">                &quot;Session &quot; + sessionId + &quot; is a child of multi-package session &quot;</span><br><span class="line">                        + mParentSessionId +  &quot; and may not be committed directly.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里会去更新一些session的全局变量，主要是回调的intentSender</span><br><span class="line">    if (!markAsSealed(statusReceiver, forTransfer)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (isMultiPackage()) &#123;</span><br><span class="line">        final SparseIntArray remainingSessions = mChildSessionIds.clone();</span><br><span class="line">        final IntentSender childIntentSender =</span><br><span class="line">                new ChildStatusIntentReceiver(remainingSessions, statusReceiver)</span><br><span class="line">                        .getIntentSender();</span><br><span class="line">        boolean sealFailed = false;</span><br><span class="line">        for (int i = mChildSessionIds.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            final int childSessionId = mChildSessionIds.keyAt(i);</span><br><span class="line">            // seal all children, regardless if any of them fail; we&#x27;ll throw/return</span><br><span class="line">            // as appropriate once all children have been processed</span><br><span class="line">            if (!mSessionProvider.getSession(childSessionId)</span><br><span class="line">                    .markAsSealed(childIntentSender, forTransfer)) &#123;</span><br><span class="line">                sealFailed = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sealFailed) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //一般都是直接安装apk</span><br><span class="line">    dispatchStreamValidateAndCommit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一系列handler调用，其中有一个validateApkInstallLocked()会收集一些apk的信息，<br>handler一系列调用最后会走到handleInstall(),单个apk安装走installNonStagedLocked():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void handleInstall() &#123;</span><br><span class="line">    if (isInstallerDeviceOwnerOrAffiliatedProfileOwnerLocked()) &#123;</span><br><span class="line">        DevicePolicyEventLogger</span><br><span class="line">                .createEvent(DevicePolicyEnums.INSTALL_PACKAGE)</span><br><span class="line">                .setAdmin(mInstallSource.installerPackageName)</span><br><span class="line">                .write();</span><br><span class="line">    &#125;</span><br><span class="line">    if (params.isStaged) &#123;</span><br><span class="line">        mStagingManager.commitSession(this);</span><br><span class="line">        destroyInternal();</span><br><span class="line">        dispatchSessionFinished(PackageManager.INSTALL_SUCCEEDED, &quot;Session staged&quot;, null);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isApexInstallation()) &#123;</span><br><span class="line">        destroyInternal();</span><br><span class="line">        dispatchSessionFinished(PackageManager.INSTALL_FAILED_INTERNAL_ERROR,</span><br><span class="line">                &quot;APEX packages can only be installed using staged sessions.&quot;, null);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // For a multiPackage session, read the child sessions</span><br><span class="line">    // outside of the lock, because reading the child</span><br><span class="line">    // sessions with the lock held could lead to deadlock</span><br><span class="line">    // (b/123391593).</span><br><span class="line">    List&lt;PackageInstallerSession&gt; childSessions = getChildSessionsNotLocked();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            //直接安装apk</span><br><span class="line">            installNonStagedLocked(childSessions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">        final String completeMsg = ExceptionUtils.getCompleteMessage(e);</span><br><span class="line">        Slog.e(TAG, &quot;Commit of session &quot; + sessionId + &quot; failed: &quot; + completeMsg);</span><br><span class="line">        destroyInternal();</span><br><span class="line">        dispatchSessionFinished(e.error, completeMsg, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void installNonStagedLocked(List&lt;PackageInstallerSession&gt; childSessions)</span><br><span class="line">        throws PackageManagerException &#123;</span><br><span class="line">    //makeSessionActiveLocked去搜集当前session的信息，封装成ActiveInstallSession</span><br><span class="line">    final PackageManagerService.ActiveInstallSession installingSession =</span><br><span class="line">            makeSessionActiveLocked();</span><br><span class="line">    if (installingSession == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (isMultiPackage()) &#123;</span><br><span class="line">        List&lt;PackageManagerService.ActiveInstallSession&gt; installingChildSessions =</span><br><span class="line">                new ArrayList&lt;&gt;(childSessions.size());</span><br><span class="line">        boolean success = true;</span><br><span class="line">        PackageManagerException failure = null;</span><br><span class="line">        for (int i = 0; i &lt; childSessions.size(); ++i) &#123;</span><br><span class="line">            final PackageInstallerSession session = childSessions.get(i);</span><br><span class="line">            try &#123;</span><br><span class="line">                final PackageManagerService.ActiveInstallSession installingChildSession =</span><br><span class="line">                        session.makeSessionActiveLocked();</span><br><span class="line">                if (installingChildSession != null) &#123;</span><br><span class="line">                    installingChildSessions.add(installingChildSession);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">                failure = e;</span><br><span class="line">                success = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            sendOnPackageInstalled(mContext, mRemoteStatusReceiver, sessionId,</span><br><span class="line">                    isInstallerDeviceOwnerOrAffiliatedProfileOwnerLocked(), userId, null,</span><br><span class="line">                    failure.error, failure.getLocalizedMessage(), null);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mPm.installStage(installingChildSessions);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //直接安装apk是调用的PMS的installStage</span><br><span class="line">        mPm.installStage(installingSession);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看PMS中的installStage做了什么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void installStage(ActiveInstallSession activeInstallSession) &#123;</span><br><span class="line">    //......</span><br><span class="line">    </span><br><span class="line">    final Message msg = mHandler.obtainMessage(INIT_COPY);</span><br><span class="line">    //将activeInstallSession封装成HandlerParams的子类InstallParams</span><br><span class="line">    final InstallParams params = new InstallParams(activeInstallSession);</span><br><span class="line">    params.setTraceMethod(&quot;installStage&quot;).setTraceCookie(System.identityHashCode(params));</span><br><span class="line">    msg.obj = params;</span><br><span class="line"></span><br><span class="line">    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;installStage&quot;,</span><br><span class="line">            System.identityHashCode(msg.obj));</span><br><span class="line">    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;queueInstall&quot;,</span><br><span class="line">            System.identityHashCode(msg.obj));</span><br><span class="line"></span><br><span class="line">    //发送了一个INIT_COPY消息给PMS的handler，在handler中执行params.startCopy();</span><br><span class="line">    mHandler.sendMessage(msg);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private abstract class HandlerParams &#123;</span><br><span class="line">    final void startCopy() &#123;</span><br><span class="line">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy &quot; + mUser + &quot;: &quot; + this);</span><br><span class="line">        handleStartCopy();</span><br><span class="line">        handleReturnCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract void handleStartCopy();</span><br><span class="line">    abstract void handleReturnCode();        </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">class InstallParams extends HandlerParams &#123;</span><br><span class="line">    public void handleStartCopy() &#123;</span><br><span class="line">        //......</span><br><span class="line">        PackageInfoLite pkgLite = null;</span><br><span class="line"></span><br><span class="line">        //会去根据文件路径进行一次apk解析</span><br><span class="line">        pkgLite = PackageManagerServiceUtils.getMinimalPackageInfo(mContext,</span><br><span class="line">                origin.resolvedPath, installFlags, packageAbiOverride);     </span><br><span class="line">        //......</span><br><span class="line">                //根据参数信息判断安装的位置</span><br><span class="line">                loc = installLocationPolicy(pkgLite);                   </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>INIT_COPY  params.startCopy() 中 对param进行初始化</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>SettingsProvider</title>
    <url>/2024/07/12/android_fw/72.SettingsProvider/</url>
    <content><![CDATA[<p>SettingsProvier 读写值接口比较简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings.Global.putInt(getContentResolver(),&quot;xxx&quot;, 1);</span><br><span class="line">Settings.Global.getInt(getContentResolver(),&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>
<p>主要看看实现过程,不管get&#x2F;put的是什么类型，内部是调用的string类型的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int getInt(ContentResolver cr, String name)</span><br><span class="line">        throws SettingNotFoundException &#123;</span><br><span class="line">    String v = getString(cr, name);</span><br><span class="line">    try &#123;</span><br><span class="line">        return Integer.parseInt(v);</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        throw new SettingNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getString(ContentResolver resolver, String name) &#123;</span><br><span class="line">    return getStringForUser(resolver, name, resolver.getUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** @hide */</span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">public static String getStringForUser(ContentResolver resolver, String name,</span><br><span class="line">        int userHandle) &#123;</span><br><span class="line">    if (MOVED_TO_SECURE.contains(name)) &#123;</span><br><span class="line">        Log.w(TAG, &quot;Setting &quot; + name + &quot; has moved from android.provider.Settings.Global&quot;</span><br><span class="line">                + &quot; to android.provider.Settings.Secure, returning read-only value.&quot;);</span><br><span class="line">        return Secure.getStringForUser(resolver, name, userHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    return sNameValueCache.getStringForUser(resolver, name, userHandle);</span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line">/** @hide */</span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">public static boolean putStringForUser(@NonNull ContentResolver resolver,</span><br><span class="line">        @NonNull String name, @Nullable String value, @Nullable String tag,</span><br><span class="line">        boolean makeDefault, @UserIdInt int userHandle, boolean overrideableByRestore) &#123;</span><br><span class="line">    if (MOVED_TO_GLOBAL.contains(name)) &#123;</span><br><span class="line">        Log.w(TAG, &quot;Setting &quot; + name + &quot; has moved from android.provider.Settings.Secure&quot;</span><br><span class="line">                + &quot; to android.provider.Settings.Global&quot;);</span><br><span class="line">        return Global.putStringForUser(resolver, name, value,</span><br><span class="line">                tag, makeDefault, userHandle, DEFAULT_OVERRIDEABLE_BY_RESTORE);</span><br><span class="line">    &#125;</span><br><span class="line">    return sNameValueCache.putStringForUser(resolver, name, value, tag,</span><br><span class="line">            makeDefault, userHandle, overrideableByRestore);</span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean putStringForUser(ContentResolver cr, String name, String value,</span><br><span class="line">        String tag, boolean makeDefault, final int userHandle,</span><br><span class="line">        boolean overrideableByRestore) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Bundle arg = new Bundle();</span><br><span class="line">        arg.putString(Settings.NameValueTable.VALUE, value);</span><br><span class="line">        arg.putInt(CALL_METHOD_USER_KEY, userHandle);</span><br><span class="line">        if (tag != null) &#123;</span><br><span class="line">            arg.putString(CALL_METHOD_TAG_KEY, tag);</span><br><span class="line">        &#125;</span><br><span class="line">        if (makeDefault) &#123;</span><br><span class="line">            arg.putBoolean(CALL_METHOD_MAKE_DEFAULT_KEY, true);</span><br><span class="line">        &#125;</span><br><span class="line">        if (overrideableByRestore) &#123;</span><br><span class="line">            arg.putBoolean(CALL_METHOD_OVERRIDEABLE_BY_RESTORE_KEY, true);</span><br><span class="line">        &#125;</span><br><span class="line">        IContentProvider cp = mProviderHolder.getProvider(cr);</span><br><span class="line">        //拿到SettingsProvider的ContentProvider，调用call接口</span><br><span class="line">        cp.call(cr.getPackageName(), cr.getAttributionTag(),</span><br><span class="line">                mProviderHolder.mUri.getAuthority(), mCallSetCommand, name, arg);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        Log.w(TAG, &quot;Can&#x27;t set key &quot; + name + &quot; in &quot; + mUri, e);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;             </span><br></pre></td></tr></table></figure>

<p>所以真正的实现在SettingsProvider中，调用其call方法，从传过来的bundle中取出值，<br>先写到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean insertSettingLocked(int type, int userId, String name, String value,</span><br><span class="line">        String tag, boolean makeDefault, boolean forceNonSystemPackage, String packageName,</span><br><span class="line">        boolean forceNotify, Set&lt;String&gt; criticalSettings, boolean overrideableByRestore) &#123;</span><br><span class="line">    if (overrideableByRestore != Settings.DEFAULT_OVERRIDEABLE_BY_RESTORE) &#123;</span><br><span class="line">        getContext().enforceCallingOrSelfPermission(</span><br><span class="line">                Manifest.permission.MODIFY_SETTINGS_OVERRIDEABLE_BY_RESTORE,</span><br><span class="line">                &quot;Caller is not allowed to modify settings overrideable by restore&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final int key = makeKey(type, userId);</span><br><span class="line"></span><br><span class="line">    boolean success = false;</span><br><span class="line">    SettingsState settingsState = peekSettingsStateLocked(key);</span><br><span class="line">    if (settingsState != null) &#123;</span><br><span class="line">        //这里会先写到map中，然后丢给handler异步处理</span><br><span class="line">        success = settingsState.insertSettingLocked(name, value,</span><br><span class="line">                tag, makeDefault, forceNonSystemPackage, packageName, overrideableByRestore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (success &amp;&amp; criticalSettings != null &amp;&amp; criticalSettings.contains(name)) &#123;</span><br><span class="line">        settingsState.persistSyncLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (forceNotify || success) &#123;</span><br><span class="line">        notifyForSettingsChange(key, name);</span><br><span class="line">    &#125;</span><br><span class="line">    return success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>分屏</title>
    <url>//pages/c10468/</url>
    <content><![CDATA[<h2 id="官方关于分屏的介绍"><a href="#官方关于分屏的介绍" class="headerlink" title="官方关于分屏的介绍"></a>官方关于分屏的介绍</h2><p>官方支持 <a href="https://source.android.google.cn/docs/core/display/multi-window?hl=zh-cn">Multi-Window</a><br>多窗口分为3种：</p>
<ul>
<li>分屏(Split-screen)</li>
<li>自由窗口(Freeform)</li>
<li>画中画(Picture-in-picture (PIP))</li>
</ul>
<h2 id="系统对多窗口的支持"><a href="#系统对多窗口的支持" class="headerlink" title="系统对多窗口的支持"></a>系统对多窗口的支持</h2><p>在ATMS中,主要判断是否是低内存设备，以及是否在xml中配置config_supportsMultiWindow为true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns true if the system supports at least one form of multi-window.</span><br><span class="line"> * E.g. freeform, split-screen, picture-in-picture.</span><br><span class="line"> */</span><br><span class="line">public static boolean supportsMultiWindow(Context context) &#123;</span><br><span class="line">    // On watches, multi-window is used to present essential system UI, and thus it must be</span><br><span class="line">    // supported regardless of device memory characteristics.</span><br><span class="line">    boolean isWatch = context.getPackageManager().hasSystemFeature(</span><br><span class="line">            PackageManager.FEATURE_WATCH);</span><br><span class="line">    return (!ActivityManager.isLowRamDeviceStatic() || isWatch)</span><br><span class="line">            &amp;&amp; Resources.getSystem().getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_supportsMultiWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>PreferenceScreen-Android Settings</title>
    <url>//pages/e24f7c/</url>
    <content><![CDATA[<h2 id="什么是PreferenceScreen"><a href="#什么是PreferenceScreen" class="headerlink" title="什么是PreferenceScreen"></a>什么是PreferenceScreen</h2><p><a href="https://developer.android.google.cn/reference/kotlin/androidx/preference/PreferenceScreen">PreferenceScreen</a>是一个包含设置控件的最顶层容器，如果要使用Android原生的设置控件，XML布局中的根标签必须是<code>&lt;PreferenceScreen&gt;</code>，并且XML布局必须放在res&#x2F;xml&#x2F;目录中[<a href="https://developer.android.google.cn/develop/ui/views/components/settings#create_a_hierarchy">参考官网</a>]</p>
<p><strong>使用PreferenceScreen来布局设置页面，十分方便，基本上只需要配置好xml布局就行了，状态值设置不需要开发者进行处理，各控件内部通过SharedPreferences来进行保存的，可以直接通过sp进行取值操作。</strong></p>
<h2 id="相关控件"><a href="#相关控件" class="headerlink" title="相关控件"></a>相关控件</h2><p>官网有<a href="https://developer.android.google.cn/develop/ui/views/components/settings/components-and-attributes#preference_components">各控件的说明</a>，这里列出常用的控件</p>
<ul>
<li>PreferenceFragmentCompat ——用于处理偏好设置的fragment，要使用原生设置控件需要自定义一个子类继承该类</li>
<li>PreferenceScreen——包含设置控件的最顶层容器</li>
<li>PreferenceCategory——用于对相似的选项进行分组的容器。显示类别标题，并以明显的布局将选项组分开。</li>
<li>Preference——表示单个设置选项的基本构件。如果将Preference设置为persist，则它具有相应的键-值对，其中包含用户对设置的选择，可以在应用程序的其他地方访问该设置。</li>
<li>EditTextPreference ——保存String值的选项。用户点击选项弹出一个对话框，对话框显示一个编辑框（用于用户修改选项值）</li>
<li>SwitchPreferenceCompat——保存一个布尔值的选项。</li>
</ul>
<h2 id="控件属性值"><a href="#控件属性值" class="headerlink" title="控件属性值"></a>控件属性值</h2><p>官网有<a href="https://developer.android.google.cn/develop/ui/views/components/settings/components-and-attributes#preference_attributes">详细说明</a></p>
<ul>
<li><p>title</p>
<p>选项标题</p>
</li>
<li><p>summary</p>
<p>选项的说明摘要</p>
</li>
<li><p>icon</p>
<p>选项图标</p>
</li>
<li><p>key</p>
<p>表示用于持久化存储选项值的key。可以通过key取到对应的选项控件，进行自定义操作。官方建议为层次结构中的每个Preference设置一个键。</p>
</li>
<li><p>enabled</p>
<p>控制用户是否可以与选项交互的布尔值。当该值为false时，选项显示为灰色，用户无法与之交互。默认值为true。</p>
</li>
<li><p>selectable</p>
<p>控制用户是否可以点击该选项，默认为true</p>
</li>
<li><p>isPreferenceVisible</p>
<p>控制选项或选项组是否可见。等价于代码调用setVisible()。</p>
</li>
<li><p>defaultValue</p>
<p>选项的默认值。值类型取决于选项类型</p>
</li>
<li><p>dependency</p>
<p>此选项依赖的SwitchPreferenceCompat的key。当相应的开关关闭时，该选项将被禁用，并且不能被修改。</p>
</li>
</ul>
<h2 id="获取设置选项存储的值"><a href="#获取设置选项存储的值" class="headerlink" title="获取设置选项存储的值"></a>获取设置选项存储的值</h2><p>默认情况下，选项值使用SharedPreferences进行保存的</p>
<p>所以要获取选项设置的值，可以通过PreferenceManager.getDefaultSharedPreferences()获取到sp对象，然后通过sp去取值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);</span><br><span class="line">String name = sharedPreferences.getString(“signature”, &quot;&quot;);</span><br></pre></td></tr></table></figure>

<p>另外官方提供了<a href="https://developer.android.google.cn/develop/ui/views/components/settings/use-saved-values#custom-data-store">自定义数据存储方式</a></p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>xml页面如下，<code>root_preferences.xml</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;PreferenceScreen xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;PreferenceCategory app:title=&quot;设置分组1&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--    跳转到指定的fragment    --&gt;</span><br><span class="line">        &lt;Preference</span><br><span class="line">            app:fragment=&quot;com.omosoft.localtest.module.settings.SettingsActivity$ServiceFragment&quot;</span><br><span class="line">            app:key=&quot;goup1_key1&quot;</span><br><span class="line">            app:summary=&quot;跳转选项1设置页面&quot;</span><br><span class="line">            app:title=&quot;选项1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Preference</span><br><span class="line">            app:key=&quot;group1_key2&quot;</span><br><span class="line">            app:selectable=&quot;false&quot;</span><br><span class="line">            app:summary=&quot;selectable=false&quot;</span><br><span class="line">            app:title=&quot;选项2&quot; /&gt;</span><br><span class="line">        &lt;Preference</span><br><span class="line">            app:enabled=&quot;false&quot;</span><br><span class="line">            app:key=&quot;group1_key3&quot;</span><br><span class="line">            app:summary=&quot;enabled=false&quot;</span><br><span class="line">            app:title=&quot;选项3&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/PreferenceCategory&gt;</span><br><span class="line"></span><br><span class="line">    &lt;PreferenceCategory</span><br><span class="line">        app:initialExpandedChildrenCount=&quot;6&quot;</span><br><span class="line">        app:title=&quot;设置分组2&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;SwitchPreferenceCompat</span><br><span class="line">            app:defaultValue=&quot;true&quot;</span><br><span class="line">            app:key=&quot;group2_switch&quot;</span><br><span class="line">            app:summary=&quot;SwitchPreferenceCompat&quot;</span><br><span class="line">            app:title=&quot;设置开关&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--    通过dependency指定依赖的开关是选项1，只有选项1打开才能设置选项2    --&gt;</span><br><span class="line">        &lt;EditTextPreference</span><br><span class="line">            app:defaultValue=&quot;默认值&quot;</span><br><span class="line">            app:dependency=&quot;group2_switch&quot;</span><br><span class="line">            app:key=&quot;group2_name&quot;</span><br><span class="line">            app:useSimpleSummaryProvider=&quot;true&quot;</span><br><span class="line">            app:summary=&quot;EditTextPreference&quot;</span><br><span class="line">            app:title=&quot;姓名&quot; /&gt;</span><br><span class="line">        &lt;!--    单选列表    --&gt;</span><br><span class="line">        &lt;ListPreference</span><br><span class="line">            app:dependency=&quot;group2_switch&quot;</span><br><span class="line">            app:entries=&quot;@array/sex_entries&quot;</span><br><span class="line">            app:entryValues=&quot;@array/sex_values&quot;</span><br><span class="line">            app:key=&quot;group2_sex&quot;</span><br><span class="line">            app:useSimpleSummaryProvider=&quot;true&quot;</span><br><span class="line">            app:summary=&quot;性别&quot;</span><br><span class="line">            app:title=&quot;列表选项(单选)&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--  多选列表     --&gt;</span><br><span class="line">        &lt;MultiSelectListPreference</span><br><span class="line">            app:dependency=&quot;group2_switch&quot;</span><br><span class="line">            app:entries=&quot;@array/hobby_entries&quot;</span><br><span class="line">            app:entryValues=&quot;@array/hobby_values&quot;</span><br><span class="line">            app:key=&quot;group2_hobby&quot;</span><br><span class="line">            app:summary=&quot;爱好&quot;</span><br><span class="line">            app:title=&quot;列表选项(多选)&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/PreferenceCategory&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/PreferenceScreen&gt;</span><br></pre></td></tr></table></figure>

<p>对应的SettingsFragment如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SettingsActivity extends AppCompatActivity implements PreferenceFragmentCompat.OnPreferenceStartFragmentCallback &#123;</span><br><span class="line">    public static final String TAG = &quot;SettingsActivity&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.settings_activity);</span><br><span class="line">        if (savedInstanceState == null) &#123;</span><br><span class="line">            getSupportFragmentManager()</span><br><span class="line">                    .beginTransaction()</span><br><span class="line">                    .replace(R.id.settings, new SettingsFragment())</span><br><span class="line">                    .commit();</span><br><span class="line">        &#125;</span><br><span class="line">        ActionBar actionBar = getSupportActionBar();</span><br><span class="line">        if (actionBar != null) &#123;</span><br><span class="line">            actionBar.setDisplayHomeAsUpEnabled(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class SettingsFragment extends PreferenceFragmentCompat &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCreatePreferences(Bundle savedInstanceState, String rootKey) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onCreatePreferences: &quot; + getClass());</span><br><span class="line">            //加载xml资源</span><br><span class="line">            setPreferencesFromResource(R.xml.root_preferences, rootKey);</span><br><span class="line"></span><br><span class="line">            //初始化选项，通过findPreference找到指定key的选项进行操作</span><br><span class="line">            EditTextPreference etPref = findPreference(&quot;group2_name&quot;);</span><br><span class="line">            if (etPref != null) &#123;</span><br><span class="line">                String text = etPref.getText();</span><br><span class="line">                Toast.makeText(getContext(), text, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class ServiceFragment extends PreferenceFragmentCompat &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCreatePreferences(Bundle savedInstanceState, String rootKey) &#123;</span><br><span class="line">            setPreferencesFromResource(R.xml.service_perferences, rootKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onPreferenceStartFragment(PreferenceFragmentCompat caller, Preference pref) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onPreferenceStartFragment: caller = &quot; + caller.toString() + &quot;, pref = &quot; + pref.toString() + &quot;,&quot; + pref.getFragment());</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下:</br><br><img src="/imgs/02_01_root_preferences.png" width="300" height="auto"/></p>
]]></content>
  </entry>
  <entry>
    <title>EditText</title>
    <url>//pages/cf392f/</url>
    <content><![CDATA[<p><a href="https://github.com/itgoyo/AndroidSource-Analysis/blob/master/chapter1/TextView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">https://github.com/itgoyo/AndroidSource-Analysis/blob/master/chapter1/TextView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md</a></p>
<h2 id="EditText继承自TextView"><a href="#EditText继承自TextView" class="headerlink" title="EditText继承自TextView"></a>EditText继承自TextView</h2><p>TextView中有一些辅助类</p>
<ul>
<li>一个Editor对象                mEditor<br>  TextView作为可编辑文本控件的时候(EditText)，使用Editor来处理文本的区域选择处理和判断、拼写检查、弹出文本菜单等。</li>
<li>一个Layout对象                mLayout<br>  TextView的文字排版、折行策略以及文本绘制都是在Layout里面完成的，TextView的自身测量也受Layout的影响。Layout是TextView执行setText方法后，由TextView内部创建的实例，并不能由外部提供。可以用getLayout()方法获取。</li>
<li>一个TransformationMethod对象  mTransformation<br>  用来处理最终的显示结果的类，例如显示密码的时候把密码转换成圆点。这个类并不直接影响TextView内部储存的Text，只影响显示的结果。</li>
<li>一个MovementMethod对象        mMovement<br>  用来处理TextView内部事件响应的类，可以针对TextView内文本的某一个区域做软键盘输入或者触摸事件的响应。</li>
<li>一个Drawables对象             mDrawables<br>  TextView的静态内部类，用来处理和储存TextView的CompoundDrawables,包括TextView的上下左右的Drawable以及错误提示的Drawable。</li>
<li>InputConnection<br>  EditText的文本输入部分是在TextView中完成的。而InputConnection是软键盘和TextView之间的桥梁，所有的软键盘的输入文字、修改文字和删除文字都是通过InputConnection传递给TextView的。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>博客搭建</title>
    <url>//pages/d60c31/</url>
    <content><![CDATA[<h1 id="使用VuePress搭建博客"><a href="#使用VuePress搭建博客" class="headerlink" title="使用VuePress搭建博客"></a>使用VuePress搭建博客</h1><p>VuePress依赖NodeJs环境</p>
<p>参考: <a href="https://vuepress.vuejs.org/zh/guide/getting-started.html">VuePress中文网 快速上手</a></p>
<ol>
<li><p>下载安装NodeJs ：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>
<p> 压缩包解压安装的需要自己配环境变量</p>
</li>
</ol>
<p>换源 <a href="https://www.cnblogs.com/treasury/p/12793253.html">https://www.cnblogs.com/treasury/p/12793253.html</a><br>npm config get registry<br>npm config set registry&#x3D;<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com/</a><br>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
<ol start="2">
<li><p>创建一个目录作为项目根目录，并简单配置，快速启动一个本地服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.创建一个目录作为项目根目录，进入根目录</span><br><span class="line">mkdir vuepress-starter &amp;&amp; cd vuepress-starter</span><br><span class="line"># 2.通过npm初始化项目</span><br><span class="line">npm init -y</span><br><span class="line"># 3. 在项目中添加vuepress模块和vuepress-theme-vdoing（vuepress的一个主题）</span><br><span class="line">npm install vuepress</span><br><span class="line">npm install vuepress-theme-vdoing</span><br><span class="line"># 4. 创建第一篇文档</span><br><span class="line">mkdir docs &amp;&amp; echo &#x27;# Hello VuePress&#x27; &gt; docs/README.md</span><br><span class="line"># 5. 在项目根目录下的package.json中添加脚本指令</span><br><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,</span><br><span class="line">    &quot;docs:build&quot;: &quot;vuepress build docs&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 6. 启动本地服务</span><br><span class="line">npm run docs:dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些简单配置（端口，标题等）</p>
</li>
</ol>
<p>vuepress的配置需要在docs目录下创建一个.vuepress目录，所有的配置文件放在.vuepress中</p>
<ul>
<li>docs&#x2F;.vuepress&#x2F;config.js: 配置文件的入口文件，也可以是 YML 或 toml。</li>
<li>docs&#x2F;.vuepress&#x2F;public: 静态资源目录。</li>
</ul>
<p>创建.vuepress目录和静态资源目录，将一些图片资源放到public目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd vuepress-starter/docs</span><br><span class="line">mkdir -p .vuepress/public</span><br></pre></td></tr></table></figure>

<p>在.vuepress中创建config.js,在config.js中对vuepress进行简单配置</p>
<p>config.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    host:&quot;localhost&quot;,</span><br><span class="line">    port:&quot;80&quot;,</span><br><span class="line">    title: &quot;Fireflies&#x27;s blog&quot;,</span><br><span class="line">    // &lt;head&gt; 标签内容</span><br><span class="line">    head:[</span><br><span class="line">        [&#x27;link&#x27;, &#123; rel: &#x27;icon&#x27;, href: &#x27;/imgs/ico.jpg&#x27; &#125;]</span><br><span class="line">    ],</span><br><span class="line">    description: &quot;&quot;,</span><br><span class="line">    theme:&quot;vdoing&quot;,//主题</span><br><span class="line">    // 主题配置</span><br><span class="line">    themeConfig:&#123;</span><br><span class="line">        // 默认不自动生成category 和 tag</span><br><span class="line">        category: false,</span><br><span class="line">        tag: false,</span><br><span class="line">        // 侧边栏[自动生成结构化侧边栏，默认可折叠]，目录页数据需要依赖于结构化的侧边栏数据</span><br><span class="line">        sidebar: &#x27;structuring&#x27;,</span><br><span class="line">        // 页脚版权配置</span><br><span class="line">        footer:&#123;</span><br><span class="line">            createYear:2022,</span><br><span class="line">            copyrightInfo: &quot;Fireflies&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>主页配置</li>
</ol>
<p>编辑<code>docs/README.md</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">home: true</span><br><span class="line"># heroImage: /imgs/test.jpg</span><br><span class="line">heroText: Fireflies&#x27;s blog</span><br><span class="line">tagline: null #副标题</span><br><span class="line"># actionText: 快速上手 →</span><br><span class="line"># actionLink: /zh/guide/</span><br><span class="line">features:</span><br><span class="line">- title: 标题1</span><br><span class="line">  details: 描述1</span><br><span class="line">  link: /catelogue/test #链接跳转的文件</span><br><span class="line">- title: 标题2</span><br><span class="line">  details: 描述2</span><br><span class="line">  link: /catelogue/test2 #链接跳转的文件</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>目录配置<br>关于文件及目录命名规范：<a href="https://doc.xugaoyi.com/pages/33d574/#%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A">vdoing命名约定</a></li>
</ol>
<p>在docs目录下创建一个文件夹用来放目录文件（00.目录）</p>
<p>在<code>00.目录</code>下创建一个目录文件，如<code>01.test.md</code>,创建一个目录用来存放该对应目录下的文件,如<code>00.目录</code>同级的目录<code>01.test</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">pageComponent:</span><br><span class="line">  name: Catalogue</span><br><span class="line">  data:</span><br><span class="line">    path: 01.test # 设置为`docs/`下面的某个文件夹相对路径</span><br><span class="line">    imgUrl: null</span><br><span class="line">    description: 描述</span><br><span class="line">title: 目录标题</span><br><span class="line">date: 2020-03-11 21:50:53</span><br><span class="line">permalink: /catelogue/test #该目录的永久链接</span><br><span class="line">sidebar: false # 不显示侧边栏</span><br><span class="line">article: false # 不是文章页 (不显示面包屑栏、最近更新栏等)</span><br><span class="line">comment: false # 不显示评论栏</span><br><span class="line">editLink: false # 不显示编辑按钮</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>后续向<code>01.test</code>目录下添加文件，运行服务时会自动生成目录页数据</p>
<h2 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h2><h3 id="添加-vuepress-plugin-mermaidjs"><a href="#添加-vuepress-plugin-mermaidjs" class="headerlink" title="添加 vuepress-plugin-mermaidjs"></a>添加 vuepress-plugin-mermaidjs</h3><p><a href="https://vuepress-plugin-mermaidjs.efrane.com/">documentation</a><br>安装插件时必须指定具体的版本号，否则默认会安装最新版本的插件，最新版本不兼容 VuePres 1.x</p>
<ol>
<li>npm install <a href="mailto:&#118;&#x75;&#x65;&#x70;&#x72;&#101;&#115;&#x73;&#45;&#x70;&#x6c;&#x75;&#x67;&#105;&#x6e;&#x2d;&#x6d;&#101;&#114;&#x6d;&#97;&#105;&#100;&#106;&#115;&#64;&#49;&#46;&#57;&#x2e;&#49;">&#118;&#x75;&#x65;&#x70;&#x72;&#101;&#115;&#x73;&#45;&#x70;&#x6c;&#x75;&#x67;&#105;&#x6e;&#x2d;&#x6d;&#101;&#114;&#x6d;&#97;&#105;&#100;&#106;&#115;&#64;&#49;&#46;&#57;&#x2e;&#49;</a></li>
<li>在.vuepress&#x2F;config.js中注册插件  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">      &#x27;vuepress-plugin-mermaidjs&#x27;</span><br><span class="line">  ]</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="使用hexo搭建博客"><a href="#使用hexo搭建博客" class="headerlink" title="使用hexo搭建博客"></a>使用hexo搭建博客</h1><p>参考：<a href="https://blog.csdn.net/weixin_45631738/article/details/104716374">https://blog.csdn.net/weixin_45631738/article/details/104716374</a><br>  前置条件和VuePress搭建博客流程相差不大，都是先安装NodeJs和git</p>
<ol>
<li><p>先本地搭好环境，创建一个目录作为项目根目录，进行简单配置，快速启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. 创建一个目录，在目录下局部安装hexo</span><br><span class="line">mkdir hexo-starter </span><br><span class="line">npm install hexo</span><br><span class="line"># 2.在myblog中初始化hexo，目录需要是一个空目录，这个目录作为blog源码的根目录</span><br><span class="line">npx hexo init myblog</span><br><span class="line"># 3.进入myblog</span><br><span class="line">cd myblog</span><br><span class="line"># 4.然后可以启动hexo的server看看效果</span><br><span class="line">npx hexo server</span><br></pre></td></tr></table></figure>
</li>
<li><p>在github上创建一个私有仓库hexo-blog用来存放博客源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://github.com/FirefliesL/hexo-blog.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
</li>
<li><p>在github上创建一个公开仓库用来存放博客编译后的静态资源</p>
</li>
<li><p>在本地对hexo-blog这个博客源码中的<code>_config.yml</code>进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先安装hexo-deployer-git</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>在 <code>_config.yml</code> 中对 deploy 部分进行配置，指定要部署的仓库地址 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repo: https://github.com/FirefliesL/Firefies.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置好之后在本地博客源码目录进行资源生成和部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd cd myblog</span><br><span class="line">npx hexo g</span><br><span class="line">npx hexo d</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署时，会自动将编译后的静态资源push到配置好的远程仓库</p>
</li>
<li><p>在远程仓库的<code>settings</code>–<code>Pages</code>配置好即可，<br>但实际发现资源加载错误，html没有样式，查阅官方文档后发现将仓库名称改为<code>&lt;username&gt;.github.io</code>即可</p>
</li>
</ol>
<h1 id="hexo配合GitHub-Action自动部署博客"><a href="#hexo配合GitHub-Action自动部署博客" class="headerlink" title="hexo配合GitHub Action自动部署博客"></a>hexo配合GitHub Action自动部署博客</h1><p>参考：<a href="https://cloud.tencent.com/developer/article/2201648">https://cloud.tencent.com/developer/article/2201648</a></p>
<p><a href="https://juejin.cn/post/6943895271751286821">https://juejin.cn/post/6943895271751286821</a></p>
<p><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/</a></p>
<ol>
<li><p>生成一个github的token</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">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</span><br></pre></td></tr></table></figure></li>
<li><p>在私有仓库（就是博客源码对应的远程仓库）中将token添加到secrets中</p>
</li>
<li><p>创建一个action<br>github 仓库页面选择actions – set up a workflow yourself </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Deploy My_Blog  #自动化的名称</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  # Triggers the workflow on push or pull request events but only for the main branch</span><br><span class="line">  push: # push的时候触发</span><br><span class="line">    branches: [ master ]  # 哪些分支需要触发</span><br><span class="line">  pull_request:  </span><br><span class="line">    branches: [ dev ]</span><br><span class="line"></span><br><span class="line"># A workflow run is made up of one or more jobs that can run sequentially or in parallel</span><br><span class="line">jobs:</span><br><span class="line">  # This workflow contains a single job called &quot;build&quot;</span><br><span class="line">  Blog_CI-CD:</span><br><span class="line">    runs-on: ubuntu-latest  # 服务器环境</span><br><span class="line">    # Steps represent a sequence of tasks that will be executed as part of the job</span><br><span class="line">    </span><br><span class="line">    steps:</span><br><span class="line">      # 检查代码</span><br><span class="line">      - name: Checkout</span><br><span class="line">        uses: actions/checkout@v2  #软件市场的名称</span><br><span class="line">        with: # 参数</span><br><span class="line">          submodules: true</span><br><span class="line">          persist-credentials: false</span><br><span class="line">          </span><br><span class="line">      - name: Setup Node.js</span><br><span class="line">       # 设置 node.js 环境</span><br><span class="line">        uses: actions/setup-node@v1</span><br><span class="line">        with:</span><br><span class="line">          node-version: &#x27;12&#x27;</span><br><span class="line">          </span><br><span class="line">      - name: Cache node modules</span><br><span class="line">      # 设置包缓存目录，避免每次下载</span><br><span class="line">        uses: actions/cache@v1</span><br><span class="line">        with:</span><br><span class="line">          path: ~/.npm</span><br><span class="line">          key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;</span><br><span class="line">          </span><br><span class="line">      # 配置Hexo环境 </span><br><span class="line">      - name: Setup Hexo</span><br><span class="line">        # env:</span><br><span class="line">        #   ACTION_DEPLOY_KEY: $&#123;&#123; secrets.HEXO_DEPLOY &#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          npm install hexo-cli -g</span><br><span class="line">          npm install</span><br><span class="line">           </span><br><span class="line">      </span><br><span class="line">      # 生成静态文件</span><br><span class="line">      - name: Build</span><br><span class="line">        run: |</span><br><span class="line">          hexo clean </span><br><span class="line">          hexo g</span><br><span class="line">        </span><br><span class="line">      # 2、部署到 GitHub Pages</span><br><span class="line">      - name: upload GitHub repository</span><br><span class="line">        env: </span><br><span class="line">          # Github 仓库</span><br><span class="line">          GITHUB_REPO: github.com/FirefliesL/firefliesl.github.io.git</span><br><span class="line">         # 将编译后的博客文件推送到指定仓库</span><br><span class="line">        run: |</span><br><span class="line">          cd ./public &amp;&amp; git init</span><br><span class="line">          git config user.name &quot;lifeifei&quot;</span><br><span class="line">          git config user.email &quot;771422461@qq.com&quot;</span><br><span class="line">          git add .</span><br><span class="line">          git commit -m &quot;GitHub Actions Auto Builder at $(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)&quot;</span><br><span class="line">          git push --force --quiet &quot;https://$&#123;&#123; secrets.HEXO_DEPLOY_TOKEN &#125;&#125;@$GITHUB_REPO&quot; master:master</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>这样每次push到master分支，就会触发action种的jobs，就会自动将编译后的静态资源push到公共仓库</p>
</li>
</ol>
<h2 id="hexo的一些简单配置"><a href="#hexo的一些简单配置" class="headerlink" title="hexo的一些简单配置"></a>hexo的一些简单配置</h2><p>配置文件是<code>_config.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Fireflies&#x27;s blog</span><br><span class="line">subtitle: &#x27;&#x27;</span><br><span class="line">description: &#x27;&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: Fireflies</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="hexo安装主题butterfly"><a href="#hexo安装主题butterfly" class="headerlink" title="hexo安装主题butterfly"></a>hexo安装主题butterfly</h2><ol>
<li>在blog根目录下安装hexo-theme-butterfly<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i hexo-theme-butterfly</span><br></pre></td></tr></table></figure></li>
<li>在<code>_config.yml</code>中配置启用主题<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure></li>
<li>butterfly的配置文件<br>通过npm安装的在node_modules –&gt; hexo-theme-butterfly目录下,<code>_config.yml</code><br>可以在在 hexo 的根目录创建一个文件 <code>_config.butterfly.yml</code>,用来重载默认的配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 网站图标，head标签</span><br><span class="line">favicon: /img/ico.jpg</span><br><span class="line"></span><br><span class="line"># Avatar (头像)</span><br><span class="line">avatar:</span><br><span class="line">  img: /img/avatar.jpg</span><br><span class="line">  effect: false</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><ol>
<li>生成标签页，会在<code>source</code>目录下生成 <code>tags/index.md</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></li>
<li>补全配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2023-09-21 15:52:48</span><br><span class="line"># 标签页面 type 必须为 tags</span><br><span class="line">type: tags</span><br><span class="line"># 指定排序</span><br><span class="line">orderby: name</span><br><span class="line">order: 1</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="分类页面"><a href="#分类页面" class="headerlink" title="分类页面"></a>分类页面</h3><ol>
<li>生成分类页，会在<code>source</code>目录下生成 <code>categories/index.md</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure></li>
<li>补全配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2023-09-21 16:05:05</span><br><span class="line"># 标签页面 type 必须为 categories</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[npx] hexo new [layout] &lt;title&gt; [-p 路径]</span><br></pre></td></tr></table></figure>

<p>详细的配置参考<a href="https://butterfly.js.org/posts/21cfbf15/">butterfly官方文档</a></p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://01cv.cn/">https://01cv.cn/</a></p>
<p><a href="https://developer.android.google.cn/develop/ui/views/layout/declaring-layout?hl=zh-cn">https://developer.android.google.cn/develop/ui/views/layout/declaring-layout?hl=zh-cn</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo-butterfly主题相关配置</title>
    <url>/2023/09/21/blog/hexo-butterfly%E4%B8%BB%E9%A2%98%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h1><p>hexo配置的默认端口是4000，要修改端口有2种方式</p>
<ol>
<li><p>修改默认端口<br>在<code>node_modules/hexo-server/index.js</code>中修改port</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo.config.server = Object.assign(&#123;</span><br><span class="line">  port: 4000, //这里就是默认端口</span><br><span class="line">  log: false,</span><br><span class="line">  // `undefined` uses Node&#x27;s default (try `::` with fallback to `0.0.0.0`)</span><br><span class="line">  ip: undefined,</span><br><span class="line">  compress: false,</span><br><span class="line">  header: true</span><br><span class="line">&#125;, hexo.config.server);</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务时指定端口号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server -p 8080</span><br></pre></td></tr></table></figure>
<p>可以在package.json中配置脚本，然后通过<code>npm run server</code>来启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;hexo generate&quot;,</span><br><span class="line">  &quot;clean&quot;: &quot;hexo clean&quot;,</span><br><span class="line">  &quot;deploy&quot;: &quot;hexo deploy&quot;,</span><br><span class="line">  &quot;server&quot;: &quot;hexo server -p 8080&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>hexo的配置文件是<code>_config.yml</code></p>
<p>另外通过npm安装的在<code>node_modules/hexo-theme-butterfly</code>目录下，有个<code>_config.yml</code>，<br>这个是主题相关的配置文件。可以在在 hexo 的根目录创建一个文件 <code>_config.butterfly.yml</code>，用来重载默认的配置</p>
<p><strong>后续说的网站配置文件指根目录下的<code>_config.yml</code>，主题配置文件指根目录下的 <code>_config.butterfly.yml</code></strong></p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>修改网站配置文件<code>_config.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure>

<h2 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h2><p>修改主题配置文件<code>_config.butterfly.yml</code></p>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nav:</span><br><span class="line">  logo: img/avatar.jpg # 导航栏的图标</span><br><span class="line">  display_title: true # 是否显示网站标题</span><br><span class="line">  fixed: false # 是否固定导航栏</span><br></pre></td></tr></table></figure>

<h3 id="目录-菜单"><a href="#目录-菜单" class="headerlink" title="目录&#x2F;菜单"></a>目录&#x2F;菜单</h3><p>修改主题配置文件<code>_config.butterfly.yml</code></p>
<p>格式为：路径||图标名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: / || fas fa-home</span><br><span class="line">  归档: /archives/ || fas fa-archive</span><br><span class="line">  标签: /tags/ || fas fa-tags</span><br><span class="line">  分类: /categories/ || fas fa-folder-open</span><br><span class="line">  # List||fas fa-list:</span><br><span class="line">  #   Music: /music/ || fas fa-music</span><br><span class="line">  #   Movie: /movies/ || fas fa-video</span><br><span class="line">  # Link: /link/ || fas fa-link</span><br><span class="line">  # About: /about/ || fas fa-heart</span><br></pre></td></tr></table></figure>


<h1 id="通用页面配置"><a href="#通用页面配置" class="headerlink" title="通用页面配置"></a>通用页面配置</h1><p>通用页面如：标签页、分类页</p>
<h2 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h2><ol>
<li>生成标签页，会在<code>source</code>目录下生成 <code>tags/index.md</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></li>
<li>补全配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2023-09-21 15:52:48</span><br><span class="line"># 标签页面 type 必须为 tags</span><br><span class="line">type: tags</span><br><span class="line"># 指定排序</span><br><span class="line">orderby: name</span><br><span class="line">order: 1</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="分类页面"><a href="#分类页面" class="headerlink" title="分类页面"></a>分类页面</h2><ol>
<li>生成分类页，会在<code>source</code>目录下生成 <code>categories/index.md</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure></li>
<li>补全配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2023-09-21 16:05:05</span><br><span class="line"># 标签页面 type 必须为 categories</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="网站head图标"><a href="#网站head图标" class="headerlink" title="网站head图标"></a>网站head图标</h2><p>修改主题配置文件<code>_config.butterfly.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favicon: /img/ico.jpg</span><br></pre></td></tr></table></figure>

<h2 id="头像配置"><a href="#头像配置" class="headerlink" title="头像配置"></a>头像配置</h2><p>修改主题配置文件<code>_config.butterfly.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  img: /img/avatar.jpg  #头像</span><br><span class="line">  effect: false         #是否一直旋转</span><br></pre></td></tr></table></figure>

<h2 id="顶部横幅banner"><a href="#顶部横幅banner" class="headerlink" title="顶部横幅banner"></a>顶部横幅banner</h2><p>修改主题配置文件<code>_config.butterfly.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 是否禁用所有的banner</span><br><span class="line">disable_top_img: true</span><br><span class="line"></span><br><span class="line"># 主页的banner</span><br><span class="line">index_img:</span><br><span class="line"></span><br><span class="line"># 默认的 top_img，当页面的 top_img 没有配置时，会显示 default_top_img</span><br><span class="line">default_top_img:</span><br><span class="line"></span><br><span class="line"># 归档页面的 top_img</span><br><span class="line">archive_img:</span><br><span class="line"></span><br><span class="line"># tag 子页面 的 默认 top_img</span><br><span class="line">tag_img:</span><br><span class="line"></span><br><span class="line"># tag 子页面的 top_img，可配置每个 tag 的 top_img</span><br><span class="line"># format:</span><br><span class="line">#  - tag name: xxxxx</span><br><span class="line">tag_per_img:</span><br><span class="line"></span><br><span class="line"># If the banner of category page not setting, it will show the top_img</span><br><span class="line"># note: category page, not categories page (子分類頁面的 top_img)</span><br><span class="line">category_img:</span><br><span class="line"></span><br><span class="line"># The banner image of category page</span><br><span class="line"># format:</span><br><span class="line">#  - category name: xxxxx</span><br><span class="line">category_per_img:</span><br></pre></td></tr></table></figure>

<h2 id="文章页面的配置"><a href="#文章页面的配置" class="headerlink" title="文章页面的配置"></a>文章页面的配置</h2><p>修改主题配置文件<code>_config.butterfly.yml</code></p>
<h3 id="目录样式"><a href="#目录样式" class="headerlink" title="目录样式"></a>目录样式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  post: true</span><br><span class="line">  page: false</span><br><span class="line">  number: true</span><br><span class="line">  expand: true  # 是否展开 </span><br><span class="line">  style_simple: false # for post</span><br><span class="line">  scroll_percent: true</span><br></pre></td></tr></table></figure>

<h3 id="文章结尾版权配置"><a href="#文章结尾版权配置" class="headerlink" title="文章结尾版权配置"></a>文章结尾版权配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_copyright:</span><br><span class="line">  enable: true</span><br><span class="line">  decode: false</span><br><span class="line">  author_href:</span><br><span class="line">  license: CC BY-NC-SA 4.0</span><br><span class="line">  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/</span><br></pre></td></tr></table></figure>
<p>也可以在文章的Front-matter中单独设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copyright: false</span><br><span class="line">copyright_author: xxxx</span><br><span class="line">copyright_author_href: https://xxxxxx.com</span><br><span class="line">copyright_url: https://xxxxxx.com</span><br><span class="line">copyright_info: 此文章版权归xxxxx所有，如有转载，请注明来自原作者</span><br></pre></td></tr></table></figure>

<h3 id="文章结尾的打赏"><a href="#文章结尾的打赏" class="headerlink" title="文章结尾的打赏"></a>文章结尾的打赏</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reward:</span><br><span class="line">  enable: false                 #是否启用</span><br><span class="line">  QR_code:                      #打赏二维码</span><br><span class="line">    # - img: /img/wechat.jpg</span><br><span class="line">    #   link:</span><br><span class="line">    #   text: 微信</span><br><span class="line">    # - img: /img/alipay.jpg</span><br><span class="line">    #   link:</span><br><span class="line">    #   text: 支付宝</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="文章的目录"><a href="#文章的目录" class="headerlink" title="文章的目录"></a>文章的目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  post: true</span><br><span class="line">  page: false</span><br><span class="line">  number: true</span><br><span class="line">  expand: false</span><br><span class="line">  style_simple: false # for post</span><br><span class="line">  scroll_percent: true</span><br></pre></td></tr></table></figure>

<h3 id="底部footer"><a href="#底部footer" class="headerlink" title="底部footer"></a>底部footer</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  owner:</span><br><span class="line">    enable: true</span><br><span class="line">    since: 2023</span><br><span class="line">  custom_text:</span><br><span class="line">  copyright: true # Copyright of theme and framework</span><br></pre></td></tr></table></figure>

<h3 id="侧边栏配置"><a href="#侧边栏配置" class="headerlink" title="侧边栏配置"></a>侧边栏配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aside:</span><br><span class="line">  enable: true</span><br><span class="line">  hide: false</span><br><span class="line">  button: true</span><br><span class="line">  mobile: true      # 是否在手机端显示</span><br><span class="line">  position: right   # left or right</span><br><span class="line"></span><br><span class="line">  display:</span><br><span class="line">    archive: true   # 是否显示归档</span><br><span class="line">    tag: true       # 标签</span><br><span class="line">    category: true  # 分类</span><br><span class="line">  card_author:</span><br><span class="line">    enable: true</span><br><span class="line">    description:    # 个人介绍</span><br><span class="line">    button:</span><br><span class="line">      enable: true</span><br><span class="line">      icon: fab fa-github</span><br><span class="line">      text: Follow Me</span><br><span class="line">      link: https://github.com/FirefliesL</span><br><span class="line">  card_announcement:    # 公告</span><br><span class="line">    enable: true</span><br><span class="line">    content: 无</span><br><span class="line">  card_recent_post:</span><br><span class="line">    enable: true</span><br><span class="line">    limit: 5 # if set 0 will show all</span><br><span class="line">    sort: date # date or updated</span><br><span class="line">    sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br><span class="line">  card_categories:</span><br><span class="line">    enable: true</span><br><span class="line">    limit: 8 # if set 0 will show all</span><br><span class="line">    expand: none # none/true/false</span><br><span class="line">    sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br><span class="line">  card_tags:</span><br><span class="line">    enable: true</span><br><span class="line">    limit: 40 # if set 0 will show all</span><br><span class="line">    color: false</span><br><span class="line">    orderby: random # Order of tags, random/name/length</span><br><span class="line">    order: 1 # Sort of order. 1, asc for ascending; -1, desc for descending</span><br><span class="line">    sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br><span class="line">  card_archives:</span><br><span class="line">    enable: true</span><br><span class="line">    type: monthly # yearly or monthly</span><br><span class="line">    format: MMMM YYYY # eg: YYYY年MM月</span><br><span class="line">    order: -1 # Sort of order. 1, asc for ascending; -1, desc for descending</span><br><span class="line">    limit: 8 # if set 0 will show all</span><br><span class="line">    sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br><span class="line">  card_webinfo:</span><br><span class="line">    enable: true</span><br><span class="line">    post_count: true</span><br><span class="line">    last_push_date: true</span><br><span class="line">    sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br></pre></td></tr></table></figure>

<h1 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h1><h2 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h2><ol>
<li><p>先安装插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>_config.yml</code>中配置插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo-generator-searchdb</span><br><span class="line">search:</span><br><span class="line">  path: search.xml  # 生成的文件</span><br><span class="line">  field: post       # 搜索范围 post(默认)，page, all</span><br><span class="line">  content: true     # 是否包含每篇文章的全部内容</span><br><span class="line">  format: html      # 内容的显示格式 html (Default)，striptags，raw</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>_config.butterfly.yml</code>中配置主题的搜索功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true  #是否开启搜索功能</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  CDN:</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="界面美化"><a href="#界面美化" class="headerlink" title="界面美化"></a>界面美化</h1><h2 id="静止彩带效果"><a href="#静止彩带效果" class="headerlink" title="静止彩带效果"></a>静止彩带效果</h2><p>修改主题配置文件<code>_config.butterfly.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canvas_ribbon:</span><br><span class="line">  enable: true</span><br><span class="line">  size: 150</span><br><span class="line">  alpha: 0.6</span><br><span class="line">  zIndex: -1</span><br><span class="line">  click_to_change: true</span><br><span class="line">  mobile: false</span><br></pre></td></tr></table></figure>

<h2 id="标题样式美化"><a href="#标题样式美化" class="headerlink" title="标题样式美化"></a>标题样式美化</h2><p>修改主题配置文件<code>_config.butterfly.yml</code><br>图标可以在 <a href="https://fontawesome.com/search?o=r&m=free">fontawesome</a>去找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beautify:</span><br><span class="line">  enable: true</span><br><span class="line">  field: post # site/post</span><br><span class="line">  title-prefix-icon:  &#x27;\f0c6&#x27; #fontawesome的icon的Unicode数</span><br><span class="line">  title-prefix-icon-color:  &#x27;#F47466&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="其它配置"><a href="#其它配置" class="headerlink" title="其它配置"></a>其它配置</h1><h2 id="mermaid标签"><a href="#mermaid标签" class="headerlink" title="mermaid标签"></a>mermaid标签</h2><p>修改主题配置文件<code>_config.butterfly.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mermaid:</span><br><span class="line">  enable: true</span><br><span class="line">  # built-in themes: default/forest/dark/neutral</span><br><span class="line">  theme:</span><br><span class="line">    light: default</span><br><span class="line">    dark: dark</span><br></pre></td></tr></table></figure>
<p>格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>wsl</title>
    <url>//pages/a74008/</url>
    <content><![CDATA[<h2 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h2><p>WSL(Windows subsystem for Linux),windows下的linux子系统。</p>
<p>安装可以参考<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">官方文档</a></p>
<p>默认安装是安装在系统盘，考虑到后期拉源码，编译会占用大量的空间，将它安装在其他盘，总结一下简单流程：</p>
<ol>
<li><p>启用适用于Linux的windows子系统</p>
<p>以管理员身份打开powershell，运行以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>

<p>或者直接通过可视化界面操作：</p>
<p>控制面板——卸载程序——启用或关闭windows功能——勾选“适用于Linux的Windows子系统”</p>
</li>
<li><p>启用虚拟机功能，以便于将WSL2设置为默认版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>

<p>或者直接通过可视化界面操作：</p>
<p>控制面板——卸载程序——启用或关闭windows功能——勾选“虚拟机平台”</p>
<p>还需要下载<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">Linux内核更新包</a></p>
</li>
<li><p>将WSL2设置为默认</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>


</li>
<li><p>将wsl安装在指定目录，需要下载<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#downloading-distributions">wsl linux发行版</a>，然后安装</p>
</li>
<li><p>下载下来的是一个.appx的文件，将其后缀从.appx改为.zip，并解压</p>
</li>
<li><p>解压后，目录下有对应的.exe可执行文件，双击运行即可进行安装。</p>
</li>
<li><p>安装完成后，会让进行用户名和密码设置。</p>
</li>
</ol>
<p>wsl2会存在内存占用高的问题，在用户目录下新建.wslconfig，配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=8GB</span><br><span class="line">swap=16GB</span><br><span class="line">localhostForwarding=true</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>WSL2还存在空间不足的情况，需要扩容</p>
<p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/vhd-size">https://docs.microsoft.com/zh-cn/windows/wsl/vhd-size</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.进入磁盘分区</span><br><span class="line">diskpart</span><br><span class="line">2.选择虚拟盘</span><br><span class="line">Select vdisk file=&quot;E:\wsl\Ubuntu_1804.2019.522.0_x64\ext4.vhdx&quot;</span><br><span class="line">3.查看详情</span><br><span class="line">detail vdisk</span><br><span class="line">4.扩容(单位MB)</span><br><span class="line">expand vdisk maximum=870400</span><br><span class="line">5.退出</span><br><span class="line">exit</span><br><span class="line">6.进入wsl，更新容量</span><br><span class="line">sudo mount -t devtmpfs none /dev</span><br><span class="line">mount | grep ext4</span><br><span class="line">复制此项的名称，该名称类似于：/dev/sdXX（X 表示任何其他字符</span><br><span class="line">sudo resize2fs /dev/sdb 870400M</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="挂载额外的磁盘"><a href="#挂载额外的磁盘" class="headerlink" title="挂载额外的磁盘"></a>挂载额外的磁盘</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/wsl2-mount-disk#mount-a-vhd-in-wsl">https://learn.microsoft.com/zh-cn/windows/wsl/wsl2-mount-disk#mount-a-vhd-in-wsl</a></p>
<p>windows家庭版没有Hyper-V,需要先安装</p>
<p>创建bat脚本，内容如下，然后以管理员身份运行，执行完后重启即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line"></span><br><span class="line">dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hv.txt</span><br><span class="line"></span><br><span class="line">for /f %%i in (&#x27;findstr /i . hv.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span><br><span class="line"></span><br><span class="line">del hv.txt</span><br><span class="line"></span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V -All /LimitAccess /ALL</span><br><span class="line"></span><br><span class="line">Pause</span><br></pre></td></tr></table></figure>



<p>需要在PowerShell中以管理员身份运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建一个虚拟磁盘</span><br><span class="line">New-VHD -Path D:\wsl\extern.vhdx -SizeBytes 300GB</span><br><span class="line">2.将虚拟磁盘挂载到Windows中，并输出磁盘路径</span><br><span class="line">Write-Output &quot;\\.\PhysicalDrive$((Mount-VHD -Path &lt;pathToVHD&gt; -PassThru | Get-Disk).Number)&quot;</span><br><span class="line">查看所有可用磁盘</span><br><span class="line">GET-CimInstance -query &quot;SELECT * from Win32_DiskDrive&quot;</span><br><span class="line">3.连接磁盘，但不挂载，DiskPath 类似 \\.\PHYSICALDRIVEX</span><br><span class="line">wsl --mount &lt;DiskPath&gt; --bare</span><br></pre></td></tr></table></figure>

<p>进入wsl为连接的虚拟磁盘创建ext4文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.查看所有磁盘，类似sda、sdb、sdc...</span><br><span class="line">lsblk</span><br><span class="line">2.为连接的磁盘创建ext4文件系统,sdX中的X实际挂载会有所不同</span><br><span class="line">sudo mkfs.ext4 /dev/sdX</span><br></pre></td></tr></table></figure>

<p>在PowerShell中重新挂载创建好文件系统的虚拟磁盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --unmount &lt;DiskPath&gt;</span><br><span class="line">wsl --mount &lt;DiskPath&gt;</span><br></pre></td></tr></table></figure>





<p>free 查看内存</p>
<p>df 查看挂载的磁盘分区</p>
<p>图形化:<a href="https://zhuanlan.zhihu.com/p/435832206">https://zhuanlan.zhihu.com/p/435832206</a></p>
<h3 id="更换wsl路径"><a href="#更换wsl路径" class="headerlink" title="更换wsl路径"></a>更换wsl路径</h3><p>官方版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 查看本地的 wsl列表</span><br><span class="line">wsl -l -v</span><br><span class="line">2. 将需要迁移的系统导出为tar</span><br><span class="line">wsl --export &lt;Distro&gt; &lt;FileName&gt;</span><br><span class="line">wsl --export Ubuntu-18.04 E:\wsl\wsl_ubuntu1804.tar</span><br><span class="line">3. 将原来的系统注销</span><br><span class="line">wsl --unregister Ubuntu-18.04</span><br><span class="line">4. 将导出的tar导入到新的路径</span><br><span class="line">wsl --import &lt;Distro&gt; &lt;InstallLocation&gt; &lt;FileName&gt;</span><br><span class="line">wsl --import Ubuntu-18.04 E:\wsl\Ubuntu_1804.2019.522.0_x64 E:\wsl\wsl_ubuntu1804.tar</span><br><span class="line">5. 设置默认登陆用户名</span><br><span class="line">进入到子系统安装目录，包含ubuntuxxxx.exe</span><br><span class="line">执行 ubuntu config --default-user &lt;username&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://zhuanlan.zhihu.com/p/338280729">https://zhuanlan.zhihu.com/p/338280729</a></p>
<p>发现原来wsl的配置是保存在注册表中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直接手动移动vhdx镜像文件。然后修改注册表</span><br><span class="line">1. 编辑注册表</span><br><span class="line">cmd运行regedit 打开注册表</span><br><span class="line">2. [HKEY_USERS\【SID】\SOFTWARE\Microsoft\Windows\CurrentVersion\Lxss\&#123;【UUID】&#125;]</span><br><span class="line">SID可以通过 whoami /USER查看</span><br><span class="line">不同UUID代表不同的wsl实例</span><br><span class="line">3. 修改BasePath就是修改vhdx的路径。</span><br></pre></td></tr></table></figure>



<p>先安装，然后将原来的目录改成和新安装的目录一样的名字，用原来的将其替换</p>
]]></content>
  </entry>
  <entry>
    <title>docker</title>
    <url>//pages/5eee67/</url>
    <content><![CDATA[<p>docker一些常用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service docker start	#启动docker服务</span><br><span class="line">docker pull &lt;imageurl&gt;		#下载docker镜像</span><br><span class="line">docker images				#查看本地的docker镜像,列出所有的imageid</span><br><span class="line">docker ps -a				#查看所有的docker容器，列出所有的containerid</span><br><span class="line">docker run &lt;imageid&gt;		#以指定镜像运行新的容器</span><br><span class="line">	docker run -itd -v 本机路径:容器路径 &lt;imageid&gt;</span><br><span class="line">	docker run -itd -v /home/feifei/workspace/:/home/chinatsp/workspace &lt;image&gt;</span><br><span class="line">docker start &lt;containerid&gt;   #启动指定的容器</span><br><span class="line">docker rm &lt;containerid&gt;      #删除指定容器</span><br><span class="line">docker exec -it &lt;containerid&gt; &lt;command&gt;	#在指定容器中执行指令</span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;docker&#x2F;daemon.json 配置docker允许访问的不安全的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line"># 指定为可以访问任意源</span><br><span class="line">&#123;</span><br><span class="line">  &quot;insecure-registries&quot;: [ &quot;0.0.0.0/0&quot;]</span><br><span class="line">&#125;</span><br><span class="line"># 重启docker</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>查看Android手机CPU频率</title>
    <url>//pages/03bffd/</url>
    <content><![CDATA[<h2 id="CPU信息"><a href="#CPU信息" class="headerlink" title="CPU信息"></a>CPU信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看CPU支持的核数</span><br><span class="line">cat /sys/devices/system/cpu/present</span><br><span class="line">#查看当前CPU0频率</span><br><span class="line">cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq</span><br><span class="line">cat /sys/devices/system/cpu/cpu1/cpufreq/cpuinfo_cur_freq</span><br><span class="line">cat /sys/devices/system/cpu/cpu2/cpufreq/cpuinfo_cur_freq</span><br><span class="line">cat /sys/devices/system/cpu/cpu3/cpufreq/cpuinfo_cur_freq</span><br><span class="line">cat /sys/devices/system/cpu/cpu4/cpufreq/cpuinfo_cur_freq</span><br><span class="line">cat /sys/devices/system/cpu/cpu5/cpufreq/cpuinfo_cur_freq</span><br><span class="line">cat /sys/devices/system/cpu/cpu6/cpufreq/cpuinfo_cur_freq</span><br><span class="line">cat /sys/devices/system/cpu/cpu7/cpufreq/cpuinfo_cur_freq</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpuinfo_cur_freq              当前cpu正在运行的工作频率</span><br><span class="line">cpuinfo_max_freq              该文件指定了处理器能够运行的最高工作频率</span><br><span class="line">cpuinfo_min_freq              该文件指定了处理器能够运行的最低工作频率</span><br><span class="line">cpuinfo_transition_latency    该文件定义了处理器在两个不同频率之间切换时所需要的时间（单位：ns）</span><br><span class="line">scaling_available_frequencies 所有支持的主频率列表</span><br><span class="line">scaling_available_governors   该文件显示当前内核中支持的所有cpufreq governor类型</span><br><span class="line">scaling_cur_freq              CPU当前运行的主频率,governor和cpufreq核决定的</span><br><span class="line">scaling_driver                该文件显示该CPU正在使用何种cpufreq driver</span><br><span class="line">scaling_governor              通过echo命令，能够改变当前处理器的governor类型</span><br><span class="line">scaling_max_freq              显示policy的上限.当改变cpu policy时，需要首先设scaling_max_freq</span><br><span class="line">scaling_min_freq              显示policy的下限</span><br><span class="line">scaling_setspeed              governor为“userspace”，可设置cpu主频率值。值在scaling_min_freq和scaling_max_freq之间。</span><br></pre></td></tr></table></figure>

<h2 id="电池信息"><a href="#电池信息" class="headerlink" title="电池信息"></a>电池信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 电池电量</span><br><span class="line">cat /sys/class/power_supply/battery/capacity</span><br><span class="line"># 电池状态</span><br><span class="line">cat /sys/class/power_supply/battery/status</span><br><span class="line"># 电池温度</span><br><span class="line">cat /sys/class/power_supply/battery/temp</span><br><span class="line"># 电池健康</span><br><span class="line">cat /sys/class/power_supply/battery/health</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Gerrit &amp; git &amp; repo</title>
    <url>//pages/9b89c3/</url>
    <content><![CDATA[<h2 id="Gerrit"><a href="#Gerrit" class="headerlink" title="Gerrit"></a>Gerrit</h2><p>官方网站：<a href="https://www.gerritcodereview.com/">https://www.gerritcodereview.com/</a></p>
<p>提交代码时指定reviewers:<a href="https://gerrit-documentation.storage.googleapis.com/Documentation/3.6.2/user-upload.html#reviewers">https://gerrit-documentation.storage.googleapis.com/Documentation/3.6.2/user-upload.html#reviewers</a></p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git中文显示\数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config core.quotePath false</span><br></pre></td></tr></table></figure>

<p>初始化本地仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>添加远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:1945155025/vuepress_demo.git</span><br></pre></td></tr></table></figure>

<p>推送到新的远程分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin &lt;newBrach&gt;</span><br></pre></td></tr></table></figure>

<p>git pull origin master</p>
<p>保存帐号密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config credential.helper store</span><br><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>


<p>查看历史操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<p>查看指定文件代码责任人</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git blame &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>显示某次提交的详细修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git show &lt;commitId&gt; [file]</span><br></pre></td></tr></table></figure>

<p>push代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#(需要代码审核) git push &lt;远程仓库名&gt; HEAD:refs/for/&lt;远程分支名&gt;</span><br><span class="line">git push origin HEAD:refs/for/&lt;remote branch&gt;</span><br><span class="line">#(直接入库),不加refs/for/</span><br><span class="line">git push origin HEAD:master</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch&gt; 【新建本地分支branch并切换到该分支】</span><br><span class="line">git checkout -b &lt;branch&gt; origin/&lt;branch&gt; 【新建本地分支并追踪远程分支】</span><br><span class="line">git ls-remote --heads origin     查看远程仓库origin的分支</span><br><span class="line">git fetch origin &lt;branch&gt; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick -x 2f91bb95bfa0e5d7d9ca6d97d8886988203cc846..3922427cd1f24beab5a6bb97aaf698a0ab1f65ca 包括2端</span><br><span class="line">git cherry-pick -x (2f91bb95bfa0e5d7d9ca6d97d8886988203cc846..3922427cd1f24beab5a6bb97aaf698a0ab1f65ca]</span><br></pre></td></tr></table></figure>



<p>配置alias</p>
<p>如果 alias扩展 以感叹号作为前缀，则它将被视为shell命令.</p>
<p><a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-alias">官网说明1</a><br><a href="https://git-scm.com/book/en/v2/Git-Basics-Git-Aliases">官网说明2</a></p>
<p>如在用户目录下的<code>.gitconfig</code>中添加如下名为<code>push2review</code>的alias：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">        push2review = !git push origin HEAD:refs/for/test%r=user1@test.com,r=user2@test.com,r=user3@test.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行 git push2review就是 执行push2review中定义的指令</p>
<h2 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h2><p>查看repo版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repo version</span><br></pre></td></tr></table></figure>

<p>创建本地分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repo start &lt;branch&gt; [--all|&lt;project&gt;]</span><br></pre></td></tr></table></figure>

<p>查看本地分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repo branch</span><br></pre></td></tr></table></figure>

<p>删除本地分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repo abandon &lt;branch&gt; [&lt;project&gt; ...]</span><br></pre></td></tr></table></figure>

<p>创建一个repo镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#初始化镜像</span><br><span class="line">cd ~/workspace/mirror</span><br><span class="line">repo init -u &lt;url&gt; --mirror</span><br><span class="line">#更新镜像</span><br><span class="line">repo sync</span><br><span class="line"></span><br><span class="line">后续初始化repo，指定镜像目录</span><br><span class="line">cd ~/workspace/project</span><br><span class="line">repo init -u &lt;url&gt; --reference &lt;镜像目录&gt;</span><br><span class="line">repo sync -c --no-tags</span><br><span class="line"></span><br><span class="line">后续更新代码</span><br><span class="line">先更新镜像</span><br><span class="line">cd ~/workspace/mirror</span><br><span class="line">repo sync</span><br><span class="line">再更新工作目录</span><br><span class="line">cd ~/workspace/project</span><br><span class="line">repo sync -c </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>ssl证书</title>
    <url>//pages/988f92/</url>
    <content><![CDATA[<h2 id="证书申请"><a href="#证书申请" class="headerlink" title="证书申请"></a>证书申请</h2><p>免费的证书申请可以参考 <a href="https://cloud.tencent.com/developer/article/2013019">https://cloud.tencent.com/developer/article/2013019</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1731701338777586322&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1731701338777586322&amp;wfr=spider&amp;for=pc</a></p>
<p>目前可以通过<a href="https://freessl.cn/">freessl</a>申请亚洲诚信(TrustAsia)颁发的SSL证书,并通过ACME自动化脚本进行自动续期</p>
<h2 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><p>&#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;frp-proxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen 80;</span><br><span class="line">       listen [::]:80;</span><br><span class="line">       </span><br><span class="line">       listen 443 ssl;</span><br><span class="line">       listen [::]:443 ssl;</span><br><span class="line"></span><br><span class="line">       ssl_certificate /root/ssl/cert.pem;</span><br><span class="line">       ssl_certificate_key /root/ssl/key.pem;</span><br><span class="line"></span><br><span class="line">       server_name *.lifeifei.pub;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       location / &#123;</span><br><span class="line">               try_files $uri $uri/ =404;</span><br><span class="line">	       proxy_pass http://127.0.0.1:8080;</span><br><span class="line"></span><br><span class="line"> 	       # 这个Host的header一定要加，不然转发后frp拿不到通过哪个域名访问的，导致转发失败</span><br><span class="line">	       proxy_set_header   Host             $host;</span><br><span class="line">	       #proxy_http_version 1.1;</span><br><span class="line">               proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">	       proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ &#123;</span><br><span class="line">               proxy_pass http://127.0.0.1:8080;</span><br><span class="line">               expires 12h;</span><br><span class="line">               proxy_set_header   Host             $host;</span><br><span class="line">               proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">               proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       location ~ \.(php|cgi)$ &#123;</span><br><span class="line">               proxy_pass http://127.0.0.1:8080;</span><br><span class="line"></span><br><span class="line">               proxy_set_header   Host             $host;</span><br><span class="line">               proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">               proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       #所有请求都通过frp代理</span><br><span class="line">       location ~ \.* &#123;</span><br><span class="line">               proxy_pass http://127.0.0.1:8080;</span><br><span class="line"></span><br><span class="line">               proxy_set_header   Host             $host;</span><br><span class="line">               proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">               proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">               proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">               proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>AOSP新增设备</title>
    <url>/2024/05/20/%E5%85%B6%E5%AE%83/06.AOSP%E6%96%B0%E5%A2%9E%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://source.android.google.cn/docs/setup/create/new-device?hl=zh-cn">https://source.android.google.cn/docs/setup/create/new-device?hl=zh-cn</a></p>
<h2 id="创建mk定义产品"><a href="#创建mk定义产品" class="headerlink" title="创建mk定义产品"></a>创建mk定义产品</h2><p>创建一个设备目录：<code>device/&lt;company-name&gt;/&lt;device-name&gt;</code><br>在设备目录下创建一个 mk 用来声明产品 信息,如 <code>local_project.mk</code>，文件名自己定义，<br>文件名即TARGET_PRODUCT<br>主要注意几个关键点：</p>
<ol>
<li>定义的文件名是<code>TARGET_PRODUCT</code></li>
<li><code>PRODUCT_NAME</code>需要和<code>TARGET_PRODUCT</code>保持一致（<code>PRODUCT_NAME</code>只能是文件名）</li>
<li><code>PRODUCT_DEVICE</code>需要和<code>TARGET_DEVICE</code>保持一致（<code>PRODUCT_DEVICE</code>只能是BoardConfig.mk的父目录名称）</li>
</ol>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Inherit from the common Open Source product configuration</span><br><span class="line">$(call inherit-product, $(SRC_TARGET_DIR)/product/core_64_bit.mk)</span><br><span class="line">$(call inherit-product, $(SRC_TARGET_DIR)/product/aosp_base_telephony.mk)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 产品名称 在设置-关于中显示,注意要和TARGET_PRODUCT保持一致,否则报错 No matches for product &quot;xxx&quot;.</span><br><span class="line">PRODUCT_NAME := local_project</span><br><span class="line"># 产品模型(代号) </span><br><span class="line">PRODUCT_MODEL := test_mode</span><br><span class="line"># 设备名称 需要注意指定的名称需要和BoardConfig.mk的父目录名称一样，否则报错 No config file found for TARGET_DEVICE xxx.</span><br><span class="line">PRODUCT_DEVICE := test_device</span><br><span class="line"># 软件品牌</span><br><span class="line">PRODUCT_BRAND := local_brand</span><br><span class="line"># 设备制造商</span><br><span class="line">PRODUCT_MANUFACTURER := local_manufacturer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="指定定义产品的mk"><a href="#指定定义产品的mk" class="headerlink" title="指定定义产品的mk"></a>指定定义产品的mk</h2><p>创建<code>AndroidProducts.mk</code>,在其中指定定义产品的mk<br>注意：COMMON_LUNCH_CHOICES 需要和 PRODUCT_MAKEFILES 指定的文件名匹配，<br>PRODUCT_MAKEFILES中的文件名称就是TARGET_PRODUCT，而COMMON_LUNCH_CHOICES中的TARGET_PRODUCT需要和PRODUCT_MAKEFILES中声明的保持一致<br>否则会lunch的时候报错<em><strong>Product not defined in this file</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PRODUCT_MAKEFILES := \</span><br><span class="line">        $(LOCAL_DIR)/local_project.mk \</span><br><span class="line">COMMON_LUNCH_CHOICES := \</span><br><span class="line">        local_project-userdebug \</span><br><span class="line">        local_project-user        </span><br></pre></td></tr></table></figure>

<h2 id="创建BoardConfig-mk"><a href="#创建BoardConfig-mk" class="headerlink" title="创建BoardConfig.mk"></a>创建BoardConfig.mk</h2><p>注意，需要在创建一个BoardConfig.mk文件，这个文件的父目录会被作为<code>TARGET_DEVICE</code>,在定义<code>PRODUCT_DEVICE</code>时需要注意，<br><code>PRODUCT_DEVICE</code>只能是<code>TARGET_DEVICE</code>中的一种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TARGET_ARCH := arm64</span><br></pre></td></tr></table></figure>
<p>TARGET_ARCH not defined by board config:xxx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TARGET_ARCH_VARIANT := armv8-a</span><br></pre></td></tr></table></figure>
<p>Unknown ARM architecture version: armv8.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TARGET_CPU_ABI := arm64-v8a</span><br></pre></td></tr></table></figure>
<p>No TARGET_CPU_ABI defined by board config: .</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>framework中一些通用逻辑</title>
    <url>/2024/05/21/%E5%85%B6%E5%AE%83/07.Makefile/</url>
    <content><![CDATA[<p><a href="https://seisman.github.io/how-to-write-makefile/introduction.html">https://seisman.github.io/how-to-write-makefile/introduction.html</a></p>
<h2 id="makefile的规则"><a href="#makefile的规则" class="headerlink" title="makefile的规则"></a>makefile的规则</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标：依赖</span><br><span class="line">    指令</span><br></pre></td></tr></table></figure>
<p>创建一个<code>Makefile</code>文件，在同一目录下执行make就会去解析<code>Makefile</code>，进行编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test:dependency</span><br><span class="line">	@echo &quot;make test finish&quot;</span><br><span class="line"></span><br><span class="line">dependency:</span><br><span class="line">	@echo &quot;execute dependency&quot;</span><br></pre></td></tr></table></figure>

<p>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。<br>如果找到，它会找文件中的第一个目标（target）进行编译，在上面的例子中，他会找到test这个目标，把这个作为最终的目标执行编译。</p>
]]></content>
  </entry>
  <entry>
    <title>apk混淆</title>
    <url>//pages/9c2bc2/</url>
    <content><![CDATA[<h2 id="Proguard和R8"><a href="#Proguard和R8" class="headerlink" title="Proguard和R8"></a>Proguard和R8</h2><p>(Proguard)[<a href="https://www.guardsquare.com/proguard]:java%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E5%99%A8">https://www.guardsquare.com/proguard]:java代码混淆器</a></p>
<p>(R8)[<a href="https://developer.android.google.cn/studio/build/shrink-code?hl=zh-cn#enable]:Android">https://developer.android.google.cn/studio/build/shrink-code?hl=zh-cn#enable]:Android</a> Studio 3.4 开始，R8是默认的编译器，将java字节码转换成在Android平台上运行的dex格式，<br>本地通过Android.bp对jar包进行混淆，编译后发现只有生成的dex格式的jar包混淆成功，class类型的jar包没有混淆（R8会将class转成dex）。由此可见，R8时对dex进行混淆，Proguard是对class进行混淆。<br>R8兼容ProGuard 的规则.</p>
<p>所以编写混淆规则时，参考：(<a href="https://developer.android.google.cn/studio/build/shrink-code?hl=zh-cn)%5Bhttps://developer.android.google.cn/studio/build/shrink-code?hl=zh-cn%5D">https://developer.android.google.cn/studio/build/shrink-code?hl=zh-cn)[https://developer.android.google.cn/studio/build/shrink-code?hl=zh-cn]</a></p>
<h2 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h2><h2 id="Android-bp混淆"><a href="#Android-bp混淆" class="headerlink" title="Android.bp混淆"></a>Android.bp混淆</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//混淆</span><br><span class="line">optimize: &#123;</span><br><span class="line">    //是否启用</span><br><span class="line">    enabled: true,</span><br><span class="line">    //删除未使用的代码来优化大小</span><br><span class="line">    //shrink: true,</span><br><span class="line">    //优化字节码</span><br><span class="line">    //optimize: true,</span><br><span class="line">    //混淆</span><br><span class="line">    //obfuscate: true,</span><br><span class="line">    //混淆文件</span><br><span class="line">    proguard_flags_files:[&quot;proguard.flags&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="class-jar混淆"><a href="#class-jar混淆" class="headerlink" title="class jar混淆"></a>class jar混淆</h2><p>通过Android R8进行混淆后是dex格式的文件，无法提供给三方使用，所以需要用Proguard来进行混淆。<br>参考 ： (<a href="https://blog.csdn.net/I_am_Yong_Ge/article/details/93886621)[https://blog.csdn.net/I_am_Yong_Ge/article/details/93886621]">https://blog.csdn.net/I_am_Yong_Ge/article/details/93886621)[https://blog.csdn.net/I_am_Yong_Ge/article/details/93886621]</a></p>
<ol>
<li>先下载(proguard)[<a href="https://github.com/Guardsquare/proguard/releases]%EF%BC%8C%E5%B9%B6%E8%A7%A3%E5%8E%8B">https://github.com/Guardsquare/proguard/releases]，并解压</a></li>
<li>执行proguard的bin目录下的proguardgui.bat</li>
<li>在GUI界面进行自定义配置，然后混淆生成jar</li>
</ol>
<p>这里主要注意几个点</p>
<ol>
<li>jar包不要shrinking，shrinking会删除未使用的代码。</li>
<li>涉及到jni相关的，需要保留native方法的名称，不然会链接失败，找不到对应方法</li>
<li>可以忽略警告和note: <code>-dontnote</code>, <code>-dontwarn</code></li>
<li>保留方法参数名称: <code>-keepparameternames</code></li>
</ol>
<p>library的混淆规则可以参考：(proguard官方示例)[<a href="https://www.guardsquare.com/manual/configuration/examples#library]">https://www.guardsquare.com/manual/configuration/examples#library]</a></p>
<p>可参考:(<a href="https://www.codenong.com/cs106664836/)[https://www.codenong.com/cs106664836/]">https://www.codenong.com/cs106664836/)[https://www.codenong.com/cs106664836/]</a></p>
<h2 id="AOSP里面的混淆规则"><a href="#AOSP里面的混淆规则" class="headerlink" title="AOSP里面的混淆规则"></a>AOSP里面的混淆规则</h2><p>会读取build&#x2F;make&#x2F;core&#x2F;proguard.flags和Android.bp中optimize.proguard_flags_files定义的规则文件<br>(java.go#compile)[<a href="http://aospxref.com/android-11.0.0_r21/xref/build/soong/java/java.go#1273]">http://aospxref.com/android-11.0.0_r21/xref/build/soong/java/java.go#1273]</a><br>    (java.go#compileDex)[<a href="http://aospxref.com/android-11.0.0_r21/xref/build/soong/java/java.go#1624]">http://aospxref.com/android-11.0.0_r21/xref/build/soong/java/java.go#1624]</a><br>        (dex.go#r8Flags)[<a href="http://aospxref.com/android-11.0.0_r21/xref/build/soong/java/dex.go?fi=compileDex#217]">http://aospxref.com/android-11.0.0_r21/xref/build/soong/java/dex.go?fi=compileDex#217]</a><br>            (规则文件处理)[<a href="http://aospxref.com/android-11.0.0_r21/xref/build/soong/java/dex.go#153]">http://aospxref.com/android-11.0.0_r21/xref/build/soong/java/dex.go#153]</a></p>
<p>aapt2中也有对混淆规则的处理，会去解析xml文件<br>以AndroidManifest.xml的解析为例，<br>(CollectProguardRulesForManifest)[<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/tools/aapt2/cmd/Link.cpp#2093]%E4%B8%AD">http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/tools/aapt2/cmd/Link.cpp#2093]中</a><br>调用的(ManifestVisitor)[<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/tools/aapt2/java/ProguardRules.cpp#260]">http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/tools/aapt2/java/ProguardRules.cpp#260]</a><br>去解析xml，保存需要保留的信息，最后在通过Proguard写入规则<br>(ManifestVisitor#Visit)[<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/tools/aapt2/java/ProguardRules.cpp#266]">http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/tools/aapt2/java/ProguardRules.cpp#266]</a><br>(Link#WriteProguardFile)[<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/tools/aapt2/cmd/Link.cpp#1286]">http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/tools/aapt2/cmd/Link.cpp#1286]</a><br>(WriteKeepSet)[<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/tools/aapt2/java/ProguardRules.cpp?fi=WriteKeepSet#402]">http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/tools/aapt2/java/ProguardRules.cpp?fi=WriteKeepSet#402]</a></p>
]]></content>
  </entry>
  <entry>
    <title>javadoc生成文档</title>
    <url>/2024/12/02/%E5%85%B6%E5%AE%83/21.javadoc%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>简单的生成：<br>如有一个Test.java文件，-d指定生成doc的目录为OutDoc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javadoc -d OutDoc Test.java</span><br></pre></td></tr></table></figure>
<p>还可以通过-sourcepath指定源码目录 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javadoc -d OutDoc -sourcepath . Test.java</span><br></pre></td></tr></table></figure>

<p>一般都会有依赖，可以通过 -classpath指定依赖的jar的路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javadoc -d OutDoc -classpath ~/android.jar:~/local.jar Test.java</span><br></pre></td></tr></table></figure>

<h2 id="不为过时接口生成文档"><a href="#不为过时接口生成文档" class="headerlink" title="不为过时接口生成文档"></a>不为过时接口生成文档</h2><p>-nodeprecated</p>
<h2 id="过时接口生成文档，但不显示“过时”标记或列表，也不会列出过时的-API-链接"><a href="#过时接口生成文档，但不显示“过时”标记或列表，也不会列出过时的-API-链接" class="headerlink" title="过时接口生成文档，但不显示“过时”标记或列表，也不会列出过时的 API 链接"></a>过时接口生成文档，但不显示“过时”标记或列表，也不会列出过时的 API 链接</h2><p>-nodeprecatedlist<br>-windowtitle <text> 文档的浏览器窗口标题<br>-nohelp     不生成帮助页<br>-noindex    不生成索引<br>-notree     不生成类分层结构<br>-doctitle <html-code> 概览页面的标题<br>-notimestamp 不生成时间戳注释</p>
]]></content>
  </entry>
  <entry>
    <title>gradle笔记</title>
    <url>/2024/12/03/%E5%85%B6%E5%AE%83/22.gradle%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="gralde官网"><a href="#gralde官网" class="headerlink" title="gralde官网"></a>gralde官网</h1><p>gradle官网地址：<a href="https://gradle.org/">https://gradle.org/</a><br>下载：<a href="https://gradle.org/releases/">https://gradle.org/releases/</a></p>
<p>先要熟悉<a href="https://docs.gradle.org/current/userguide/gradle_basics.html">基本结构</a><br>有一个Gradle Wrapper的概念，是一个基于gradle这个bin文件的二次封装，<br>主要作用：</p>
<ol>
<li>根据给定的 Gradle 版本对项目进行标准化。</li>
<li>为不同的用户提供相同的 Gradle 版本。</li>
<li>为不同的执行环境（IDE、CI 服务器……）提供 Gradle 版本。<br>gradle wapper的文件结构如下：<br>.<br>├── gradle<br>│   └── wrapper<br>│       ├── gradle-wrapper.jar</li>
</ol>
<p>│       └── gradle-wrapper.properties<br>├── gradlew<br>└── gradlew.bat </p>
<p>项目根目录下的一些必要文件</p>
<ul>
<li>settings.gradle : Gradle设置文件定义根项目名称和子项目</li>
</ul>
<h2 id="settings-gradle–gradle项目的起点"><a href="#settings-gradle–gradle项目的起点" class="headerlink" title="settings.gradle–gradle项目的起点"></a>settings.gradle–gradle项目的起点</h2><p>Gradle 支持单个和多项目构建。</p>
<p>对于单个项目构建，settings.gradle是可选的。</p>
<p>对于多项目构建，settings.gradle是强制性的，并声明所有子项目。</p>
<p>创建一个基础的gradle项目<br><code>gradle help --task :init </code>查看初始化相关的帮助</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir localtest</span><br><span class="line">cd localtest</span><br><span class="line">gradle init </span><br><span class="line"># 选择basic</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">gradle init --type basic</span><br></pre></td></tr></table></figure>
<p>然后会在localtest目录下生成gradle相关的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看所有task</span><br><span class="line">gradle tasks</span><br></pre></td></tr></table></figure>
<p>通过指定task的名字来执行对应的task，例如在build.gradle中新建一个名为hello的task</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">println &#x27;在build.gradle中&#x27;</span><br><span class="line">tasks.register(&quot;hello&quot;)&#123;</span><br><span class="line"></span><br><span class="line">    //group和description用来对任务进行描述，通过gradle tasks查看任务时，便于清除task的用途</span><br><span class="line">    group = &#x27;localtest&#x27;</span><br><span class="line">    description = &#x27;打印一句hello&#x27;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println(&quot;hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在settings.gradle中也加上一点打印,用来理解gradle文件的加载执行过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rootProject.name = &#x27;localtest&#x27;</span><br><span class="line">println &#x27;在初始化阶段，settings.gradle&#x27;</span><br></pre></td></tr></table></figure>

<p>gradle 先去加载settings.gradle,然后加载指定的任务，最后执行指定的任务中的doFirst,doLast</p>
<p>通过任务依赖，可以控制任务执行顺序,<br>如下，执行gradle upper时，会先执行hello,再去执行upper中的doLast</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasks.register(&quot;hello&quot;)&#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println(&quot;hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">tasks.register(&quot;upper&quot;)&#123;</span><br><span class="line">    dependsOn tasks.hello</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println(&quot;upper&quot;)</span><br><span class="line">        String someStr = &quot;mY_tEasf&quot;</span><br><span class="line">        println &quot;original string:  $someStr&quot;</span><br><span class="line">        println &quot;upper string: $&#123;someStr.toUpperCase()&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监听task执行开始结束"><a href="#监听task执行开始结束" class="headerlink" title="监听task执行开始结束"></a>监听task执行开始结束</h2><p>监听task执行过程，参考官网说明：<a href="https://docs.gradle.org/8.4/userguide/build_lifecycle.html#execution">https://docs.gradle.org/8.4/userguide/build_lifecycle.html#execution</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasks.register(&#x27;ok&#x27;)</span><br><span class="line"></span><br><span class="line">tasks.register(&#x27;broken&#x27;) &#123;</span><br><span class="line">    dependsOn ok</span><br><span class="line">    doLast &#123;</span><br><span class="line">        throw new RuntimeException(&#x27;broken&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在task执行开始时</span><br><span class="line">gradle.taskGraph.beforeTask &#123; Task task -&gt;</span><br><span class="line">    println &quot;executing $task ...&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在task执行结束时</span><br><span class="line">gradle.taskGraph.afterTask &#123; Task task, TaskState state -&gt;</span><br><span class="line">    if (state.failure) &#123;</span><br><span class="line">        println &quot;FAILED&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        println &quot;done&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JNI</title>
    <url>//pages/a288f1/</url>
    <content><![CDATA[<h2 id="JNIEXPORT-与-JNICALL-宏定义作用"><a href="#JNIEXPORT-与-JNICALL-宏定义作用" class="headerlink" title="JNIEXPORT 与 JNICALL 宏定义作用"></a>JNIEXPORT 与 JNICALL 宏定义作用</h2><p>Linux 平台下JNICALL 没有进行定义 , 直接置空 ; <strong>在 Linux 中可以不用写 JNIEXPORT 和 JNICALL 宏 ;</strong></p>
<p>Windows平台下<br>Windows 中如果需要生成动态库 , 并且需要将该动态库交给其它项目使用 , 需要在方法前加入特殊标识 , 才能 在外部 程序代码中 调用该 DLL 动态库中定义的方法;<br>详情可以参考(官网)[<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/error-handling.html]">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/error-handling.html]</a><br>JNICALL 被定义为 __stdcall , __stdcall 是一种函数调用参数的约定 , 在 Windows 中调用函数时 , 该函数的参数是以 栈 的形式保存的 , 栈 中元素是后进先出的 , __stdcall 表示参数是从右到左保存的 ;</p>
<p><a href="https://blog.csdn.net/shulianghan/article/details/104072587">https://blog.csdn.net/shulianghan/article/details/104072587</a><br><a href="https://blog.csdn.net/xbj1015892775/article/details/122614325">https://blog.csdn.net/xbj1015892775/article/details/122614325</a></p>
<h2 id="JNI-Native-函数的注册"><a href="#JNI-Native-函数的注册" class="headerlink" title="JNI Native 函数的注册"></a>JNI Native 函数的注册</h2><p>native函数的注册有2种：</p>
<ol>
<li><p>静态注册<br> 当Java层调用native函数时，它会从对应的JNI库找Java_<PackageName><em><ClassName></em><MethodName>，如果没有，就会报错。如果找到，则会为这个java层声明的native方法和C&#x2F;C++层的对应函数建立一个关联关系，其实就是保存JNI层函数的函数指针。以后再调用native函数时，直接使用这个函数指针就可以了，当然这项工作是由虚拟机完成的。</p>
<p> 从这里可以看出，静态方法就是根据函数名来建立Java函数和JNI函数之间的关联关系的，它要求JNI层函数的名字必须遵循特定的格式。这种方法也有几个弊端，它们是：</p>
<ul>
<li>需要编译所有声明了native函数的Java类，每个生成的class文件都得用javah生成一个头文件。    </li>
<li>javah生成的JNI层函数名特别长，书写起来很不方便。    </li>
<li>初次调用native函数时要根据函数名字搜索对应的JNI层函数来建立关联关系，这样会影响运行效率。</li>
</ul>
</li>
<li><p>动态注册<br> JNI中定义了一个结构体JNINativeMethod,保存了java中native函数与C&#x2F;C++中函数的对应关系</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* used in RegisterNatives to describe native method name, signature,</span><br><span class="line">* and function pointer.</span><br><span class="line">*/</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    char *name;         //Java中native函数的名字，不用携带包的路径。例如“nativeCalculate“。</span><br><span class="line">    char *signature;    //Java函数的签名信息，用字符串表示，是参数类型和返回值类型的组合。</span><br><span class="line">    void *fnPtr;        //JNI层对应函数的函数指针，注意它是void*类型。</span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure>

<p> 当Java层通过System.loadLibrary加载完JNI动态库后，紧接着会查找该库中一个叫JNI_OnLoad的函数，如果有，就调用它，而动态注册的工作就是在这里完成的。<br> 可以通过RegisterNatives来动态注册jni函数,示例如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef NELEM</span><br><span class="line"># define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define ALOGD(...) __android_log_print(ANDROID_LOG_DEBUG  , &quot;jnitest&quot;, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">//C++层的实现</span><br><span class="line">static jstring generateMsgFromNative(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    return env-&gt;NewStringUTF(&quot;hello, this is msg from native&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//JNINativeMethod数组</span><br><span class="line">static const JNINativeMethod gMethods[] = &#123;</span><br><span class="line">        &#123;&quot;generateMsgFromNative&quot;, &quot;()Ljava/lang/String;&quot;, (void *) generateMsgFromNative&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//注册JNI函数</span><br><span class="line">static int registerNativeMethods(JNIEnv *env) &#123;</span><br><span class="line">    jclass clazz = env-&gt;FindClass(&quot;com/omosoft/jnitest/JNIUtils&quot;);</span><br><span class="line">    return env-&gt;RegisterNatives(clazz, gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//so加载完成</span><br><span class="line">extern &quot;C&quot; jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123;</span><br><span class="line">    ALOGD(&quot;JNI_OnLoad...&quot;);</span><br><span class="line">    JNIEnv *env = nullptr;</span><br><span class="line">    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">        ALOGD(&quot;getEnv failed&quot;);</span><br><span class="line">        return JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    //动态注册jni函数</span><br><span class="line">    registerNativeMethods(env);</span><br><span class="line">    return JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="jstring-和-char-之间的转换"><a href="#jstring-和-char-之间的转换" class="headerlink" title="jstring 和 char*之间的转换"></a>jstring 和 char*之间的转换</h2><ul>
<li>char* 转 jstring : <code>env-&gt;NewStringUTF(&quot;hello, this is msg from native&quot;)</code></li>
<li>jstirng 转 char* : <code>const char * str = env-&gt;GetStringUTFChars(jstr, nullptr);</code></li>
</ul>
<h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p>(安卓JNI精细化讲解，让你彻底了解JNI（一）：环境搭建与HelloWord)[<a href="https://www.cnblogs.com/qixingchao/p/11911764.html]">https://www.cnblogs.com/qixingchao/p/11911764.html]</a><br>(安卓JNI精细化讲解，让你彻底了解JNI（二）：用法解析)[<a href="https://www.cnblogs.com/qixingchao/p/11911787.html]">https://www.cnblogs.com/qixingchao/p/11911787.html]</a></p>
]]></content>
  </entry>
  <entry>
    <title>mermaid绘图</title>
    <url>//pages/b9e650/</url>
    <content><![CDATA[<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>先声明时序图 <code>sequenceDiagram</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>绘制时许图的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[角色1][箭头]][角色2]:描述消息</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">A-&gt;&gt;B:描述消息</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>效果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">A-&gt;&gt;B:描述消息</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>参考官网:<a href="https://mermaid.js.org/syntax/sequenceDiagram.html#sequence-diagrams">https://mermaid.js.org/syntax/sequenceDiagram.html#sequence-diagrams</a></p>
]]></content>
  </entry>
  <entry>
    <title>CMake常用语法</title>
    <url>//pages/98eec5/</url>
    <content><![CDATA[<h2 id="windows下的环境配置"><a href="#windows下的环境配置" class="headerlink" title="windows下的环境配置"></a>windows下的环境配置</h2><ol>
<li>下载windows下的c++编译器 <a href="https://www.mingw-w64.org/downloads/#mingw-builds">Mingw-w64</a></li>
<li>下载<a href="https://cmake.org/download/">Cmake</a></li>
<li>解压后配置环境变量</li>
</ol>
<p>官网提示：虽然CMake支持大写、小写和混合大小写命令，但小写命令是首选，并将在整个教程中使用。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ol>
<li>任何项目的最顶层CMakeLists.txt的开始 必须使用cmake_minimum_required()命令指定CMake的最小版本。这将建立策略设置，并确保后续的CMake函数使用兼容版本的CMake运行。</li>
<li>开始一个项目，使用project()命令来设置项目名称，每个项目都需要这个调用，应该在cmake_minimum_required()之后立即调用。</li>
<li>最后，add_executable()命令告诉CMake使用指定的源代码文件创建一个可执行文件。</li>
</ol>
<h2 id="创建一个基本项目"><a href="#创建一个基本项目" class="headerlink" title="创建一个基本项目"></a>创建一个基本项目</h2><p>最基础版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.必须声明兼容的CMake最低版本</span><br><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br><span class="line"># 2.项目名称和版本</span><br><span class="line">project(SimulateHUD VERSION 0.1.0)</span><br><span class="line"></span><br><span class="line"># 3.指定编译成可执行文件 的out文件名 及编译所需源码</span><br><span class="line">add_executable(SimulateHUD main.cpp)</span><br></pre></td></tr></table></figure>

<p>带配置文件版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1:声明兼容的CMake的最低版本</span><br><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"># 2:设置项目名称及版本号</span><br><span class="line">project(Tutorial VERSION 2.0.1)</span><br><span class="line"></span><br><span class="line"># 设置C++标准（可选）</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(CMAKE_CXX_STANDARD_REQUIRED True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3: 指定编译成可执行文件 的out文件名 及编译所需源码</span><br><span class="line">add_executable(Tutorial tutorial.cpp)</span><br><span class="line"></span><br><span class="line"># 拷贝配置文件到编译文件夹（可选）</span><br><span class="line">configure_file(LocalConfig.h.in LocalConfig.h)</span><br><span class="line">target_include_directories(Tutorial PUBLIC $&#123;PROJECT_BINARY_DIR&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="指定C-标准"><a href="#指定C-标准" class="headerlink" title="指定C++标准"></a>指定C++标准</h2><p>在CMake中启用对特定c++标准的支持的一种方法是使用CMAKE_CXX_STANDARD变量,如使用C++11标准</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(CMAKE_CXX_STANDARD_REQUIRED True)</span><br></pre></td></tr></table></figure>

<h2 id="源文件中使用CMakeLists中定义的版本号"><a href="#源文件中使用CMakeLists中定义的版本号" class="headerlink" title="源文件中使用CMakeLists中定义的版本号"></a>源文件中使用CMakeLists中定义的版本号</h2><p>在源码中获取到CmakeLists.txt中定义的变量</p>
<p>创建一个文件，其中包含一个或多个要替换的变量。这些变量有特殊的语法，看起来像@VAR@.然后，我们使用configure_file()命令将输入文件复制到给定的输出文件中，并将这些变量替换为CMakelists.txt文件中的VAR的当前值。</p>
<p>例如在项目根目录定义一个<code>config.h.in</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//project name is LocalTest</span><br><span class="line">//这里定义了2个宏，值为CMakeLists.txt中定义的版本号</span><br><span class="line">#define VERSION_MAJOR @LocalTest_VERSION_MAJOR@</span><br><span class="line">#define VERSION_MINOR @LocalTest_VERSION_MINOR@</span><br><span class="line">#define VERSION_PATCH @LocalTest_VERSION_PATCH@</span><br></pre></td></tr></table></figure>

<p>在CMakeLists中通过configure_file()将文件拷贝到指定文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将config.h.in拷贝到编译目录的config.h</span><br><span class="line">configure_file(config.h.in config.h)</span><br><span class="line"># 指定要引用的头文件目录</span><br><span class="line">target_include_directories(LocalTest PUBLIC $&#123;PROJECT_BINARY_DIR&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="添加子目录进行编译"><a href="#添加子目录进行编译" class="headerlink" title="添加子目录进行编译"></a>添加子目录进行编译</h2><p>add_subdirectory() , 子目录下需要包含CMakeLists.txt</p>
<h2 id="创建一个library"><a href="#创建一个library" class="headerlink" title="创建一个library"></a>创建一个library</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1:声明兼容的CMake的最低版本</span><br><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"># 2:设置项目名称及版本号</span><br><span class="line">project(MathFunctions VERSION 2.0.1)</span><br><span class="line"># 3:指定要编译的library名称及源码</span><br><span class="line">add_library(MathFunctions mysqrt.cpp)</span><br></pre></td></tr></table></figure>

<h2 id="针对模块进行可选编译配置"><a href="#针对模块进行可选编译配置" class="headerlink" title="针对模块进行可选编译配置"></a>针对模块进行可选编译配置</h2><p>在CMakeLists.txt中</p>
<ol>
<li>使用option()函数定义变量<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">option(USE_MYMATH &quot;使用MyMathlibrary&quot; ON)</span><br><span class="line">if(USE_MYMYTH)</span><br><span class="line">    add_subdirectory(MathFunctions)</span><br><span class="line">    # 定义一个EXTRA_LIBS数组，包含MathFunctions库</span><br><span class="line">    list(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line">    # 定义一个EXTRA_INCLUDES数组，包含MathFunctions的头文件目录</span><br><span class="line">    list(APPEND EXTRA_INCLUDES &quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;)</span><br><span class="line">    # 添加头文件和lib依赖</span><br><span class="line">    target_link_libraries(Tutorial PUBLIC $&#123;EXTRA_LIBS&#125;)</span><br><span class="line">    target_include_directories(Tutorial PUBLIC </span><br><span class="line">                            $&#123;EXTRA_INCLUDES&#125;</span><br><span class="line">                            )</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMake官网</a></p>
]]></content>
  </entry>
  <entry>
    <title>WSL相关</title>
    <url>//pages/81e31d/</url>
    <content><![CDATA[<p>WSL(Windows subsystem for Linux),windows下的linux子系统。</p>
<h2 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h2><p>安装可以参考<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">官方文档</a></p>
<p>默认安装是安装在系统盘，考虑到后期拉源码，编译会占用大量的空间，将它安装在其他盘，总结一下简单流程：</p>
<ol>
<li><p>启用适用于Linux的windows子系统</p>
<p>以管理员身份打开powershell，运行以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>

<p>或者直接通过可视化界面操作：</p>
<p>控制面板——卸载程序——启用或关闭windows功能——勾选“适用于Linux的Windows子系统”</p>
</li>
<li><p>启用虚拟机功能，以便于将WSL2设置为默认版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>

<p>或者直接通过可视化界面操作：</p>
<p>控制面板——卸载程序——启用或关闭windows功能——勾选“虚拟机平台”</p>
<p>还需要下载<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">Linux内核更新包</a></p>
</li>
<li><p>将WSL2设置为默认</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>


</li>
<li><p>将wsl安装在指定目录，需要下载<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#downloading-distributions">wsl linux发行版</a>，然后安装</p>
</li>
<li><p>下载下来的是一个.appx的文件，将其后缀从.appx改为.zip，并解压</p>
</li>
<li><p>解压后，目录下有对应的.exe可执行文件，双击运行即可进行安装。</p>
</li>
<li><p>安装完成后，会让进行用户名和密码设置。</p>
</li>
</ol>
<p>wsl2会存在内存占用高的问题，在用户目录下新建.wslconfig，配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=8GB</span><br><span class="line">swap=16GB</span><br><span class="line">localhostForwarding=true</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>WSL2还存在空间不足的情况，需要扩容</p>
<p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/vhd-size">https://docs.microsoft.com/zh-cn/windows/wsl/vhd-size</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.进入磁盘分区</span><br><span class="line">diskpart</span><br><span class="line">2.选择虚拟盘</span><br><span class="line">Select vdisk file=&quot;E:\wsl\Ubuntu_1804.2019.522.0_x64\ext4.vhdx&quot;</span><br><span class="line">3.查看详情</span><br><span class="line">detail vdisk</span><br><span class="line">4.扩容(单位MB)</span><br><span class="line">expand vdisk maximum=870400</span><br><span class="line">5.退出</span><br><span class="line">exit</span><br><span class="line">6.进入wsl，更新容量</span><br><span class="line">sudo mount -t devtmpfs none /dev</span><br><span class="line">mount | grep ext4</span><br><span class="line">复制此项的名称，该名称类似于：/dev/sdXX（X 表示任何其他字符</span><br><span class="line">sudo resize2fs /dev/sdb 870400M</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="挂载额外的磁盘"><a href="#挂载额外的磁盘" class="headerlink" title="挂载额外的磁盘"></a>挂载额外的磁盘</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/wsl2-mount-disk#mount-a-vhd-in-wsl">https://learn.microsoft.com/zh-cn/windows/wsl/wsl2-mount-disk#mount-a-vhd-in-wsl</a></p>
<p>windows家庭版没有Hyper-V,需要先安装</p>
<p>创建bat脚本，内容如下，然后以管理员身份运行，执行完后重启即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line"></span><br><span class="line">dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hv.txt</span><br><span class="line"></span><br><span class="line">for /f %%i in (&#x27;findstr /i . hv.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span><br><span class="line"></span><br><span class="line">del hv.txt</span><br><span class="line"></span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V -All /LimitAccess /ALL</span><br><span class="line"></span><br><span class="line">Pause</span><br></pre></td></tr></table></figure>



<p>需要在PowerShell中以管理员身份运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建一个虚拟磁盘</span><br><span class="line">New-VHD -Path D:\wsl\extern.vhdx -SizeBytes 300GB</span><br><span class="line">2.将虚拟磁盘挂载到Windows中，并输出磁盘路径</span><br><span class="line">Write-Output &quot;\\.\PhysicalDrive$((Mount-VHD -Path &lt;pathToVHD&gt; -PassThru | Get-Disk).Number)&quot;</span><br><span class="line">查看所有可用磁盘</span><br><span class="line">GET-CimInstance -query &quot;SELECT * from Win32_DiskDrive&quot;</span><br><span class="line">3.连接磁盘，但不挂载，DiskPath 类似 \\.\PHYSICALDRIVEX</span><br><span class="line">wsl --mount &lt;DiskPath&gt; --bare</span><br></pre></td></tr></table></figure>

<p>进入wsl为连接的虚拟磁盘创建ext4文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.查看所有磁盘，类似sda、sdb、sdc...</span><br><span class="line">lsblk</span><br><span class="line">2.为连接的磁盘创建ext4文件系统,sdX中的X实际挂载会有所不同</span><br><span class="line">sudo mkfs.ext4 /dev/sdX</span><br></pre></td></tr></table></figure>

<p>在PowerShell中重新挂载创建好文件系统的虚拟磁盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --unmount &lt;DiskPath&gt;</span><br><span class="line">wsl --mount &lt;DiskPath&gt;</span><br></pre></td></tr></table></figure>





<p>free 查看内存</p>
<p>df 查看挂载的磁盘分区</p>
<p>图形化:<a href="https://zhuanlan.zhihu.com/p/435832206">https://zhuanlan.zhihu.com/p/435832206</a></p>
<h2 id="更换wsl路径"><a href="#更换wsl路径" class="headerlink" title="更换wsl路径"></a>更换wsl路径</h2><p>官方版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 查看本地的 wsl列表</span><br><span class="line">wsl -l -v</span><br><span class="line">2. 将需要迁移的系统导出为tar</span><br><span class="line">wsl --export &lt;Distro&gt; &lt;FileName&gt;</span><br><span class="line">wsl --export Ubuntu-18.04 E:\wsl\wsl_ubuntu1804.tar</span><br><span class="line">3. 将原来的系统注销</span><br><span class="line">wsl --unregister Ubuntu-18.04</span><br><span class="line">4. 将导出的tar导入到新的路径</span><br><span class="line">wsl --import &lt;Distro&gt; &lt;InstallLocation&gt; &lt;FileName&gt;</span><br><span class="line">wsl --import Ubuntu-18.04 E:\wsl\Ubuntu_1804.2019.522.0_x64 E:\wsl\wsl_ubuntu1804.tar</span><br><span class="line">5. 设置默认登陆用户名</span><br><span class="line">进入到子系统安装目录，包含ubuntuxxxx.exe</span><br><span class="line">执行 ubuntu config --default-user &lt;username&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://zhuanlan.zhihu.com/p/338280729">https://zhuanlan.zhihu.com/p/338280729</a></p>
<p>发现原来wsl的配置是保存在注册表中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直接手动移动vhdx镜像文件。然后修改注册表</span><br><span class="line">1. 编辑注册表</span><br><span class="line">cmd运行regedit 打开注册表</span><br><span class="line">2. [HKEY_USERS\【SID】\SOFTWARE\Microsoft\Windows\CurrentVersion\Lxss\&#123;【UUID】&#125;]</span><br><span class="line">SID可以通过 whoami /USER查看</span><br><span class="line">不同UUID代表不同的wsl实例</span><br><span class="line">3. 修改BasePath就是修改vhdx的路径。</span><br></pre></td></tr></table></figure>



<p>先安装，然后将原来的目录改成和新安装的目录一样的名字，用原来的将其替换</p>
<h2 id="将AOSP源码放在Windows文件系统中进行编译"><a href="#将AOSP源码放在Windows文件系统中进行编译" class="headerlink" title="将AOSP源码放在Windows文件系统中进行编译"></a>将AOSP源码放在Windows文件系统中进行编译</h2><p>WSL2存在跨系统访问IO读写慢的问题，将源码放在WSL中，在windows下使用IDE导入源码会很卡</p>
<p>但是源码放在windows下，在wsl中进行编译会报错，说不支持大小写不敏感的文件系统,所以在下载源码之前先做一些准备工作：</p>
<p>先通过windows下的fsutil启用目录的大小写敏感属性</p>
<p>以管理员身份运行cmd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询</span><br><span class="line">fsutil file queryCaseSensitiveInfo C:\TempFolder</span><br><span class="line"># 设置</span><br><span class="line">fsutil file setCaseSensitiveInfo &lt;目录名称&gt; [&lt;enable&gt;|&lt;disable&gt;]</span><br><span class="line">fsutil file setCaseSensitiveInfo C:\TempFolder enable</span><br></pre></td></tr></table></figure>

<p>但后续编译时，又出现新的问题：<br><code>Failed to listen for path logs: listen unix out/.path_interposer_log: bind: operation not supported</code></p>
<p>github上有人给出了解决方法<br><a href="https://github.com/microsoft/WSL/issues/7283">https://github.com/microsoft/WSL/issues/7283</a></p>
<p>wsl中重新挂载aosp文件夹所在的盘符，指定文件系统为drvfs，以D盘为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo umount /mnt/d</span><br><span class="line">sudo mount -t drvfs d: /mnt/d -o metadata</span><br></pre></td></tr></table></figure>

<p>接下来就可以将源码下载到开启了大小写敏感的目录下，在wsl中进行编译了</p>
<h2 id="添加公钥后SSH还是没权限"><a href="#添加公钥后SSH还是没权限" class="headerlink" title="添加公钥后SSH还是没权限"></a>添加公钥后SSH还是没权限</h2><p>可以添加 -Tvvv 输出debug信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -Tvvv -p port user@host</span><br></pre></td></tr></table></figure>

<p>考虑是生成的key有问题，或是需要配置加密方式</p>
<h2 id="释放wsl2占用的空间"><a href="#释放wsl2占用的空间" class="headerlink" title="释放wsl2占用的空间"></a>释放wsl2占用的空间</h2><p><a href="https://segmentfault.com/a/1190000040999582?sort=votes">https://segmentfault.com/a/1190000040999582?sort=votes</a></p>
<p>WSL2 本质上是虚拟机，所以 Windows 会自动创建 vhdx 后缀的虚拟磁盘文件作为存储。这个 vhdx 后缀的虚拟磁盘文件特点是可以自动扩容，但是一般不会自动缩容。一旦有很多文件把它“撑大”，即使把这些文件删除它也不会自动“缩小”。所以删除文件后还需要我们手动进行压缩才能释放磁盘空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line"># 挂载为只读，然后将不用的块填零</span><br><span class="line">mount /dev/sdb -o remount,ro</span><br><span class="line">zerofree /dev/sdb</span><br><span class="line"># 关闭wsl</span><br><span class="line">wsl --shutdown</span><br><span class="line"># 压缩优化虚拟磁盘</span><br><span class="line">Optimize-VHD -Path .\ext4.vhdx -Mode Quick</span><br><span class="line">Optimize-VHD -Path .\ext4.vhdx -Mode Full</span><br></pre></td></tr></table></figure>

<p>到这里完成了物理空间上的释放，但是虚拟磁盘的虚拟空间还是没变<br>可以通过Get-VHD 来查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-VHD E:\wsl\Ubuntu_1804.2019.522.0_x64\ext4.vhdx</span><br></pre></td></tr></table></figure>

<h2 id="win11家庭版启用组策略"><a href="#win11家庭版启用组策略" class="headerlink" title="win11家庭版启用组策略"></a>win11家庭版启用组策略</h2><p>Windows 11 家庭版的用户，仍可通过三种可行的方法来添加并启用组策略编辑器。原因是，这个软件包或称组件包、工具包原本就存在于系统之中，只是家庭版默认没有将其添加与安装，所以你无法使用它 </p>
<p>创建bat脚本，内容如下，然后以管理员身份运行，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line">dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt</span><br><span class="line">dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt</span><br><span class="line">for /f %%i in (&#x27;findstr /i . List.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;C:\Windows\servicing\Packages\%%i&quot;</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>然后 gpedit.msc &#x3D;&gt; 计算机配置 &#x3D;&gt; Widows设置 &#x3D;&gt; 安全设置 &#x3D;&gt; 本地策略<br>&#x3D;&gt; 用户权限分配 &#x3D;&gt; 创建符号链接 添加用户组</p>
<p>让windows下可以进行软连接</p>
]]></content>
  </entry>
  <entry>
    <title>gradle记录</title>
    <url>//pages/c5cc0d/</url>
    <content><![CDATA[<h2 id="导入framework-jar"><a href="#导入framework-jar" class="headerlink" title="导入framework.jar"></a>导入framework.jar</h2><p><a href="https://chauyan.dev/2022/01/23/Import-Android-Framework-Jar">https://chauyan.dev/2022/01/23/Import-Android-Framework-Jar</a></p>
<p>AS4.2之前:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle.projectsEvaluated &#123;</span><br><span class="line">	tasks.withType(JavaCompile) &#123;</span><br><span class="line">		options.compilerArgs.add(&#x27;-Xbootclasspath/p:app/sdk/framework.jar&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AS4.2之后:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle.projectsEvaluated &#123;  </span><br><span class="line">    tasks.withType(JavaCompile) &#123;  </span><br><span class="line">        Set&lt;File&gt; fileSet = options.bootstrapClasspath.getFiles()  </span><br><span class="line">        List&lt;File&gt; newFileList = new ArrayList&lt;&gt;();  </span><br><span class="line">        newFileList.add(new File(&quot;./app/sdk/framework.jar&quot;))  </span><br><span class="line">        newFileList.addAll(fileSet)  </span><br><span class="line">        options.bootstrapClasspath = files(newFileList.toArray())  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">gradle.projectsEvaluated &#123;</span><br><span class="line">    tasks.withType(JavaCompile).configureEach &#123;</span><br><span class="line">        // 获取原始 bootstrapClasspath 的文件集合</span><br><span class="line">        Set&lt;File&gt; fileSet = options.bootstrapClasspath.getFiles()</span><br><span class="line"></span><br><span class="line">        // 使用更简洁的语法，直接添加新的 JAR 文件，并合并到原有的 bootstrapClasspath</span><br><span class="line">        options.bootstrapClasspath = files(</span><br><span class="line">                &#x27;libs/framework.jar&#x27;,  // 直接加入自定义的 JAR 文件</span><br><span class="line">                *fileSet.toArray()     // 将原始 bootstrapClasspath 中的文件添加进来</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在根目录下的build.gradle中对所有子项目进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def sortJar(String moduleName) &#123;</span><br><span class="line">    String imlPath = &quot;$&#123;projectDir&#125;/.idea/modules/$&#123;moduleName&#125;/$&#123;rootProject.name&#125;.$&#123;moduleName&#125;.main.iml&quot;</span><br><span class="line">    println imlPath</span><br><span class="line">    File imlFile = new File(imlPath)</span><br><span class="line">    if (imlFile.exists()) &#123;</span><br><span class="line">        // 解析 .iml 文件</span><br><span class="line">        def parsedIml = new XmlParser().parse(imlFile)</span><br><span class="line">        // 查找 &lt;component&gt; 元素，找到特定 name 属性的 component</span><br><span class="line">        def component = parsedIml.&#x27;component&#x27;.find &#123; it.@name == &#x27;NewModuleRootManager&#x27; &#125;</span><br><span class="line">        // 查找 type=&quot;jdk&quot; 的 &lt;orderEntry&gt; 元素</span><br><span class="line">        def orderEntry = component.&#x27;orderEntry&#x27;.find &#123; it.@type == &#x27;jdk&#x27; &#125;</span><br><span class="line">        // 如果找到了 orderEntry，就将其移动到最后</span><br><span class="line">        if (orderEntry) &#123;</span><br><span class="line">            println &quot;处理 $&#123;imlFile&#125;&quot;</span><br><span class="line">            // 从 &lt;component&gt; 元素中移除原来的 orderEntry 元素</span><br><span class="line">            component.remove(orderEntry)</span><br><span class="line">            // 将 &lt;orderEntry&gt; 添加到 &lt;component&gt; 的最后</span><br><span class="line">            component.append(orderEntry)</span><br><span class="line">            groovy.xml.XmlUtil.serialize(parsedIml, new FileOutputStream(imlFile))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println &quot;xxx 文件 $&#123;imlPath&#125; 不存在&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subprojects &#123;</span><br><span class="line">    gradle.projectsEvaluated &#123;</span><br><span class="line">        tasks.withType(JavaCompile).configureEach &#123;</span><br><span class="line">            //先取到原始的bootstrapClasspath包含的文件</span><br><span class="line">            Set&lt;File&gt; fileSet = options.bootstrapClasspath.files</span><br><span class="line">            //由于bootstrapClasspath中的files是只读的，只有get方法，没有set方法没法重新给files赋值，</span><br><span class="line">            // 但是options中有bootstrapClasspath的set方法，所以重新创建一个bootstrapClasspath</span><br><span class="line">            options.setBootstrapClasspath(files(</span><br><span class="line">                    &quot;framework.jar&quot;,</span><br><span class="line">                    fileSet.toArray()</span><br><span class="line">            ))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //对每个子项目的的android sdk jar进行排序到最后的处理</span><br><span class="line">    sortJar(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版本的Android Studio使用gradle默认没有生成.iml,可以在设置中打开<br>file–settings–Build,Excution,Deployment–Build Tools–Gradle–Generate *.iml files for modules imported from Gradle</p>
<ol>
<li>gradle.projectsEvaluated<br>作用：projectsEvaluated 是一个 Gradle 生命周期钩子，它会在所有项目的评估（evaluation）完成后触发。这意味着 Gradle 已经解析了所有的项目和任务，但尚未开始执行任务。<br>用法：当你需要在 Gradle 构建配置完成后再执行某些操作时，使用 projectsEvaluated 钩子。这个钩子通常用于修改构建配置，例如修改任务的行为或者添加额外的配置。</li>
<li>tasks.withType(JavaCompile)<br>作用：tasks.withType(JavaCompile) 是 Gradle 中的任务选择器，返回所有类型为 JavaCompile 的任务。这些任务负责 Java 源代码的编译。</li>
<li>configureEach<br>作用：configureEach 是一个配置任务的方式，表示对 JavaCompile 类型的每个任务进行配置。对于每一个匹配的 JavaCompile 任务，都会执行 configureEach 中的代码。<br>用途：你可以在这里对每个 JavaCompile 任务进行修改，比如修改它的属性或添加新的配置。</li>
</ol>
<h2 id="通过本地插件实现倒入framework-jar"><a href="#通过本地插件实现倒入framework-jar" class="headerlink" title="通过本地插件实现倒入framework.jar"></a>通过本地插件实现倒入framework.jar</h2><p>新建一个library项目，在build.gradle中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    `java-gradle-plugin` //用java实现插件的插件</span><br><span class="line">    `maven-publish`     //将插件发布到仓库的插件</span><br><span class="line">&#125;</span><br><span class="line">//java-gradle-plugin 这个插件需要的配置</span><br><span class="line">gradlePlugin &#123;</span><br><span class="line">    plugins &#123;</span><br><span class="line">        //创建一个叫localfwjar的插件</span><br><span class="line">        create(&quot;localfwjar&quot;) &#123;</span><br><span class="line">            id = &quot;com.local.cusplugins.localfwjar&quot;</span><br><span class="line">            //这个时插件实现的类</span><br><span class="line">            implementationClass = &quot;com.local.cusplugins.LocalFrameworkJar&quot;</span><br><span class="line">            version = &quot;1.0.0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java &#123;</span><br><span class="line">    toolchain &#123;</span><br><span class="line">        languageVersion = JavaLanguageVersion.of(11)  // 指定插件使用 Java 11</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">afterEvaluate &#123;</span><br><span class="line">    //maven-publish这个插件相关的配置</span><br><span class="line">    publishing &#123;</span><br><span class="line">        publications &#123;</span><br><span class="line">            create&lt;MavenPublication&gt;(&quot;LocalFrameworkJar&quot;) &#123;</span><br><span class="line">                groupId = &quot;com.local.repo&quot;</span><br><span class="line">                artifactId = &quot;LocalFrameworkJar&quot;</span><br><span class="line">                version = &quot;1.0.0&quot;</span><br><span class="line">                from(components[&quot;java&quot;])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            maven &#123;</span><br><span class="line">                //本地仓库地址</span><br><span class="line">                url = uri(&quot;../repo&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在com.local.cusplugins包下创建一个LocalFrameworkJar.java文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LocalFrameworkJar implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    private String jarPath;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void apply(Project target) &#123;</span><br><span class="line">        System.out.println(&quot;apply localfwjar from &quot; + target);</span><br><span class="line">        //创建一个扩展配置，名字叫frameworkJar</span><br><span class="line">        FrameworkJar frameworkJar = target.getExtensions().create(&quot;frameworkJar&quot;, FrameworkJar.class);</span><br><span class="line">        //扩展设置默认配置值</span><br><span class="line">        frameworkJar.getJarPath().convention(&quot;&quot;);</span><br><span class="line">        //在配置处理完毕之后</span><br><span class="line">        target.afterEvaluate(new Action&lt;Project&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void execute(Project project) &#123;</span><br><span class="line">                jarPath = frameworkJar.getJarPath().get();</span><br><span class="line">                if (jarPath.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(&quot;framework jar路径未配置，无法使用localfwjar插件，配置示例：\n&quot; +</span><br><span class="line">                            &quot;frameworkJar &#123;\n&quot; +</span><br><span class="line">                            &quot;    jarPath = \&quot;/home/test/framework/framework.jar\&quot;\n&quot; +</span><br><span class="line">                            &quot;&#125;&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;framework jar路径：&quot; + jarPath);</span><br><span class="line">                addFrameworkJarConfig(target, jarPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addFrameworkJarConfig(Project project, String jarPath) &#123;</span><br><span class="line">        //添加依赖</span><br><span class="line">        project.getDependencies().add(&quot;compileOnly&quot;, project.files(jarPath));</span><br><span class="line">        //添加编译前，优先使用framework jar的逻辑</span><br><span class="line">        project.getTasks().withType(JavaCompile.class).forEach(new Consumer&lt;JavaCompile&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(JavaCompile javaCompile) &#123;</span><br><span class="line">                javaCompile.doFirst(new Action&lt;Task&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void execute(Task task) &#123;</span><br><span class="line">                        JavaCompile javaCompile = (JavaCompile) task;</span><br><span class="line">                        CompileOptions javaCompileOptions = javaCompile.getOptions();</span><br><span class="line">                        FileCollection bootstrapClasspath = javaCompileOptions.getBootstrapClasspath();</span><br><span class="line">                        if (bootstrapClasspath != null) &#123;</span><br><span class="line">                            //配置了bootstrapClasspath，将jarPath添加进去</span><br><span class="line">                            Set&lt;File&gt; files = bootstrapClasspath.getFiles();</span><br><span class="line">                            bootstrapClasspath = project.files(jarPath, files);</span><br><span class="line">                            javaCompileOptions.setBootstrapClasspath(bootstrapClasspath);</span><br><span class="line">                            System.out.println(javaCompile.getName() + &quot; config bootstrapClasspath = &quot; + bootstrapClasspath.getFiles());</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            FileCollection classpath = javaCompile.getClasspath();</span><br><span class="line">                            classpath = project.files(jarPath, classpath.getFiles());</span><br><span class="line">                            javaCompile.setClasspath(classpath);</span><br><span class="line">                            System.out.println(javaCompile.getName() + &quot;config classpath = &quot; + classpath.getFiles());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于需要动态配置jar的路径，需要额外创建一个类来定义配置，创建FrameworkJar.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract public class FrameworkJar &#123;</span><br><span class="line">     abstract public Property&lt;String&gt; getJarPath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意implementationClass不是文件名称,是class名字,不要有文件名后缀,不然class加载会不成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">遇到报错:</span><br><span class="line">Unable to load class &#x27;com.local.plugins.LocalPlugin.java&#x27;</span><br><span class="line">com.local.plugins.LocalPlugin.java</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>AndroidStudio</title>
    <url>//pages/3e2de4/</url>
    <content><![CDATA[<h2 id="AndroidStudio-IBUS中文输入异常"><a href="#AndroidStudio-IBUS中文输入异常" class="headerlink" title="AndroidStudio IBUS中文输入异常"></a>AndroidStudio IBUS中文输入异常</h2><p>ubuntu下使用默认IBUS输入法，在AndroidStudio中输入中文时，不显示待选中文，输入后一直显示一条下划线</p>
<ol>
<li>点击菜单 “Help | Edit Custom VM options…”</li>
<li>添加 -Drecreate.x11.input.method&#x3D;true 到最后一行</li>
<li>重启IDEA</li>
</ol>
<h2 id="生成桌面图标"><a href="#生成桌面图标" class="headerlink" title="生成桌面图标"></a>生成桌面图标</h2><p>Tools–Create Desktop Entry</p>
<h2 id="修改默认Project视图"><a href="#修改默认Project视图" class="headerlink" title="修改默认Project视图"></a>修改默认Project视图</h2><p>要将默认视图从 Android 视图更改为 Project 视图，请依次选择 Help &gt; Edit Custom Properties 并添加 studio.projectview&#x3D;true。</p>
<h2 id="project-structure"><a href="#project-structure" class="headerlink" title="project structure"></a>project structure</h2><ol>
<li>File – Project Structure (Ctrl alt shift s)</li>
<li>项目右键 – Open Module Settings （F4）</li>
</ol>
<h2 id="定制toolbar"><a href="#定制toolbar" class="headerlink" title="定制toolbar"></a>定制toolbar</h2><p>File – Settings – Appearance &amp; Behavior – Menus and Toolbars</p>
<h2 id="每次都下载gradle"><a href="#每次都下载gradle" class="headerlink" title="每次都下载gradle"></a>每次都下载gradle</h2><p>配置环境变量 GRADLE_HOME ， GRADLE_USER_HOME</p>
<ul>
<li>GRADLE_HOME<br>  Gradle 的安装目录。可以用来指定本地 Gradle 版本，而不是使用包装器。</li>
<li>GRADLE_USER_HOME<br>  Gradle 存储其全局配置属性、初始化脚本、缓存、日志文件等的目录。若未设置，则默认为USER_HOME&#x2F;.gradle<br>  jar都会下载到GRADLE_USER_HOME&#x2F;caches&#x2F;modules-2&#x2F;files-2.1下面</li>
</ul>
<p>在android studio中指定gradle user home<br>第一次可以配置代理下载</p>
]]></content>
  </entry>
  <entry>
    <title>Ubuntu串口连接</title>
    <url>//pages/fb0dca/</url>
    <content><![CDATA[<h2 id="Ubuntu串口工具"><a href="#Ubuntu串口工具" class="headerlink" title="Ubuntu串口工具"></a>Ubuntu串口工具</h2><p>使用GtkTerm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gtkterm</span><br></pre></td></tr></table></figure>

<h2 id="查看串口设备"><a href="#查看串口设备" class="headerlink" title="查看串口设备"></a>查看串口设备</h2><p>连接usb转串口线到PC，通过终端输入<code>dmesg</code>来查看串口地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[349190.387319] usb 1-8: new full-speed USB device number 22 using xhci_hcd</span><br><span class="line">[349190.540168] usb 1-8: New USB device found, idVendor=067b, idProduct=2303, bcdDevice= 3.00</span><br><span class="line">[349190.540179] usb 1-8: New USB device strings: Mfr=1, Product=2, SerialNumber=0</span><br><span class="line">[349190.540182] usb 1-8: Product: USB-Serial Controller</span><br><span class="line">[349190.540185] usb 1-8: Manufacturer: Prolific Technology Inc.</span><br><span class="line">[349190.541766] pl2303 1-8:1.0: pl2303 converter detected</span><br><span class="line">[349190.542386] usb 1-8: pl2303 converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure>
<p>其中ttyUSB0就是串口设备地址</p>
<p>打开gtkterm后端口选择&#x2F;dev&#x2F;ttyUSB0，配置波特率即可</p>
]]></content>
  </entry>
  <entry>
    <title>Ubuntu非root用户80端口</title>
    <url>//pages/bd08cb/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在ubuntu上通过nodejs部署服务时，配置的80端口，但是服务起来使用的是1024端口</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>监听低于1024的端口需要root权限。</p>
<h2 id="让非root用户可以监听1024以下的端口"><a href="#让非root用户可以监听1024以下的端口" class="headerlink" title="让非root用户可以监听1024以下的端口"></a>让非root用户可以监听1024以下的端口</h2><p><code>setcap cap_net_bind_service=+ep</code>是一个Linux命令，用于授予二进制文件绑定网络套接字端口的能力。将此命令与可执行文件的路径一起使用，可以让该文件在不需要root权限的情况下监听低于1024的端口。</p>
<p>具体而言，cap_net_bind_service是一种称为”capability”的Linux安全机制，允许特定的进程拥有仅限于root用户才有的权限。使用setcap命令，可以将这些特殊权限授予其他用户或进程，以便它们可以执行受限制的任务，而不需要完全的root访问权限。</p>
<p>在上述命令中，cap_net_bind_service表示要授予的能力，而+ep则表示要将该能力添加到文件的现有能力集中。+ep的含义如下：</p>
<ul>
<li>e 表示”effective”，使能力对该二进制文件的运行时有效。</li>
<li>p 表示”permanent”，将能力授予文件的能力集，以便在文件重新启动时保留该能力。<br>因此，当您使用该命令时，请确保将其与要授予能力的文件路径一起使用，并使用sudo或root用户权限运行该命令。例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo setcap cap_net_bind_service=+ep /path/to/your/executable/file</span><br></pre></td></tr></table></figure>
请注意，在某些情况下，可能还需要修改防火墙规则或端口绑定配置，以便确保该文件可以成功地绑定所需的端口。</li>
</ul>
<p>所以通过nodejs部署的服务器，可以通过如下指令，让非root用户启动的nodejs服务监听80端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo setcap &#x27;cap_net_bind_service=+ep&#x27; /usr/bin/node</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Linux常用指令</title>
    <url>//pages/7cb586/</url>
    <content><![CDATA[<h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br><span class="line">uname -a</span><br><span class="line">hostnamectl</span><br><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure>

<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure>

<h2 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>

<h2 id="查看目录占用空间"><a href="#查看目录占用空间" class="headerlink" title="查看目录占用空间"></a>查看目录占用空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du -h -d1</span><br></pre></td></tr></table></figure>

<h2 id="quota磁盘限额"><a href="#quota磁盘限额" class="headerlink" title="quota磁盘限额"></a>quota磁盘限额</h2><p>查看限额情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quota -s</span><br></pre></td></tr></table></figure>

<h2 id="dock栏独立"><a href="#dock栏独立" class="headerlink" title="dock栏独立"></a>dock栏独立</h2><p>在ubuntu上多个工作区共用的一个dock栏，想要每个工作区单独使用dock栏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock isolate-workspaces true</span><br></pre></td></tr></table></figure>

<h2 id="dock栏的快捷键"><a href="#dock栏的快捷键" class="headerlink" title="dock栏的快捷键"></a>dock栏的快捷键</h2><p>在ubuntu上，dock栏有一系列的快捷键，设置里好像没有看见相关设置。<br>例如：super+数字 会打开docke栏上对应的应用程序<br>其他快捷键可以通过gsettings查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gsettings list-recursively org.gnome.shell.extensions.dash-to-dock</span><br></pre></td></tr></table></figure>
<p>禁用dock栏的快捷键可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock hot-keys false</span><br></pre></td></tr></table></figure>

<h2 id="ubuntu的指令补全"><a href="#ubuntu的指令补全" class="headerlink" title="ubuntu的指令补全"></a>ubuntu的指令补全</h2><p><a href="https://www.shuzhiduo.com/A/l1dyvokqze/">https://www.shuzhiduo.com/A/l1dyvokqze/</a><br><a href="https://blog.csdn.net/qq_40632245/article/details/136352683">https://blog.csdn.net/qq_40632245/article/details/136352683</a></p>
<h2 id="ubuntu图标配置存放路径"><a href="#ubuntu图标配置存放路径" class="headerlink" title="ubuntu图标配置存放路径"></a>ubuntu图标配置存放路径</h2><p>对所有用户有效: &#x2F;usr&#x2F;share&#x2F;applications 以及 &#x2F;usr&#x2F;local&#x2F;share&#x2F;applications</p>
<p>仅当前用户有效: ~&#x2F;.local&#x2F;share&#x2F;applications</p>
<p><a href="https://blog.csdn.net/jiang_huixin/article/details/107092622">https://blog.csdn.net/jiang_huixin/article/details/107092622</a></p>
<h2 id="自启路径"><a href="#自启路径" class="headerlink" title="自启路径"></a>自启路径</h2><p>~&#x2F;.config&#x2F;autostart</p>
<h2 id="Linux三剑客"><a href="#Linux三剑客" class="headerlink" title="Linux三剑客"></a>Linux三剑客</h2><ul>
<li>grep 查找匹配文本</li>
<li>sed  编辑匹配到的文本</li>
<li>awk  格式化文本（文本处理）</li>
</ul>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>可以参考:<a href="https://blog.csdn.net/m0_57515995/article/details/125713566">https://blog.csdn.net/m0_57515995&#x2F;article&#x2F;details&#x2F;125713566</a></p>
<p>awk 语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk [Options] [Program] [file ...]</span><br></pre></td></tr></table></figure>
<p>主要关注<code>Program</code>,通过<code>man awk</code>可以看到对program的解释，格式是 正则{action}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An AWK program is a sequence of pattern &#123;action&#125; pairs and user function definitions.</span><br><span class="line"></span><br><span class="line">A pattern can be:</span><br><span class="line">     BEGIN</span><br><span class="line">     END</span><br><span class="line">     expression</span><br><span class="line">     expression , expression</span><br><span class="line"></span><br><span class="line">One, but not both, of pattern &#123;action&#125; can be omitted.  If &#123;action&#125; is omitted it  is  im‐</span><br><span class="line">plicitly  &#123; print &#125;.  If pattern is omitted, then it is implicitly matched.  BEGIN and END</span><br><span class="line">patterns require an action.</span><br></pre></td></tr></table></figure>
<p>正则匹配要操作的文本，{action}是对匹配到的文本进行处理,最常用到的就是print</p>
<p>awk中正则一般用<code>//</code>包裹起来，<code>~</code>为匹配，<code>!~</code>为不匹配，<br>例如 打印第一个字段包含test的 指令：<code>awk &#39;$1~/test/&#123;print&#125;&#39; file</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. Regular expressions</span><br><span class="line">       In the AWK language, records, fields and strings are often tested for matching  a  regular</span><br><span class="line">       expression.  Regular expressions are enclosed in slashes, and</span><br><span class="line"></span><br><span class="line">            expr ~ /r/</span><br><span class="line"></span><br><span class="line">       is  an  AWK expression that evaluates to 1 if expr “matches” r, which means a substring of</span><br><span class="line">       expr is in the set of strings defined by r.  With no match the expression evaluates to  0;</span><br><span class="line">       replacing  ~ with the “not match” operator, !~ , reverses the meaning.  As  pattern-action</span><br><span class="line">       pairs,</span><br><span class="line"></span><br><span class="line">            /r/ &#123; action &#125;   and   $0 ~ /r/ &#123; action &#125;</span><br><span class="line"></span><br><span class="line">       are the same, and for each input record that matches r, action is executed.  In fact,  /r/</span><br><span class="line">       is  an  AWK  expression that is equivalent to ($0 ~ /r/) anywhere except when on the right</span><br><span class="line">       side of a match operator or passed as an argument to a built-in function  that  expects  a</span><br><span class="line">       regular expression argument.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>awk是逐行读取的，每一行保存在变量$0中，然后每一行被分割成多个字段，每个字段依次保存在$1,$2,…,$NF中，<br>其中 $NF 表示最后一个字段。内建变量 NF 表示每一行字段的数量，而 NR 和 FNR 随着行数递增1。超过 $NF 的字段会被设为 “”</p>
<pre><code>4. Records and fields
       Records are read in one at a time, and stored in the field variable  $0.   The  record  is
       split  into  fields which are stored in $1, $2, ..., $NF.  The built-in variable NF is set
       to the number of fields, and NR and FNR are incremented by 1.  Fields above $NF are set to
       &quot;&quot;.

       Assignment  to  $0  causes  the  fields and NF to be recomputed.  Assignment to NF or to a
       field causes $0 to be reconstructed by concatenating the $i&#39;s separated by  OFS.   Assign‐
       ment  to  a  field  with  index  greater  than NF, increases NF and causes $0 to be recon‐
       structed.

       Data input stored in fields is string, unless the entire field has numeric form  and  then
       the type is number and string.  For example,

            echo 24 24E |
            mawk &#39;&#123; print($1&gt;100, $1&gt;&quot;100&quot;, $2&gt;100, $2&gt;&quot;100&quot;) &#125;&#39;
            0 1 1 1

       $0  and  $2  are string and $1 is number and string.  The first comparison is numeric, the
       second is string, the third is string (100 is converted to &quot;100&quot;), and the last is string.
</code></pre>
<p>一些常用的内置变量</p>
<table>
<thead>
<tr>
<th align="left">内置变量</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$0</td>
<td align="left">当前处理行的内容</td>
</tr>
<tr>
<td align="left">NF</td>
<td align="left">当前行分割出来的字段数量</td>
</tr>
<tr>
<td align="left">NR</td>
<td align="left">当前处理的行号</td>
</tr>
<tr>
<td align="left">FNR</td>
<td align="left">文件中当前处理的行号（新的文件从1开始）</td>
</tr>
<tr>
<td align="left">FS</td>
<td align="left">指定字段的分割符，默认为空格或制表符（同 -F）</td>
</tr>
<tr>
<td align="left">OFS</td>
<td align="left">输出时分割字段的符号</td>
</tr>
<tr>
<td align="left">RS</td>
<td align="left">指定每行的分割符，默认”\n”</td>
</tr>
<tr>
<td align="left">ORS</td>
<td align="left">输出时分割行的分割符</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Ubuntu问题记录</title>
    <url>//pages/ca4e4f/</url>
    <content><![CDATA[<h2 id="Ubuntu20-04无法锁屏"><a href="#Ubuntu20-04无法锁屏" class="headerlink" title="Ubuntu20.04无法锁屏"></a>Ubuntu20.04无法锁屏</h2><p>切换一下桌面环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure gdm3</span><br></pre></td></tr></table></figure>

<h2 id="状态栏和一些弹窗文字不显示"><a href="#状态栏和一些弹窗文字不显示" class="headerlink" title="状态栏和一些弹窗文字不显示"></a>状态栏和一些弹窗文字不显示</h2><p>重启gnome shell试试：</p>
<p>alt + F2 弹出命令窗口，输入R重启 gnome shell</p>
<h2 id="Evolution签名导出"><a href="#Evolution签名导出" class="headerlink" title="Evolution签名导出"></a>Evolution签名导出</h2><p>直接找到对应的路径导出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.config/evolution/signatures</span><br></pre></td></tr></table></figure>

<h2 id="安装android-studio"><a href="#安装android-studio" class="headerlink" title="安装android studio"></a>安装android studio</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TARGET_DIR=/opt/android/</span><br><span class="line">sudo tar -zxvf file.tar.gz -C $TARGET_DIR</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后续更新忘记安装的路径，根据图标来找 cat &#x2F;usr&#x2F;local&#x2F;share&#x2F;applications&#x2F;jetbrains-studio.desktop</p>
]]></content>
  </entry>
  <entry>
    <title>sqlite3操作</title>
    <url>//pages/ba0cd8/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入数据库</span><br><span class="line">sqlite3 &lt;db&gt;</span><br><span class="line"></span><br><span class="line"># 查看数据库下的所有表</span><br><span class="line">.tables</span><br><span class="line"></span><br><span class="line"># 查询结果显示列名</span><br><span class="line">.headers on</span><br><span class="line"></span><br><span class="line"># 查看当前db路径</span><br><span class="line">.database</span><br><span class="line"></span><br><span class="line"># 当前数据库状态</span><br><span class="line">.show</span><br><span class="line"></span><br><span class="line"># 退出</span><br><span class="line">.quit</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>快捷键</title>
    <url>//pages/8999da/</url>
    <content><![CDATA[<h2 id="ubuntu下常用快捷键"><a href="#ubuntu下常用快捷键" class="headerlink" title="ubuntu下常用快捷键"></a>ubuntu下常用快捷键</h2><ul>
<li>ctrl+insert  复制</li>
<li>shift+insert 粘贴</li>
<li>ctrl+shift+c 终端复制</li>
<li>ctrl+shift+v 终端粘贴</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>shell语法</title>
    <url>//pages/38cc3f/</url>
    <content><![CDATA[<h2 id="常用字符串判断"><a href="#常用字符串判断" class="headerlink" title="常用字符串判断"></a>常用字符串判断</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">param=$1</span><br><span class="line"># 注意判断条件中的[],&quot;[&quot;后和&quot;]&quot;前有空格</span><br><span class="line">if [ -n &quot;$param&quot; ]</span><br><span class="line">then</span><br><span class="line">        echo $param</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>这里记录以下常用的：</p>
<ul>
<li><p>-n 字符串不为空</p>
</li>
<li><p>-z 字符串为空</p>
</li>
<li><p>-f 文件存在并且是普通文件</p>
</li>
<li><p>-d 文件存在并且是文件夹</p>
</li>
<li><p>-eq 整数值相等</p>
</li>
<li><p>-ne 整数值不等</p>
</li>
</ul>
<p>以下是通过<code>info bash|grep -B30 -A80 -e &quot;-a file&quot;</code> 获取到的条件表达式的说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONDITIONAL EXPRESSIONS</span><br><span class="line">       Conditional expressions are used by the [[ compound command and the test and [ builtin commands to test file attributes and  perform  string</span><br><span class="line">       and  arithmetic  comparisons.   The  test  abd [ commands determine their behavior based on the number of arguments; see the descriptions of</span><br><span class="line">       those commands for any other command-specific actions.</span><br><span class="line"></span><br><span class="line">       Expressions are formed from the following unary or binary primaries.  Bash handles several filenames specially when they are used in expres‐</span><br><span class="line">       sions.   If  the  operating system on which bash is running provides these special files, bash will use them; otherwise it will emulate them</span><br><span class="line">       internally with this behavior: If any file argument to one of the primaries is of the form /dev/fd/n, then file descriptor n is checked.  If</span><br><span class="line">       the  file  argument  to one of the primaries is one of /dev/stdin, /dev/stdout, or /dev/stderr, file descriptor 0, 1, or 2, respectively, is</span><br><span class="line">       checked.</span><br><span class="line"></span><br><span class="line">       Unless otherwise specified, primaries that operate on files follow symbolic links and operate on the target of the  link,  rather  than  the</span><br><span class="line">       link itself.</span><br><span class="line"></span><br><span class="line">       When used with [[, the &lt; and &gt; operators sort lexicographically using the current locale.  The test command sorts using ASCII ordering.</span><br><span class="line"></span><br><span class="line">       -a file</span><br><span class="line">              True if file exists.</span><br><span class="line">       -b file</span><br><span class="line">              True if file exists and is a block special file.</span><br><span class="line">       -c file</span><br><span class="line">              True if file exists and is a character special file.</span><br><span class="line">       -d file</span><br><span class="line">              True if file exists and is a directory.</span><br><span class="line">       -e file</span><br><span class="line">              True if file exists.</span><br><span class="line">       -f file</span><br><span class="line">              True if file exists and is a regular file.</span><br><span class="line">       -g file</span><br><span class="line">              True if file exists and is set-group-id.</span><br><span class="line">       -h file</span><br><span class="line">              True if file exists and is a symbolic link.</span><br><span class="line">       -k file</span><br><span class="line">              True if file exists and its ``sticky&#x27;&#x27; bit is set.</span><br><span class="line">       -p file</span><br><span class="line">              True if file exists and is a named pipe (FIFO).</span><br><span class="line">       -r file</span><br><span class="line">              True if file exists and is readable.</span><br><span class="line">       -s file</span><br><span class="line">              True if file exists and has a size greater than zero.</span><br><span class="line">       -t fd  True if file descriptor fd is open and refers to a terminal.</span><br><span class="line">       -u file</span><br><span class="line">              True if file exists and its set-user-id bit is set.</span><br><span class="line">       -w file</span><br><span class="line">              True if file exists and is writable.</span><br><span class="line">       -x file</span><br><span class="line">              True if file exists and is executable.</span><br><span class="line">       -G file</span><br><span class="line">              True if file exists and is owned by the effective group id.</span><br><span class="line">       -L file</span><br><span class="line">              True if file exists and is a symbolic link.</span><br><span class="line">       -N file</span><br><span class="line">              True if file exists and has been modified since it was last read.</span><br><span class="line">       -O file</span><br><span class="line">              True if file exists and is owned by the effective user id.</span><br><span class="line">       -S file</span><br><span class="line">              True if file exists and is a socket.</span><br><span class="line">       file1 -ef file2</span><br><span class="line">              True if file1 and file2 refer to the same device and inode numbers.</span><br><span class="line">       file1 -nt file2</span><br><span class="line">              True if file1 is newer (according to modification date) than file2, or if file1 exists and file2 does not.</span><br><span class="line">       file1 -ot file2</span><br><span class="line">              True if file1 is older than file2, or if file2 exists and file1 does not.</span><br><span class="line">       -o optname</span><br><span class="line">              True  if  the shell option optname is enabled.  See the list of options under the description of the -o option to the set builtin be‐</span><br><span class="line">              low.</span><br><span class="line">       -v varname</span><br><span class="line">              True if the shell variable varname is set (has been assigned a value).</span><br><span class="line">       -R varname</span><br><span class="line">              True if the shell variable varname is set and is a name reference.</span><br><span class="line">       -z string</span><br><span class="line">              True if the length of string is zero.</span><br><span class="line">       string</span><br><span class="line">       -n string</span><br><span class="line">              True if the length of string is non-zero.</span><br><span class="line"></span><br><span class="line">       string1 == string2</span><br><span class="line">       string1 = string2</span><br><span class="line">              True if the strings are equal.  = should be used with the test command for POSIX conformance.  When used with the  [[  command,  this</span><br><span class="line">              performs pattern matching as described above (Compound Commands).</span><br><span class="line"></span><br><span class="line">       string1 != string2</span><br><span class="line">              True if the strings are not equal.</span><br><span class="line"></span><br><span class="line">       string1 &lt; string2</span><br><span class="line">              True if string1 sorts before string2 lexicographically.</span><br><span class="line"></span><br><span class="line">       string1 &gt; string2</span><br><span class="line">              True if string1 sorts after string2 lexicographically.</span><br><span class="line"></span><br><span class="line">       arg1 OP arg2</span><br><span class="line">              OP  is one of -eq, -ne, -lt, -le, -gt, or -ge.  These arithmetic binary operators return true if arg1 is equal to, not equal to, less</span><br><span class="line">              than, less than or equal to, greater than, or greater than or equal to arg2, respectively.  Arg1 and arg2 may be positive or negative</span><br><span class="line">              integers.  When used with the [[ command, Arg1 and Arg2 are evaluated as arithmetic expressions  (see ARITHMETIC EVALUATION above).</span><br></pre></td></tr></table></figure>

<h2 id="shell算术运算"><a href="#shell算术运算" class="headerlink" title="shell算术运算"></a>shell算术运算</h2><p>在 shell 中，使用 $(( )) 进行算术运算。例如：result&#x3D;$((a + b))。常用的运算符包括 +（加），-（减），*（乘），&#x2F;（除）和 %（取余）。<br>不过只支持int类型运算，更复杂的计算，如小数，或更大的数字，需要用到bc，全称是 “Basic Calculator”。它是一个任意精度的计算器语言，可以用于执行复杂的数学计算</p>
<p>$()用于命令替换，运行括号内的命令，并将输出结果替换到命令中，如将<code>echo &quot;16.2+18.7&quot;|bc</code>执行后的结果赋值给a：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=$(echo &quot;16.2+18.7&quot;|bc)</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>

<p>$(())用于算术扩展,计算括号内的表达式，并返回结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result=$((5 + 3))</span><br><span class="line">echo &quot;结果是: $result&quot;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>正则</title>
    <url>//pages/22fca8/</url>
    <content><![CDATA[<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><p>. ： 匹配除\n以外的任意一个字符</p>
<ul>
<li>：匹配前面的表达式0次或多次</li>
</ul>
<ul>
<li>： 匹配前面的表达式1次以上<br>? ：匹配前面的表达式0次或1次<br>() ：将括号中的字符串作为一个整体<br>|  ： 以或的方式匹配字符串<br>[] :字符集，方括号内的用来匹配单个字符，即所有在方括号内能被找到的字符，都匹配，（注意是匹配单个字符）</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>ssh免ip免密码登陆</title>
    <url>//pages/7a896d/</url>
    <content><![CDATA[<h2 id="shh登陆免ip"><a href="#shh登陆免ip" class="headerlink" title="shh登陆免ip"></a>shh登陆免ip</h2><p>修改ssh的配置文件<code>~/.ssh/config</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># config for 10.100.193.10</span><br><span class="line">Host server10</span><br><span class="line">	Hostname $ip</span><br><span class="line">	User $username</span><br></pre></td></tr></table></figure>
<p>后续可以通过 <code>ssh server10</code>来进行登陆</p>
<h2 id="ssh登陆免密码"><a href="#ssh登陆免密码" class="headerlink" title="ssh登陆免密码"></a>ssh登陆免密码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生存密钥对</span><br><span class="line">ssh-keygen</span><br><span class="line"># 将生成的公钥通过ssh-copy-id拷贝到远程服务器</span><br><span class="line">ssh-copy-id user@host</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>C++相关</title>
    <url>//pages/c75abc/</url>
    <content><![CDATA[<h2 id="c-实现AIDL"><a href="#c-实现AIDL" class="headerlink" title="c++实现AIDL"></a>c++实现AIDL</h2><p>在AOSP中发现所有实现AIDL的C++源码，方法返回值都是<code>::android::binder::Status</code><br>全局搜了一下<code>::android::binder::Status</code>,找到了<code>key_store_service.h</code>头文件,有如下注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Class provides implementation for generated BnKeystoreService.h based on</span><br><span class="line">// gen/aidl/android/security/BnKeystoreService.h generated from</span><br><span class="line">// java/android/security/IKeystoreService.aidl Note that all generated methods return binder::Status</span><br><span class="line">// and use last arguments to send actual result to the caller. Private methods don&#x27;t need to handle</span><br><span class="line">// binder::Status. Input parameters cannot be null unless annotated with @nullable in .aidl file.</span><br><span class="line">class KeyStoreService : public android::security::keystore::BnKeystoreService ...</span><br></pre></td></tr></table></figure>
<p>就是说所有AIDL方法返回值都是binder::Status，实际AIDL的返回值通过方法中的最后一个参数返回,也就是最后一个参是是个指针。</p>
<p>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::android::binder::Status getState(int32_t userId, int32_t* _aidl_return) override;</span><br></pre></td></tr></table></figure>


<h2 id="时间-标准库chrono"><a href="#时间-标准库chrono" class="headerlink" title="时间-标准库chrono"></a>时间-标准库chrono</h2><h3 id="时钟-clocks"><a href="#时钟-clocks" class="headerlink" title="时钟 clocks"></a>时钟 clocks</h3><p>要获取时间，需要用到时钟，常用2个时钟：</p>
<ol>
<li>system_clock 系统时钟，修改系统时间会发生变化</li>
<li>steady_clock 稳定时钟，和系统时间无关，不能被修改</li>
</ol>
<h3 id="时间点-time-point"><a href="#时间点-time-point" class="headerlink" title="时间点 time_point"></a>时间点 time_point</h3><p>通过时钟可以获取到时间点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取当前系统时间，system_clock一个时钟周期是1微秒</span><br><span class="line">time_point&lt;system_clock&gt; now = system_clock::now();</span><br><span class="line">//想让时间点精度从us转到ms可以通过time_point_cast进行转换（从高精度到低精度，会有精度损失）</span><br><span class="line">time_point&lt;system_clock,milliseconds&gt; nowInMs = time_point_cast&lt;milliseconds&gt;(now);</span><br><span class="line">//想让时间点精度从ms转us 可以直接隐式转换，从低精度到高精度，精度无损，直接隐式转换</span><br><span class="line">time_point&lt;system_clock,microseconds&gt; nowInUs(nowInMs);</span><br></pre></td></tr></table></figure>

<h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><p>一般步骤为通过localtime函数获取日期信息，通过strftime函数格式化日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取到当前时间点，精确到毫秒</span><br><span class="line">auto now = time_point_cast&lt;milliseconds&gt;(system_clock::now());</span><br><span class="line">//转成时间戳</span><br><span class="line">time_t t = system_clock::to_time_t(now);</span><br><span class="line">//转成时间结构体，但结构体种没有表示ms的字段</span><br><span class="line">tm *tm = localtime(&amp;t);</span><br><span class="line">int milliSecond = now.time_since_epoch().count() % 1000;</span><br><span class="line">char buffer[32];</span><br><span class="line">//格式化时间</span><br><span class="line">int len = strftime(buffer, 32, &quot;%Y-%m-%d %H:%M:%S&quot;, tm);</span><br><span class="line">sprintf(buffer + len, &quot;.%03u&quot;, milliSecond);</span><br><span class="line">//格式化后的时间字符串</span><br><span class="line">std::string s(buffer);</span><br></pre></td></tr></table></figure>

<h3 id="时间间隔-duration"><a href="#时间间隔-duration" class="headerlink" title="时间间隔 duration"></a>时间间隔 duration</h3><p>duration表示一段时间间隔，用来记录时间长度，可以表示几秒、几分钟、几个小时的时间间隔。</p>
<p>2个时间点相减：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//用steady_clock 获取开始时间点，steady_clock的一个时钟周期是1ns</span><br><span class="line">time_point&lt;steady_clock&gt; start = steady_clock::now();</span><br><span class="line">//获取结束时间点</span><br><span class="line">time_point&lt;steady_clock&gt; end = steady_clock::now();</span><br><span class="line">//开始减去结束，获取时间间隔 ns</span><br><span class="line">duration&lt;long, std::ratio&lt;1, 1000000000&gt;&gt; durationInNs = end - start;</span><br><span class="line">//duration&lt;long, std::nano&gt; durationInNano = end - start;</span><br><span class="line">//将时间间隔ns精度转成ms精度</span><br><span class="line">duration&lt;long, std::milli&gt; durationInMs = duration_cast&lt;duration&lt;long, std::milli&gt;&gt;(durationInNs);</span><br><span class="line">//通过duration的count()方法获取到时钟周期，即毫秒数</span><br><span class="line">long count = durationInMs.count();</span><br></pre></td></tr></table></figure>

<h2 id="参考-https-www-codersrc-com-c-c"><a href="#参考-https-www-codersrc-com-c-c" class="headerlink" title="参考 https://www.codersrc.com/c-c"></a>参考 <a href="https://www.codersrc.com/c-c">https://www.codersrc.com/c-c</a></h2><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *p;	//定义了一个int指针，它不是空指针，是随机值</span><br><span class="line"></span><br><span class="line">vold *pv;	//定义了一个void指针，通用指针，可以指向任意类型的数据</span><br></pre></td></tr></table></figure>

<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//声明一个函数指针，这里的pFun是一个指针</span><br><span class="line">int (*pFun) (int);</span><br><span class="line"></span><br><span class="line">int doubleVal(int val)&#123;</span><br><span class="line">    return val*2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void testPonitFunc()&#123;</span><br><span class="line">    //将指针指向函数，给指针赋值</span><br><span class="line">    pFun=doubleVal;</span><br><span class="line">    int result=pFun(3);</span><br><span class="line">    printf(&quot;test val is %d\n&quot;,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义函数指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//声明一个函数指针类型，这里的PFUN是一个函数指针类型</span><br><span class="line">typedef int (*PFUN) (int);</span><br><span class="line"></span><br><span class="line">int doubleVal(int val)&#123;</span><br><span class="line">    return val*2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void testPonitFunc()&#123;</span><br><span class="line">    //声明PFUN函数指针类型的指针,并指向对应的函数</span><br><span class="line">    PFUN pFun=doubleVal;</span><br><span class="line">    int result=pFun(3);</span><br><span class="line">    printf(&quot;test val is %d\n&quot;,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="和指针相关的常量"><a href="#和指针相关的常量" class="headerlink" title="和指针相关的常量"></a>和指针相关的常量</h2><p>指针常量 一个指针类型的常量，是常量的指针，即指针是个常量，指向的值可变；</p>
<p>常量指针 一个常量类型的指针，是指针的常量，即常量被一个指针指向了，指针可变，值不可变。</p>
<p><strong>记概念会混淆，要会读代码，知道代码是表达指针地址不可变 还是  指针指向的值不可变</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int* const p = &amp;a; 	//指针地址不可变;		p是int*，p不可变，即指针不可变</span><br><span class="line">int const *p = &amp;a;	//指针指向的值不可变;   *p是int，*p不可变，即指针指向的值不可变	</span><br><span class="line">const int *p = &amp;a; 	//指针指向的值不可变;   *p是int，*p不可变，即指针指向的值不可变	</span><br></pre></td></tr></table></figure>



<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>#运算符——字符串化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define LOCAL_ADD(a,b) printf(#a &quot;+&quot; #b &quot;= %d\n&quot;,(a)+(b));</span><br><span class="line">//测试#运算符</span><br><span class="line">void testStringizing()&#123;</span><br><span class="line">    LOCAL_ADD(2+2,3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后执行打印的字符串为：2+2+3&#x3D; 7</p>
<p>##运算符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define XVAL(n) n##n</span><br><span class="line">//测试##运算符</span><br><span class="line">void testTokenCombine()&#123;</span><br><span class="line">    printf(&quot;%d&quot;,XVAL(2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行打印的值为：22</p>
]]></content>
  </entry>
  <entry>
    <title>C++使用AIDL</title>
    <url>//pages/01804f/</url>
    <content><![CDATA[<h2 id="C-binder需要用到的库及头文件"><a href="#C-binder需要用到的库及头文件" class="headerlink" title="C++ binder需要用到的库及头文件"></a>C++ binder需要用到的库及头文件</h2><p>库及对应的头文件路径<br>cutils: system&#x2F;core&#x2F;libcutils&#x2F;include&#x2F;cutils<br>utils: system&#x2F;core&#x2F;libutils&#x2F;include&#x2F;utils<br>binder: frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;include&#x2F;binder</p>
<h2 id="C-获取binder"><a href="#C-获取binder" class="headerlink" title="C++ 获取binder"></a>C++ 获取binder</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取serviceManager</span><br><span class="line">sp&lt;IServiceManager&gt; sm(android::defaultServiceManager());</span><br><span class="line">while (true) &#123;</span><br><span class="line">    //通过sm获取mModuleUpdateService的binder对象</span><br><span class="line">    sp&lt;IBinder&gt; binder = sm-&gt;getService(String16(ModuleUpdateService::getServiceName()));</span><br><span class="line">    if (binder != nullptr) &#123;</span><br><span class="line">        //将binder转成对应的服务</span><br><span class="line">        mModuleUpdateService = interface_cast&lt;IModuleUpdate&gt;(binder);</span><br><span class="line">        //实例化回调接口</span><br><span class="line">        mUpdateCallback = new HUUpdateCallback();</span><br><span class="line">        //注册回调</span><br><span class="line">        std::cout &lt;&lt; &quot;[thread_&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;] &quot; &lt;&lt; &quot;注册回调&quot; &lt;&lt; std::endl;</span><br><span class="line">        mModuleUpdateService-&gt;registerUpdateCallback(ADAPTER_MODULE_HU, mUpdateCallback);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    usleep(500000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Android Binder 中，BN（Binder Native）是服务端实现的基类，BP（Binder Proxy）是客户端代理的基类。<br>服务端：Bn<br>客户端：Bp</p>
<h2 id="启动线程池等待响应"><a href="#启动线程池等待响应" class="headerlink" title="启动线程池等待响应"></a>启动线程池等待响应</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">//启动Binder线程池</span><br><span class="line">ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">//将当前线程加入到Binder线程池，处理binder任务，这样就会阻塞当前线程，一直等binder调用</span><br><span class="line">IPCThreadState::self()-&gt;joinThreadPool();</span><br></pre></td></tr></table></figure>

<h2 id="记录一次C-binder收不到回调的问题"><a href="#记录一次C-binder收不到回调的问题" class="headerlink" title="记录一次C++ binder收不到回调的问题"></a>记录一次C++ binder收不到回调的问题</h2><p>调用aidl的接口注册了回调，但收不到回调，一直卡着，server端也卡着</p>
<p>后面发现，需要启动binder线程池，否则无法进行binder通信。</p>
]]></content>
  </entry>
  <entry>
    <title>Dialog调用hide后没有隐藏</title>
    <url>/2023/10/11/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/1.Dialog%E8%B0%83%E7%94%A8hide%E6%B2%A1%E6%9C%89%E9%9A%90%E8%97%8F/</url>
    <content><![CDATA[<h1 id="记录一次Dialog调用hide后依然显示的问题"><a href="#记录一次Dialog调用hide后依然显示的问题" class="headerlink" title="记录一次Dialog调用hide后依然显示的问题"></a>记录一次Dialog调用hide后依然显示的问题</h1><p>app切换过程中，在调用dialog的hide方法后，偶现dialog没有消失，再次调用正常。</p>
<p>后面打开WMS的log排查发现有如下log：</p>
<p>Dialog正常显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10-11 16:56:09.470 19943 13723 V WindowManager： Relayout Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity&#125;: viewVisibility=0 req=1152x80 &#123;(0,0)(wrapxwrap) gr=CENTER sim=&#123;adjust=pan forwardNavigation&#125; ty=APPLICATION fmt=TRANSLUCENT wanim=0x1030002 surfaceInsets=Rect(32, 32 - 32, 32)</span><br><span class="line">10-11 16:56:09.472 19943 13723 V WindowManager: performSurfacePlacementInner: entry. Called by </span><br><span class="line">10-11 16:56:09.519 19943 13723 E WindowManager: performSurfacePlacementInner exit</span><br><span class="line">10-11 16:56:09.520 19943 13723 I WindowManager: selectAnimation in Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity&#125;: transit=1</span><br><span class="line"></span><br><span class="line">10-11 16:56:09.520 19943 13723 V WindowManager: Loading animations: layout params pkg=com.example.localtest resId=0x1030002</span><br><span class="line">10-11 16:56:09.520 19943 13723 V WindowManager: Loading animations: picked package=android</span><br><span class="line">10-11 16:56:09.522 19943 13723 V Starting animation on Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity&#125;: type=16, anim=com.android.server.wm.LocalAnimationAdapter@6e178c1</span><br><span class="line"></span><br><span class="line">10-11 16:56:09.522 19943 13723 V WindowManager: applyAnimation: win=WindowStateAnimator&#123;998a7d0 com.example.localtest/com.example.localtest.MainActivity&#125; anim=0 attr=0x0 a=android.view.animation.AnimationSet@a0549cb transit=1 type=2 isEntrance=true Callers com.android.server.wm.WindowStateAnimator.applyEnterAnimationLocked:1397 com.android.server.wm.WindowState.prepareWindowToDisplayDuringRelayout:2833 com.android.server.wm.WindowState.relayoutVisibleWindow:5165 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10-11 16:56:09.532 19943 13723 D WindowManager: focusChangedLw getDisplayId:0 mFocusedWindow:Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity&#125; mLastFocusedWindow:Window&#123;222ba39 u10 com.example.localtest/com.example.localtest.MainActivity&#125;</span><br><span class="line"></span><br><span class="line">10-11 16:56:09.545 19943 13723 V WindowManager: Win Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity&#125;: isDrawn=true, animating=true</span><br><span class="line">10-11 16:56:09.546 19943 13723 V WindowManager: Relayout complete Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity&#125;: outFrame=[1078,719][2230,799]</span><br><span class="line"></span><br><span class="line">10-11 16:56:09.782 19943 20104 V WindowManager: Animation done in WindowStateAnimator&#123;998a7d0 com.example.localtest/com.example.localtest.MainActivity&#125;: exiting=false, reportedVisible=true</span><br><span class="line">10-11 16:56:09.782 19943 20104 V WindowManager: onExitAnimationDone in Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity&#125;: exiting=false remove=false selfAnimating=false</span><br><span class="line">10-11 16:56:09.783 19943 20104 V WindowManager: Win Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity&#125;: isDrawn=true, animating=false</span><br></pre></td></tr></table></figure>

<p>Dialog正常隐藏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10-11 16:56:12.423 19943 20396 V WindowManager: Relayout Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity&#125;: viewVisibility=8 req=1152x80 &#123;(0,0)(wrapxwrap) gr=CENTER sim=&#123;adjust=pan forwardNavigation&#125; ty=APPLICATION fmt=TRANSLUCENT wanim=0x1030002 surfaceInsets=Rect(32, 32 - 32, 32)</span><br><span class="line">10-11 16:56:12.426 19943 20396 I WindowManager: Relayout invis Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity&#125;: mAnimatingExit=false</span><br><span class="line">10-11 16:56:12.427 19943 20396 I WindowManager: selectAnimation in Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity&#125;: transit=2</span><br><span class="line">10-11 16:56:12.427 19943 20396 V WindowManager: Loading animations: layout params pkg=com.example.localtest resId=0x1030002</span><br><span class="line">10-11 16:56:12.427 19943 20396 V WindowManager: Loading animations: picked package=android</span><br><span class="line">10-11 16:56:12.429 19943 20396 V WindowManager: applyAnimation: win=WindowStateAnimator&#123;998a7d0 com.example.localtest/com.example.localtest.MainActivity&#125; anim=0 attr=0x1 a=android.view.animation.AnimationSet@77c6733 transit=2 type=2 isEntrance=false Callers com.android.server.wm.WindowManagerService.tryStartExitingAnimation:2529 com.android.server.wm.WindowManagerService.relayoutWindow:2319 com.android.server.wm.Session.relayout:212</span><br><span class="line"></span><br><span class="line">10-11 16:56:12.431 19943 20396 V WindowManager: Starting animation on Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity&#125;: type=16, anim=com.android.server.wm.LocalAnimationAdapter@3d1869</span><br><span class="line"></span><br><span class="line">10-11 16:56:12.434 19943 20396 V WindowManager: performSurfacePlacementInner: entry. Called by </span><br><span class="line">10-11 16:56:12.481 19943 20396 E WindowManager: performSurfacePlacementInner exit</span><br><span class="line">10-11 16:56:12.481 19943 20396 I WindowManager: Releasing surface in: Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity EXITING&#125;</span><br><span class="line">10-11 16:56:12.486 19943 20396 V WindowManager: Relayout complete Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity EXITING&#125;: outFrame=[1078,719][2230,799]</span><br><span class="line">10-11 16:56:12.679 19943 20104 V WindowManager: Animation done in WindowStateAnimator&#123;998a7d0 com.example.localtest/com.example.localtest.MainActivity&#125;: exiting=true, reportedVisible=true</span><br><span class="line">10-11 16:56:12.679 19943 20104 V WindowManager: onExitAnimationDone in Window&#123;51ef41b u10 com.example.localtest/com.example.localtest.MainActivity EXITING&#125;: exiting=true remove=false selfAnimating=false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Starting animation on Window 开始执行动画</p>
<p>onExitAnimationDone  in Window 退出执行动画的操作（动画执行已完成）</p>
<p>WindowManagerService.relayoutWindow<br>    WindowState.relayoutVisibleWindow<br>        WindowState.prepareWindowToDisplayDuringRelayout<br>            WindowStateAnimator.applyEnterAnimationLocked<br>                WindowStateAnimator.applyAnimationLocked<br>                    WindowState.startAnimation (WindowContainer.startAnimation)<br>                        SurfaceAnimator.startAnimation<br>                            AnimationAdapter.startAnimation (LocalAnimationAdapter.startAnimation)</p>
<p>切换app进入动画开始时先去relayoutwindow，然后会调用WindowState中的WindowStateAnimator的applyEnterAnimationLocked</p>
<p>在WindowState的构造方法中，会去调用父类WindowContainer的构造方法，在父类构造方法中<br>初始化SurfaceAnimator对象，传入回调方法onAnimationFinished,当动画执行完成时，会回调WindowState的<br>onAnimationFinished，方法内部调用的WindowStateAnimator.onAnimationFinished</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WindowContainer(WindowManagerService wms) &#123;</span><br><span class="line">    mWmService = wms;</span><br><span class="line">    mPendingTransaction = wms.mTransactionFactory.get();</span><br><span class="line">    mBLASTSyncTransaction = wms.mTransactionFactory.get();</span><br><span class="line">    mSurfaceAnimator = new SurfaceAnimator(this, this::onAnimationFinished, wms);</span><br><span class="line">    mSurfaceFreezer = new SurfaceFreezer(this, wms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void onAnimationFinished(@AnimationType int type, AnimationAdapter anim) &#123;</span><br><span class="line">    doAnimationFinished(type, anim);</span><br><span class="line">    mWmService.onAnimationFinished();</span><br><span class="line">    mNeedsZBoost = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAnimationFinished(@AnimationType int type, AnimationAdapter anim) &#123;</span><br><span class="line">    for (int i = 0; i &lt; mSurfaceAnimationSources.size(); ++i) &#123;</span><br><span class="line">        mSurfaceAnimationSources.valueAt(i).onAnimationFinished(type, anim);</span><br><span class="line">    &#125;</span><br><span class="line">    mSurfaceAnimationSources.clear();</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>LocalAnimationAdapter中有一个WindowAnimationSpec对象，最后执行动画时，调用的就是WindowAnimationSpec.apply</p>
<p>在app切换过程中window relayout<br>然后在AppTransitionController中会调用wms的mSurfaceAnimationRunner.deferStartingAnimations()标记延迟启动动画</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mService.mSurfaceAnimationRunner.deferStartingAnimations()</span><br></pre></td></tr></table></figure>

<p>调用一次SurfaceAnimationRunner.startAnimation</p>
<p>然后在AppTransitionController中会调用wms的mSurfaceAnimationRunner.continueStartingAnimations()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mService.mSurfaceAnimationRunner.continueStartingAnimations();</span><br></pre></td></tr></table></figure>
<p>continueStartingAnimations会调用startPendingAnimationsLocked，最后调用startAnimationLocked</p>
]]></content>
  </entry>
  <entry>
    <title>finish返回的不是前一个app</title>
    <url>/2024/07/04/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/11.app%E8%BF%94%E5%9B%9E%E4%B8%8D%E6%98%AF%E4%B8%8A%E4%B8%80%E4%B8%AAapp/</url>
    <content><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>从APP A 跳转到 APP B，关闭APP B之后，回到的不是APP A，而是APP A之前的一个app</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>log中查看wm相关的event tag ，没有发现APP A finish，但看有ActivityStack相关的log:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityStack: moveTaskToBack: Task&#123;70b2c30 #1000059 visible=false type=standard mode=fullscreen translucent=true A=XXXX U=10 StackId=1000059 sz=1&#125;</span><br></pre></td></tr></table></figure>
<p>后续查看APP A相关逻辑，APP A 重写了逻辑，在finish中调用了moveTaskToBack， APP A 的任务栈移到了最底部</p>
]]></content>
  </entry>
  <entry>
    <title>资源相关报错</title>
    <url>/2024/07/17/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/12.%E8%B5%84%E6%BA%90%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h2 id="AOSP中新增resource引用报错：cannot-find-symbol"><a href="#AOSP中新增resource引用报错：cannot-find-symbol" class="headerlink" title="AOSP中新增resource引用报错：cannot find symbol"></a>AOSP中新增resource引用报错：cannot find symbol</h2><p><code>frameworks/base/core/res/res/values/symbols.xml</code>中还需要声明类型和名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Private symbols that we need to reference from framework code.  See</span><br><span class="line">     frameworks/base/core/res/MakeJavaSymbols.sed for how to easily generate</span><br><span class="line">     this.</span><br><span class="line"></span><br><span class="line">     Can be referenced in java code as: com.android.internal.R.&lt;type&gt;.&lt;name&gt;</span><br><span class="line">     and in layout xml as: &quot;@*android:&lt;type&gt;/&lt;name&gt;&quot;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;java-symbol type=&quot;id&quot; name=&quot;account_name&quot; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>关于priority设置无效的问题</title>
    <url>/2024/08/08/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/13.%E5%85%B3%E4%BA%8Epriority%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>在AndroidManifest.xml的Activity标签中配置了intent-filter的priority用来提高相同intent响应的优先级，<br>但实际没有效果</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>断点调试发现，查询出来的ResolveInfo中的priority一直是0，似乎配置没有生效，查询<a href="https://developer.android.google.cn/guide/topics/manifest/intent-filter-element?hl=zh-cn">官网</a>后发现原生逻辑会忽略情况下的设置：</p>
<blockquote>
<p>在某些情况下，系统会忽略请求的优先级，并将值限定为 0。此类情况发生在：<br>  非特权应用请求任何大于 0 的优先级时。<br>  特权应用为 ACTION_VIEW、ACTION_SEND、ACTION_SENDTO 或 ACTION_SEND_MULTIPLE 请求大于 0 的优先级时。</p>
</blockquote>
<p><strong>所以只有特权app才能配置priority</strong></p>
]]></content>
  </entry>
  <entry>
    <title>Ubuntu微信图片无法打卡</title>
    <url>/2023/10/27/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/2.Ubuntu%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/</url>
    <content><![CDATA[<p>在Ubuntu中安装的微信，图片无法打开<br>打开别人发送的图片是空白的，无法显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libjpeg62-dev:i386</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>U0用户下进程在U10界面弹窗</title>
    <url>/2024/05/10/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/3.U0%E7%94%A8%E6%88%B7%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%9C%A8U10%E7%95%8C%E9%9D%A2%E5%BC%B9%E7%AA%97/</url>
    <content><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>多用户的情况下，前台用户非U0，运行在U0用户下的进程弹窗会无法显示。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>通过<code>WindowManagerGlobal</code>的addView指定userid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WindowManagerGlobal.getInstance().addView(mView, mLayoutParams, mContext.getDisplayNoVerify(),</span><br><span class="line">                    null, ActivityManager.getCurrentUser());</span><br></pre></td></tr></table></figure>

<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>window的privateFlags添加 <code>SYSTEM_FLAG_SHOW_FOR_ALL_USERS</code></p>
]]></content>
  </entry>
  <entry>
    <title>4.UnsatisfiedLinkError记录.md</title>
    <url>/2024/05/24/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/4.UnsatisfiedLinkError%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录一下遇到的<code>UnsatisfiedLinkError</code>相关的错误</p>
<h2 id="dlopen-failed-library-“libxxx-so”-not-found"><a href="#dlopen-failed-library-“libxxx-so”-not-found" class="headerlink" title="dlopen failed: library “libxxx.so” not found"></a>dlopen failed: library “libxxx.so” not found</h2><p>找不到对应的so，需要确认对应的so是否存在。堆栈大概如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: dlopen failed: library &quot;libxxx.so&quot; not found</span><br><span class="line">    at java.lang.Runtime.loadLibrary0(Runtime.java:1087)</span><br><span class="line">    at java.lang.Runtime.loadLibrary0(Runtime.java:1008)</span><br><span class="line">    at java.lang.System.loadLibrary(System.java:1664)</span><br></pre></td></tr></table></figure>

<h2 id="dlopen-failed-library-“xxx”-needed-or-dlopened-by-“-apex-com-android-art-lib64-libnativeloader-so”-is-not-accessible-for-the-namespace-“classloader-namespace”"><a href="#dlopen-failed-library-“xxx”-needed-or-dlopened-by-“-apex-com-android-art-lib64-libnativeloader-so”-is-not-accessible-for-the-namespace-“classloader-namespace”" class="headerlink" title="dlopen failed: library “xxx” needed or dlopened by “&#x2F;apex&#x2F;com.android.art&#x2F;lib64&#x2F;libnativeloader.so” is not accessible for the namespace “classloader-namespace”"></a>dlopen failed: library “xxx” needed or dlopened by “&#x2F;apex&#x2F;com.android.art&#x2F;lib64&#x2F;libnativeloader.so” is not accessible for the namespace “classloader-namespace”</h2><p>权限问题，一般会有相关log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library &quot;/system/lib64/libxxx.so&quot; (&quot;/system/lib64/libxxx.so&quot;) needed or dlopened by &quot;/apex/com.android.art/lib64/libnativeloader.so&quot; is not accessible for the namespace: [name=&quot;classloader-namespace&quot;, ld_library_paths=&quot;&quot;, default_library_paths=&quot;/data/app/~~1nkZb2vc3_ysMBS8xSr6qA==/com.xxx.xxx-uHnqWjBxSlZ0S7JyLbdNag==/base.apk!/lib/arm64-v8a&quot;, permitted_paths=&quot;/data:/mnt/expand:/data/user/10/com.xxx.xxx&quot;]</span><br></pre></td></tr></table></figure>
<p>permitted_paths是app可以查找链接so的目录，log中看出是data app想链接system&#x2F;lib64下的so没有权限。<br>解决办法,将so打包到apk中，或者更改app所在的分区(和对应的so在同一分区下)</p>
<h2 id="java-lang-UnsatisfiedLinkError-No-implementation-found-for-void-com-cocos-lib-JsbBridge-nativeSendToScript-java-lang-String-java-lang-String-tried-Java-com-cocos-lib-JsbBridge-nativeSendToScript-and-Java-com-cocos-lib-JsbBridge-nativeSendToScript-Ljava-lang-String-2Ljava-lang-String-2"><a href="#java-lang-UnsatisfiedLinkError-No-implementation-found-for-void-com-cocos-lib-JsbBridge-nativeSendToScript-java-lang-String-java-lang-String-tried-Java-com-cocos-lib-JsbBridge-nativeSendToScript-and-Java-com-cocos-lib-JsbBridge-nativeSendToScript-Ljava-lang-String-2Ljava-lang-String-2" class="headerlink" title="java.lang.UnsatisfiedLinkError: No implementation found for void com.cocos.lib.JsbBridge.nativeSendToScript(java.lang.String, java.lang.String) (tried Java_com_cocos_lib_JsbBridge_nativeSendToScript and Java_com_cocos_lib_JsbBridge_nativeSendToScript__Ljava_lang_String_2Ljava_lang_String_2)"></a>java.lang.UnsatisfiedLinkError: No implementation found for void com.cocos.lib.JsbBridge.nativeSendToScript(java.lang.String, java.lang.String) (tried Java_com_cocos_lib_JsbBridge_nativeSendToScript and Java_com_cocos_lib_JsbBridge_nativeSendToScript__Ljava_lang_String_2Ljava_lang_String_2)</h2><p>没找到对应的实现，确认是否加载so，或者so中的方法签名和JNI中声明的签名不一致</p>
]]></content>
  </entry>
  <entry>
    <title>Android广播问题记录</title>
    <url>/2024/06/13/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/5.Android%E5%B9%BF%E6%92%AD%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="BroadcastQueue-Background-execution-not-allowed-receiving-XXX-to-XXX"><a href="#BroadcastQueue-Background-execution-not-allowed-receiving-XXX-to-XXX" class="headerlink" title="BroadcastQueue: Background execution not allowed: receiving XXX to XXX"></a>BroadcastQueue: Background execution not allowed: receiving XXX to XXX</h2><p>权限问题，广播无法发送给未启动的app，这是android8.0之后对隐式广播的限制。<br>在发送广播时，会去判断intent是否有<code>FLAG_RECEIVER_EXCLUDE_BACKGROUND</code>这个flag，只要有就不会发送给未启动的app；<br>如果没有这个flag，会去判断intent的component和package等信息，逻辑是，如果intent既没有指定component，也没有指定package，<br>也没有指定<code>FLAG_RECEIVER_INCLUDE_BACKGROUND</code>,也没有isSignaturePerm（所有给定的权限都是签名的权限），还是不会发送给未启动的app；</p>
<p>查看BroadcastQueue.java的源码，在<code>processNextBroadcastLocked</code>中有如下逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!skip) &#123;</span><br><span class="line">    final int allowed = mService.getAppStartModeLocked(</span><br><span class="line">            info.activityInfo.applicationInfo.uid, info.activityInfo.packageName,</span><br><span class="line">            info.activityInfo.applicationInfo.targetSdkVersion, -1, true, false, false);</span><br><span class="line">    if (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span><br><span class="line">        // We won&#x27;t allow this receiver to be launched if the app has been</span><br><span class="line">        // completely disabled from launches, or it was not explicitly sent</span><br><span class="line">        // to it and the app is in a state that should not receive it</span><br><span class="line">        // (depending on how getAppStartModeLocked has determined that).</span><br><span class="line">        if (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Background execution disabled: receiving &quot;</span><br><span class="line">                    + r.intent + &quot; to &quot;</span><br><span class="line">                    + component.flattenToShortString());</span><br><span class="line">            skip = true;</span><br><span class="line">        //这里会去判断intent是否有FLAG_RECEIVER_EXCLUDE_BACKGROUND，判断component等信息</span><br><span class="line">        &#125; else if (((r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0)</span><br><span class="line">                || (r.intent.getComponent() == null</span><br><span class="line">                    &amp;&amp; r.intent.getPackage() == null</span><br><span class="line">                    &amp;&amp; ((r.intent.getFlags()</span><br><span class="line">                            &amp; Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0)</span><br><span class="line">                    &amp;&amp; !isSignaturePerm(r.requiredPermissions))) &#123;</span><br><span class="line">            mService.addBackgroundCheckViolationLocked(r.intent.getAction(),</span><br><span class="line">                    component.getPackageName());</span><br><span class="line">            Slog.w(TAG, &quot;Background execution not allowed: receiving &quot;</span><br><span class="line">                    + r.intent + &quot; to &quot;</span><br><span class="line">                    + component.flattenToShortString());</span><br><span class="line">            skip = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>在实际开发中出现过intent指定了component但依旧没有发送给后台app的问题</em><br>查看源码逻辑，发现是因为，开发时，向多个用户发送了广播，但在某个用户下，并没有安装对应的app，<br>发送显式广播时，没有对端接收，广播被异常中断，在AOSP中清除了广播的一些信息，<br>这种情况可以通过对广播的intent加<code>FLAG_RECEIVER_INCLUDE_BACKGROUND</code>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void processNextBroadcastLocked(boolean fromMsg, boolean skipOomAdj) &#123;</span><br><span class="line">    //......</span><br><span class="line">    if ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">            info.activityInfo.applicationInfo, true,</span><br><span class="line">            r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">            new HostingRecord(&quot;broadcast&quot;, r.curComponent),</span><br><span class="line">            isActivityCapable ? ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE : ZYGOTE_POLICY_FLAG_EMPTY,</span><br><span class="line">            (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false))</span><br><span class="line">                    == null) &#123;</span><br><span class="line">        // Ah, this recipient is unavailable.  Finish it if necessary,</span><br><span class="line">        // and mark the broadcast record as ready for the next.</span><br><span class="line">        Slog.w(TAG, &quot;Unable to launch app &quot;</span><br><span class="line">                + info.activityInfo.applicationInfo.packageName + &quot;/&quot;</span><br><span class="line">                + receiverUid + &quot; for broadcast &quot;</span><br><span class="line">                + r.intent + &quot;: process is bad&quot;);</span><br><span class="line">        //异常中断，广播会丢弃，打印tag am_broadcast_discard_app</span><br><span class="line">        logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">        //清除接收端信息</span><br><span class="line">        finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                r.resultExtras, r.resultAbort, false);</span><br><span class="line">        scheduleBroadcastsLocked();</span><br><span class="line">        r.state = BroadcastRecord.IDLE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maybeAddAllowBackgroundActivityStartsToken(r.curApp, r);</span><br><span class="line">    mPendingBroadcast = r;</span><br><span class="line">    mPendingBroadcastRecvIndex = recIdx;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean finishReceiverLocked(BroadcastRecord r, int resultCode,</span><br><span class="line">        String resultData, Bundle resultExtras, boolean resultAbort, boolean waitForServices) &#123;</span><br><span class="line">    //......                </span><br><span class="line">    r.receiver = null;</span><br><span class="line">    r.intent.setComponent(null);</span><br><span class="line">    if (r.curApp != null &amp;&amp; r.curApp.curReceivers.contains(r)) &#123;</span><br><span class="line">        r.curApp.curReceivers.remove(r);</span><br><span class="line">    &#125;</span><br><span class="line">    if (r.curFilter != null) &#123;</span><br><span class="line">        r.curFilter.receiverList.curBroadcast = null;</span><br><span class="line">    &#125;</span><br><span class="line">    r.curFilter = null;</span><br><span class="line">    r.curReceiver = null;</span><br><span class="line">    r.curApp = null;</span><br><span class="line">    mPendingBroadcast = null;        </span><br><span class="line">    //......</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>窗口层级问题记录</title>
    <url>/2024/06/14/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/6.window%E5%B1%82%E7%BA%A7%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>反馈app的悬浮窗type为TYPE_APPLICATION_OVERLAY，对应int值为12，<br>而输入法对应TYPE_INPUT_METHOD，int值为15，<br>按注释来看，悬浮窗应该再输入法下方，但实际是悬浮窗在输入法上面，输入法被遮挡了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Returns the layer assignment for the window type. Allows you to control how different</span><br><span class="line">  * kinds of windows are ordered on-screen.</span><br><span class="line">  *</span><br><span class="line">  * @param type The type of window being assigned.</span><br><span class="line">  * @param canAddInternalSystemWindow If the owner window associated with the type we are</span><br><span class="line">  *        evaluating can add internal system windows. I.e they have</span><br><span class="line">  *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window</span><br><span class="line">  *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;</span><br><span class="line">  *        can be assigned layers greater than the layer for</span><br><span class="line">  *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their</span><br><span class="line">  *        layers would be lesser.</span><br><span class="line">  * @return int An arbitrary integer used to order windows, with lower numbers below higher ones.</span><br><span class="line">  */</span><br><span class="line"> default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) &#123;</span><br><span class="line">     if (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">         return APPLICATION_LAYER;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     switch (type) &#123;</span><br><span class="line">         case TYPE_WALLPAPER:</span><br><span class="line">             // wallpaper is at the bottom, though the window manager may move it.</span><br><span class="line">             return  1;</span><br><span class="line">         case TYPE_PRESENTATION:</span><br><span class="line">         case TYPE_PRIVATE_PRESENTATION:</span><br><span class="line">             return  APPLICATION_LAYER;</span><br><span class="line">         case TYPE_DOCK_DIVIDER:</span><br><span class="line">             return  APPLICATION_LAYER;</span><br><span class="line">         case TYPE_QS_DIALOG:</span><br><span class="line">             return  APPLICATION_LAYER;</span><br><span class="line">         case TYPE_PHONE:</span><br><span class="line">             return  3;</span><br><span class="line">         case TYPE_SEARCH_BAR:</span><br><span class="line">         case TYPE_VOICE_INTERACTION_STARTING:</span><br><span class="line">             return  4;</span><br><span class="line">         case TYPE_VOICE_INTERACTION:</span><br><span class="line">             // voice interaction layer is almost immediately above apps.</span><br><span class="line">             return  5;</span><br><span class="line">         case TYPE_INPUT_CONSUMER:</span><br><span class="line">             return  6;</span><br><span class="line">         case TYPE_SYSTEM_DIALOG:</span><br><span class="line">             return  7;</span><br><span class="line">         case TYPE_TOAST:</span><br><span class="line">             // toasts and the plugged-in battery thing</span><br><span class="line">             return  8;</span><br><span class="line">         case TYPE_PRIORITY_PHONE:</span><br><span class="line">             // SIM errors and unlock.  Not sure if this really should be in a high layer.</span><br><span class="line">             return  9;</span><br><span class="line">         case TYPE_SYSTEM_ALERT:</span><br><span class="line">             // like the ANR / app crashed dialogs</span><br><span class="line">             // Type is deprecated for non-system apps. For system apps, this type should be</span><br><span class="line">             // in a higher layer than TYPE_APPLICATION_OVERLAY.</span><br><span class="line">             return  canAddInternalSystemWindow ? 13 : 10;</span><br><span class="line">         case TYPE_APPLICATION_OVERLAY:</span><br><span class="line">         case TYPE_TRUSTED_APPLICATION_OVERLAY:</span><br><span class="line">             return  12;</span><br><span class="line">         case TYPE_INPUT_METHOD:</span><br><span class="line">             // on-screen keyboards and other such input method user interfaces go here.</span><br><span class="line">             return  15;</span><br><span class="line">         case TYPE_INPUT_METHOD_DIALOG:</span><br><span class="line">             // on-screen keyboards and other such input method user interfaces go here.</span><br><span class="line">             return  16;</span><br><span class="line">         case TYPE_STATUS_BAR:</span><br><span class="line">             return  17;</span><br><span class="line">         case TYPE_STATUS_BAR_ADDITIONAL:</span><br><span class="line">             return  18;</span><br><span class="line">         case TYPE_NOTIFICATION_SHADE:</span><br><span class="line">             return  19;</span><br><span class="line">         case TYPE_STATUS_BAR_SUB_PANEL:</span><br><span class="line">             return  20;</span><br><span class="line">         case TYPE_KEYGUARD_DIALOG:</span><br><span class="line">             return  21;</span><br><span class="line">         case TYPE_VOLUME_OVERLAY:</span><br><span class="line">             // the on-screen volume indicator and controller shown when the user</span><br><span class="line">             // changes the device volume</span><br><span class="line">             return  22;</span><br><span class="line">         case TYPE_SYSTEM_OVERLAY:</span><br><span class="line">             // the on-screen volume indicator and controller shown when the user</span><br><span class="line">             // changes the device volume</span><br><span class="line">             return  canAddInternalSystemWindow ? 23 : 11;</span><br><span class="line">         case TYPE_NAVIGATION_BAR:</span><br><span class="line">             // the navigation bar, if available, shows atop most things</span><br><span class="line">             return  24;</span><br><span class="line">         case TYPE_NAVIGATION_BAR_PANEL:</span><br><span class="line">             // some panels (e.g. search) need to show on top of the navigation bar</span><br><span class="line">             return  25;</span><br><span class="line">         case TYPE_SCREENSHOT:</span><br><span class="line">             // screenshot selection layer shouldn&#x27;t go above system error, but it should cover</span><br><span class="line">             // navigation bars at the very least.</span><br><span class="line">             return  26;</span><br><span class="line">         case TYPE_SYSTEM_ERROR:</span><br><span class="line">             // system-level error dialogs</span><br><span class="line">             return  canAddInternalSystemWindow ? 27 : 10;</span><br><span class="line">         case TYPE_MAGNIFICATION_OVERLAY:</span><br><span class="line">             // used to highlight the magnified portion of a display</span><br><span class="line">             return  28;</span><br><span class="line">         case TYPE_DISPLAY_OVERLAY:</span><br><span class="line">             // used to simulate secondary display devices</span><br><span class="line">             return  29;</span><br><span class="line">         case TYPE_DRAG:</span><br><span class="line">             // the drag layer: input for drag-and-drop is associated with this window,</span><br><span class="line">             // which sits above all other focusable windows</span><br><span class="line">             return  30;</span><br><span class="line">         case TYPE_ACCESSIBILITY_OVERLAY:</span><br><span class="line">             // overlay put by accessibility services to intercept user interaction</span><br><span class="line">             return  31;</span><br><span class="line">         case TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY:</span><br><span class="line">             return 32;</span><br><span class="line">         case TYPE_SECURE_SYSTEM_OVERLAY:</span><br><span class="line">             return  33;</span><br><span class="line">         case TYPE_BOOT_PROGRESS:</span><br><span class="line">             return  34;</span><br><span class="line">         case TYPE_POINTER:</span><br><span class="line">             // the (mouse) pointer layer</span><br><span class="line">             return  35;</span><br><span class="line">         default:</span><br><span class="line">             Slog.e(&quot;WindowManager&quot;, &quot;Unknown window type: &quot; + type);</span><br><span class="line">             return APPLICATION_LAYER;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>输入法是依赖于焦点窗口的，输入法基于唤起输入法的窗口所在的zOrder进行调节，<br>由于唤醒输入法的窗口的zOrder小于TYPE_APPLICATION_OVERLAY所在的zOrder，导致最后算出来的输入法zOrder比实际低</p>
<p>如果想要悬浮窗的在输入法的下面，可以添加<code>FLAG_ALT_FOCUSABLE_IM</code>flag<br>参考<a href="https://developer.android.google.cn/develop/ui/views/touch-and-input/keyboard-input/visibility?hl=zh-cn#showBehindIme">官网</a></p>
]]></content>
  </entry>
  <entry>
    <title>在C++中AIDL序列化对象</title>
    <url>/2024/06/25/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/7.AIDL-C++%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>实体类在java中实现了Parcelable，并在AIDL文件中进行了声明,<br>在c++进程引用了这个AIDL作为源文件进行编译，但实际编译会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bad internal state: cpp_header.empty(): Parcelable com.xxx.xxx.xxxBean has no C++ header defined.</span><br></pre></td></tr></table></figure>

<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>查看<a href="https://source.android.google.cn/docs/core/architecture/aidl/aidl-backends?hl=zh-cn#custom-parcelables">官方文档</a>后发现,<br>c++端的序列化需要指定头文件</p>
<blockquote>
<p>如需用 AIDL 声明自定义 CPP 后端 Parcelable，请使用 cpp_header<br>类似：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package my.pack.age;</span><br><span class="line">parcelable Foo cpp_header &quot;my/pack/age/Foo.h&quot;;</span><br></pre></td></tr></table></figure>
<p>并实现<code>writeToParcel</code>和<code>readFromParcel</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;binder/Parcelable.h&gt;</span><br><span class="line"></span><br><span class="line">class MyCustomParcelable : public android::Parcelable &#123;</span><br><span class="line">public:</span><br><span class="line">    status_t writeToParcel(Parcel* parcel) const override;</span><br><span class="line">    status_t readFromParcel(const Parcel* parcel) override;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>隐式intent设置默认Activity</title>
    <url>/2024/06/26/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/8.Android%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4Activity/</url>
    <content><![CDATA[<h2 id="addPreferredActivity"><a href="#addPreferredActivity" class="headerlink" title="addPreferredActivity"></a>addPreferredActivity</h2><p>PMS中有接口<code>addPreferredActivity</code>设置默认的Activity:<br>在PackageManager中也有对应的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Add a new preferred activity mapping to the system.  This will be used</span><br><span class="line"> * to automatically select the given activity component when</span><br><span class="line"> * &#123;@link Context#startActivity(Intent) Context.startActivity()&#125; finds</span><br><span class="line"> * multiple matching activities and also matches the given filter.</span><br><span class="line"> *</span><br><span class="line"> * @param filter The set of intents under which this activity will be</span><br><span class="line"> * made preferred.</span><br><span class="line"> * @param match The IntentFilter match category that this preference</span><br><span class="line"> * applies to.</span><br><span class="line"> * @param set The set of activities that the user was picking from when</span><br><span class="line"> * this preference was made.</span><br><span class="line"> * @param activity The component name of the activity that is to be</span><br><span class="line"> * preferred.</span><br><span class="line"> *</span><br><span class="line"> * @deprecated This function no longer does anything. It is the platform&#x27;s</span><br><span class="line"> * responsibility to assign preferred activities and this cannot be modified</span><br><span class="line"> * directly. To determine the activities resolved by the platform, use</span><br><span class="line"> * &#123;@link #resolveActivity&#125; or &#123;@link #queryIntentActivities&#125;. To configure</span><br><span class="line"> * an app to be responsible for a particular role and to check current role</span><br><span class="line"> * holders, see &#123;@link android.app.role.RoleManager&#125;.</span><br><span class="line"> */</span><br><span class="line">@Deprecated</span><br><span class="line">public abstract void addPreferredActivity(@NonNull IntentFilter filter, int match,</span><br><span class="line">        @Nullable ComponentName[] set, @NonNull ComponentName activity);</span><br></pre></td></tr></table></figure>
<p>PMS中的实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addPreferredActivityInternal(IntentFilter filter, int match,</span><br><span class="line">        ComponentName[] set, ComponentName activity, boolean always, int userId,</span><br><span class="line">        String opname) &#123;</span><br><span class="line">    // writer</span><br><span class="line">    int callingUid = Binder.getCallingUid();</span><br><span class="line">    mPermissionManager.enforceCrossUserPermission(callingUid, userId,</span><br><span class="line">            true /* requireFullPermission */, false /* checkShell */, &quot;add preferred activity&quot;);</span><br><span class="line">    if (mContext.checkCallingOrSelfPermission(</span><br><span class="line">            android.Manifest.permission.SET_PREFERRED_APPLICATIONS)</span><br><span class="line">            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            if (getUidTargetSdkVersionLockedLPr(callingUid)</span><br><span class="line">                    &lt; Build.VERSION_CODES.FROYO) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Ignoring addPreferredActivity() from uid &quot;</span><br><span class="line">                        + callingUid);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mContext.enforceCallingOrSelfPermission(</span><br><span class="line">                android.Manifest.permission.SET_PREFERRED_APPLICATIONS, null);</span><br><span class="line">    &#125;</span><br><span class="line">    if (filter.countActions() == 0) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Cannot set a preferred activity with no filter actions&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG_PREFERRED) &#123;</span><br><span class="line">        Slog.i(TAG, opname + &quot; activity &quot; + activity.flattenToShortString() + &quot; for user &quot;</span><br><span class="line">                + userId + &quot;:&quot;);</span><br><span class="line">        filter.dump(new LogPrinter(Log.INFO, TAG), &quot;  &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        //主要逻辑在这里，先保存到内存中</span><br><span class="line">        final PreferredIntentResolver pir = mSettings.editPreferredActivitiesLPw(userId);</span><br><span class="line">        pir.addFilter(new PreferredActivity(filter, match, set, activity, always));</span><br><span class="line">        //再持久化写到xml中，继续追源码发现是写在了/data/system/users/$&#123;user&#125;/package-restrictions.xml中</span><br><span class="line">        scheduleWritePackageRestrictionsLocked(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!updateDefaultHomeNotLocked(userId)) &#123;</span><br><span class="line">        postPreferredActivityChangedBroadcast(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以对其进行封装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean setDefaultHome(Context context, String pkg, String className) &#123;</span><br><span class="line">    Intent homeIntent = new Intent(Intent.ACTION_MAIN);</span><br><span class="line">    homeIntent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">    homeIntent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">    return setDefaultIntentActivity(context, homeIntent, pkg, className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean setDefaultIntentActivity(Context context, Intent intent, String pkg, String className) &#123;</span><br><span class="line">    if (intent == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (intent.getComponent() != null) &#123;</span><br><span class="line">        //显式intent无法设置</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    PackageManager pm = context.getPackageManager();</span><br><span class="line">    try &#123;</span><br><span class="line">        PackageInfo packageInfo = pm.getPackageInfo(pkg, 0);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        //package不存在</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;IntentFilter&gt; intentFilters = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;ComponentName&gt; componentNames = new ArrayList&lt;&gt;();</span><br><span class="line">    pm.getPreferredActivities(intentFilters, componentNames, null);</span><br><span class="line">    int size = intentFilters.size();</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        IntentFilter intentFilter = intentFilters.get(i);</span><br><span class="line">        //匹配对应的intent</span><br><span class="line">        if (!intentFilter.hasAction(intent.getAction())) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; categories = intent.getCategories();</span><br><span class="line">        boolean matchCategory = true;</span><br><span class="line">        for (String category : categories) &#123;</span><br><span class="line">            if (!intentFilter.hasCategory(category)) &#123;</span><br><span class="line">                matchCategory = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!matchCategory) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 清除对应intent的默认值</span><br><span class="line">        pm.clearPackagePreferredActivities(componentNames.get(i).getPackageName());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;ResolveInfo&gt; resolveInfos = pm.queryIntentActivities(intent, 0);</span><br><span class="line">    int resolvedSize = resolveInfos.size();</span><br><span class="line">    ComponentName[] set = new ComponentName[resolvedSize];</span><br><span class="line">    int bestMatch = 0;</span><br><span class="line">    for (int i = 0; i &lt; resolvedSize; i++) &#123;</span><br><span class="line">        ResolveInfo resolveInfo = resolveInfos.get(i);</span><br><span class="line">        set[i] = new ComponentName(resolveInfo.activityInfo.packageName, resolveInfo.activityInfo.name);</span><br><span class="line">        if (resolveInfo.match &gt; bestMatch) &#123;</span><br><span class="line">            bestMatch = resolveInfo.match;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    IntentFilter intentFilter = new IntentFilter();</span><br><span class="line">    intentFilter.addAction(intent.getAction());</span><br><span class="line">    Set&lt;String&gt; categories = intent.getCategories();</span><br><span class="line">    for (String category : categories) &#123;</span><br><span class="line">        intentFilter.addCategory(category);</span><br><span class="line">    &#125;</span><br><span class="line">    pm.addPreferredActivity(intentFilter, bestMatch, set, new ComponentName(pkg, className));</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="RoleManager"><a href="#RoleManager" class="headerlink" title="RoleManager"></a>RoleManager</h2><p>查看<a href="https://developer.android.google.cn/reference/kotlin/android/content/pm/PackageManager?hl=en#addpreferredactivity">官方文档</a><br>addPreferredActivity在很早的时候就已经废弃了，虽然目前还能使用，但官方建议使用<a href="https://developer.android.google.cn/reference/android/app/role/RoleManager">RoleManager</a></p>
<blockquote>
<p>角色是系统中与特定权限相关联的唯一名称。<br>可用角色列表可能会随着系统应用程序的更新而更改，因此应用程序不应该假设角色的可用性。<br>在尝试对角色进行任何操作之前，应该始终使用isRoleAvailable(java.lang.String)查询角色是否可用。一些预定义的角色名在这个类中作为常量可用，并且可以在AndroidX role库中找到可能可用的角色列表</p>
</blockquote>
<blockquote>
<p>可以有多个符合角色资格的应用程序，但只有其中的一个子集可以成为角色持有者。<br>要获得角色的资格，应用程序必须满足某些需求，包括在其清单中定义某些组件。这些需求可以在AndroidX库中找到。<br>然后，应用程序将需要用户同意才能成为角色持有人，这可以使用Activity请求startActivityForResult(Intent, int)使用从createRequestRoleIntent(java.lang.String . string)获得的Intent</p>
</blockquote>
<blockquote>
<p>在成为角色持有者之后，应用程序可以被授予特定于角色的某些特权。当应用程序失去其角色时，这些特权也将被撤销</p>
</blockquote>
<p>由此可见，官方将隐式意图抽象成了一个角色，例如作为主页的app，可能有多个符合这个角色的app。</p>
<h2 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h2><p>在Android 11中，有3个公开的接口<code>createRequestRoleIntent</code>,<code>isRoleAvailable</code>,<code>isRoleHeld</code>.</p>
<h3 id="createRequestRoleIntent"><a href="#createRequestRoleIntent" class="headerlink" title="createRequestRoleIntent"></a>createRequestRoleIntent</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns an &#123;@code Intent&#125; suitable for passing to</span><br><span class="line"> * &#123;@link android.app.Activity#startActivityForResult(Intent, int)&#125; which prompts the user to</span><br><span class="line"> * grant a role to this application.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * If the role is granted, the &#123;@code resultCode&#125; will be</span><br><span class="line"> * &#123;@link android.app.Activity#RESULT_OK&#125;, otherwise it will be</span><br><span class="line"> * &#123;@link android.app.Activity#RESULT_CANCELED&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param roleName the name of requested role</span><br><span class="line"> *</span><br><span class="line"> * @return the &#123;@code Intent&#125; to prompt user to grant the role</span><br><span class="line"> */</span><br><span class="line">@NonNull</span><br><span class="line">public Intent createRequestRoleIntent(@NonNull String roleName) &#123;</span><br><span class="line">    Preconditions.checkStringNotEmpty(roleName, &quot;roleName cannot be null or empty&quot;);</span><br><span class="line">    Intent intent = new Intent(ACTION_REQUEST_ROLE);</span><br><span class="line">    intent.setPackage(mContext.getPackageManager().getPermissionControllerPackageName());</span><br><span class="line">    intent.putExtra(Intent.EXTRA_ROLE_NAME, roleName);</span><br><span class="line">    return intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>PKMS相关问题记录</title>
    <url>/2024/07/03/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/9.PKMS%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Signature-privileged-permissions-not-in-privapp-permissions-whitelist-XXXX"><a href="#Signature-privileged-permissions-not-in-privapp-permissions-whitelist-XXXX" class="headerlink" title="Signature|privileged permissions not in privapp-permissions whitelist:XXXX"></a>Signature|privileged permissions not in privapp-permissions whitelist:XXXX</h2><p>报错原因：privapp没有在</p>
<p>AOSP中逻辑：<br>在PMS构造方法中有一个<code>PermissionManagerServiceInternal</code>对象<code>mPermissionManager</code>,<br>在systemReady的时候会去调用<code>mPermissionManager.systemReady()</code>,<br>在方法内部会去判断保存权限问题的集合是否为null，不为null就会抛出异常。<br>PermissionManagerServiceInternal的具体实现在<code>PermissionManagerService</code>中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void systemReady() &#123;</span><br><span class="line">    mSystemReady = true;</span><br><span class="line">    //如果有违反privapp权限的就会抛出异常，系统无法启动</span><br><span class="line">    if (mPrivappPermissionsViolations != null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Signature|privileged permissions not in &quot;</span><br><span class="line">                + &quot;privapp-permissions whitelist: &quot; + mPrivappPermissionsViolations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而mPrivappPermissionsViolations是在grantSignaturePermission中进行处理的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean grantSignaturePermission(String perm, AndroidPackage pkg,</span><br><span class="line">        PackageSetting pkgSetting, BasePermission bp, PermissionsState origPermissions) &#123;</span><br><span class="line">    //......</span><br><span class="line">    boolean privilegedPermission = bp.isPrivileged() || bp.isVendorPrivileged();        </span><br><span class="line">    boolean privappPermissionsDisable =</span><br><span class="line">            RoSystemProperties.CONTROL_PRIVAPP_PERMISSIONS_DISABLE;     </span><br><span class="line">    boolean platformPermission = PLATFORM_PACKAGE_NAME.equals(bp.getSourcePackageName());</span><br><span class="line">    boolean platformPackage = PLATFORM_PACKAGE_NAME.equals(pkg.getPackageName());</span><br><span class="line">    if (!privappPermissionsDisable &amp;&amp; privilegedPermission &amp;&amp; pkg.isPrivileged()</span><br><span class="line">            &amp;&amp; !platformPackage &amp;&amp; platformPermission) &#123;</span><br><span class="line">        //这里去判断是否配置了priviapp的权限白名单，没有白名单就会走内部逻辑</span><br><span class="line">        if (!hasPrivappWhitelistEntry(perm, pkg)) &#123;</span><br><span class="line"></span><br><span class="line">            //....</span><br><span class="line"></span><br><span class="line">                    //这里的逻辑是判断拒绝的权限是否为null，或者请求的权限是否在拒绝的权限中</span><br><span class="line">                    //配合前面判断白名单的逻辑，意思就是没有在xml中明确指定privileged权限是否授权的就是违反规则的权限</span><br><span class="line">                    final boolean permissionViolation =</span><br><span class="line">                            deniedPermissions == null || !deniedPermissions.contains(perm);</span><br><span class="line">                    if (permissionViolation) &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Privileged permission &quot; + perm + &quot; for package &quot;</span><br><span class="line">                                + pkg.getPackageName() + &quot; (&quot; + pkg.getCodePath()</span><br><span class="line">                                + &quot;) not in privapp-permissions whitelist&quot;);</span><br><span class="line"></span><br><span class="line">                        //这里可以看到当ro.control_privapp_permissions这个属性值为enforce的时候就会</span><br><span class="line">                        //给mPrivappPermissionsViolations赋值</span><br><span class="line">                        if (RoSystemProperties.CONTROL_PRIVAPP_PERMISSIONS_ENFORCE) &#123;</span><br><span class="line">                            if (mPrivappPermissionsViolations == null) &#123;</span><br><span class="line">                                mPrivappPermissionsViolations = new ArraySet&lt;&gt;();</span><br><span class="line">                            &#125;</span><br><span class="line">                            mPrivappPermissionsViolations.add(</span><br><span class="line">                                    pkg.getPackageName() + &quot; (&quot; + pkg.getCodePath() + &quot;): &quot;</span><br><span class="line">                                            + perm);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                     </span><br><span class="line">    //......              </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据源码分析，有如下解决办法：</p>
<p>方法1：<br>在<code>frameworks/base/data/etc/privapp-permissions-platform.xml</code>中添加对应app所需的privileged权限</p>
<p>方法2：<br>修改属性值 <code>ro.control_privapp_permissions</code>为<code>disable</code></p>
]]></content>
  </entry>
  <entry>
    <title>framework中一些通用逻辑</title>
    <url>//pages/72a181/</url>
    <content><![CDATA[<h2 id="SystemService的启动"><a href="#SystemService的启动" class="headerlink" title="SystemService的启动"></a>SystemService的启动</h2><p>SystemService是系统进程中运行的服务的基类，基本上所有的系统服务都是继承自SystemService。</p>
<p>SystemService由SystemServiceManager进行管理，一般启动一个SystemService时，<br>是调用SystemServiceManager的<code>startService(String className)</code>或<code>startService(Class&lt;T&gt; serviceClass)</code>,<br>内部实现是通过反射取到service入参只有Context的单参数构造方法，创建实例，调用实例的<code>onStart()</code>方法。</p>
<p><strong>所以SystemService的启动主要看 <code>onStart()</code> 中的实现。</strong></p>
<p>另外还需要关注一下 <code>onBootPhase</code>, 在SystemServer启动的不同阶段，都会通过SystemServiceManager对已经启动的SystemService进行通知。</p>
<p>目前有一下几个启动阶段：</p>
<table>
<thead>
<tr>
<th>启动阶段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PHASE_WAIT_FOR_DEFAULT_DISPLAY</td>
<td>系统在启动时发送给系统服务的最早启动阶段</td>
</tr>
<tr>
<td>PHASE_LOCK_SETTINGS_READY</td>
<td>在这个启动阶段之后，服务可以获得锁设置数据</td>
</tr>
<tr>
<td>PHASE_SYSTEM_SERVICES_READY</td>
<td>在这个启动阶段之后，服务可以安全地调用核心系统服务，如PowerManager或PackageManager</td>
</tr>
<tr>
<td>PHASE_DEVICE_SPECIFIC_SERVICES_READY</td>
<td>在这个启动阶段之后，服务可以安全地调用特定于设备的服务</td>
</tr>
<tr>
<td>PHASE_ACTIVITY_MANAGER_READY</td>
<td>在这个启动阶段之后，服务可以广播intent。</td>
</tr>
<tr>
<td>PHASE_THIRD_PARTY_APPS_CAN_START</td>
<td>在这个启动阶段之后，服务可以启动&#x2F;绑定到第三方应用程序。应用程序将能够使用Binder进行服务调用</td>
</tr>
<tr>
<td>PHASE_BOOT_COMPLETED</td>
<td>在这个启动阶段之后，服务可以允许用户与设备交互。这个阶段发生在启动完成并且主应用程序启动时。为降低延时，系统服务可能更建议监听这个阶段，而不是注册一个广播接收器{@link android.content.Intent#ACTION_LOCKED_BOOT_COMPLETED}</td>
</tr>
</tbody></table>
<p>除了PHASE_BOOT_COMPLETED是在AMS中触发的，其他启动阶段都是在SystemServer中触发。</p>
<h3 id="log关键字"><a href="#log关键字" class="headerlink" title="log关键字"></a>log关键字</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//UserController中发送的广播</span><br><span class="line">uc_send_user_broadcast (userId|1|5),(IntentAction|3)</span><br></pre></td></tr></table></figure>


<h2 id="EventLogTags"><a href="#EventLogTags" class="headerlink" title="EventLogTags"></a>EventLogTags</h2><p>在framework中有一个<code>services.core.unboosted</code>,这个模块对EventLogTags.logtags进行了编译<br>在 android&#x2F;build&#x2F;soong&#x2F;java&#x2F;gen.go 中的 genSources 中大概可以看出，会将 <code>.logtags</code>的文件编译成java文件</p>
<h2 id="Android中的Makefile"><a href="#Android中的Makefile" class="headerlink" title="Android中的Makefile"></a>Android中的Makefile</h2><p><code>build/make/core/Makefile</code>中看到有 <code>$(hide)</code>的标记，表示引用hide变量，全局搜索”hide :&#x3D;”的字眼，可以发现build&#x2F;make&#x2F;core&#x2F;config.mk中有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ###############################################################</span><br><span class="line"># Parse out any modifier targets.</span><br><span class="line"># ###############################################################</span><br><span class="line"></span><br><span class="line">hide := @</span><br></pre></td></tr></table></figure>
<p><strong>说明所有的$(hide) xxxx语句，其实就等同于命令前加了“@”字符，即在Makefile中表示的时关闭了回显，说明Makefile在执行@后面的命令时，不回显将要执行的命令。</strong></p>
<p>Makefile中，格式为这样的</p>
<p>target : prerequisties<br>目标：需要依赖的条件</p>
<p>但如果文件多了，按部就班写会显得很长，所有这时候makefile中的常用命令就产生了，如下：</p>
<ul>
<li><strong>$@ 表示目标文件</strong></li>
<li>$^ 表示所有的依赖文件</li>
<li>$&lt; 表示第一个依赖文件</li>
<li>$? 表示比目标还要新的依赖文件列表</li>
</ul>
<h2 id="配置系统属性"><a href="#配置系统属性" class="headerlink" title="配置系统属性"></a>配置系统属性</h2><p>修改<code>system.prop</code>配置文件</p>
<p>可以在<code>build/make/core/Makefile</code>中找到如下逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifdef TARGET_SYSTEM_PROP</span><br><span class="line">system_prop_file := $(TARGET_SYSTEM_PROP)</span><br><span class="line">else</span><br><span class="line">system_prop_file := $(wildcard $(TARGET_DEVICE_DIR)/system.prop)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">$(intermediate_system_build_prop): $(BUILDINFO_SH) $(BUILDINFO_COMMON_SH) $(INTERNAL_BUILD_ID_MAKEFILE) $(BUILD_SYSTEM)/version_defaults.mk $(system_prop_file) $(INSTALLED_ANDROID_INFO_TXT_TARGET) $(API_FINGERPRINT) $(POST_PROCESS_PROPS)</span><br><span class="line">	@echo Target buildinfo: $@</span><br><span class="line">	@mkdir -p $(dir $@)</span><br><span class="line">	$(hide) echo &gt; $@</span><br><span class="line">	$(hide) PRODUCT_BRAND=&quot;$(PRODUCT_SYSTEM_BRAND)&quot; \</span><br><span class="line">	        PRODUCT_MANUFACTURER=&quot;$(PRODUCT_SYSTEM_MANUFACTURER)&quot; \</span><br><span class="line">	        PRODUCT_MODEL=&quot;$(PRODUCT_SYSTEM_MODEL)&quot; \</span><br><span class="line">	        PRODUCT_NAME=&quot;$(PRODUCT_SYSTEM_NAME)&quot; \</span><br><span class="line">	        PRODUCT_DEVICE=&quot;$(PRODUCT_SYSTEM_DEVICE)&quot; \</span><br><span class="line">	        $(call generate-common-build-props-with-product-vars-set,system,$@)</span><br><span class="line">	$(hide) TARGET_BUILD_TYPE=&quot;$(TARGET_BUILD_VARIANT)&quot; \</span><br><span class="line">	        TARGET_BUILD_FLAVOR=&quot;$(TARGET_BUILD_FLAVOR)&quot; \</span><br><span class="line">	        TARGET_DEVICE=&quot;$(TARGET_DEVICE)&quot; \</span><br><span class="line">	        PRODUCT_DEFAULT_LOCALE=&quot;$(call get-default-product-locale,$(PRODUCT_LOCALES))&quot; \</span><br><span class="line">	        PRODUCT_DEFAULT_WIFI_CHANNELS=&quot;$(PRODUCT_DEFAULT_WIFI_CHANNELS)&quot; \</span><br><span class="line">	        PRIVATE_BUILD_DESC=&quot;$(PRIVATE_BUILD_DESC)&quot; \</span><br><span class="line">	        BUILD_ID=&quot;$(BUILD_ID)&quot; \</span><br><span class="line">	        BUILD_DISPLAY_ID=&quot;$(BUILD_DISPLAY_ID)&quot; \</span><br><span class="line">	        DATE=&quot;$(DATE_FROM_FILE)&quot; \</span><br><span class="line">	        BUILD_USERNAME=&quot;$(BUILD_USERNAME)&quot; \</span><br><span class="line">	        BUILD_HOSTNAME=&quot;$(BUILD_HOSTNAME)&quot; \</span><br><span class="line">	        BUILD_NUMBER=&quot;$(BUILD_NUMBER_FROM_FILE)&quot; \</span><br><span class="line">	        BOARD_BUILD_SYSTEM_ROOT_IMAGE=&quot;$(BOARD_BUILD_SYSTEM_ROOT_IMAGE)&quot; \</span><br><span class="line">	        PLATFORM_VERSION=&quot;$(PLATFORM_VERSION)&quot; \</span><br><span class="line">	        PLATFORM_VERSION_LAST_STABLE=&quot;$(PLATFORM_VERSION_LAST_STABLE)&quot; \</span><br><span class="line">	        PLATFORM_SECURITY_PATCH=&quot;$(PLATFORM_SECURITY_PATCH)&quot; \</span><br><span class="line">	        PLATFORM_BASE_OS=&quot;$(PLATFORM_BASE_OS)&quot; \</span><br><span class="line">	        PLATFORM_SDK_VERSION=&quot;$(PLATFORM_SDK_VERSION)&quot; \</span><br><span class="line">	        PLATFORM_PREVIEW_SDK_VERSION=&quot;$(PLATFORM_PREVIEW_SDK_VERSION)&quot; \</span><br><span class="line">	        PLATFORM_PREVIEW_SDK_FINGERPRINT=&quot;$$(cat $(API_FINGERPRINT))&quot; \</span><br><span class="line">	        PLATFORM_VERSION_CODENAME=&quot;$(PLATFORM_VERSION_CODENAME)&quot; \</span><br><span class="line">	        PLATFORM_VERSION_ALL_CODENAMES=&quot;$(PLATFORM_VERSION_ALL_CODENAMES)&quot; \</span><br><span class="line">	        PLATFORM_MIN_SUPPORTED_TARGET_SDK_VERSION=&quot;$(PLATFORM_MIN_SUPPORTED_TARGET_SDK_VERSION)&quot; \</span><br><span class="line">	        BUILD_VERSION_TAGS=&quot;$(BUILD_VERSION_TAGS)&quot; \</span><br><span class="line">	        $(if $(OEM_THUMBPRINT_PROPERTIES),BUILD_THUMBPRINT=&quot;$(BUILD_THUMBPRINT_FROM_FILE)&quot;) \</span><br><span class="line">	        TARGET_CPU_ABI_LIST=&quot;$(TARGET_CPU_ABI_LIST)&quot; \</span><br><span class="line">	        TARGET_CPU_ABI_LIST_32_BIT=&quot;$(TARGET_CPU_ABI_LIST_32_BIT)&quot; \</span><br><span class="line">	        TARGET_CPU_ABI_LIST_64_BIT=&quot;$(TARGET_CPU_ABI_LIST_64_BIT)&quot; \</span><br><span class="line">	        TARGET_CPU_ABI=&quot;$(TARGET_CPU_ABI)&quot; \</span><br><span class="line">	        TARGET_CPU_ABI2=&quot;$(TARGET_CPU_ABI2)&quot; \</span><br><span class="line">	        bash $(BUILDINFO_SH) &gt;&gt; $@</span><br><span class="line">	$(hide) $(foreach file,$(system_prop_file), \</span><br><span class="line">	    if [ -f &quot;$(file)&quot; ]; then \</span><br><span class="line">	        echo Target buildinfo from: &quot;$(file)&quot;; \</span><br><span class="line">	        echo &quot;&quot; &gt;&gt; $@; \</span><br><span class="line">	        echo &quot;#&quot; &gt;&gt; $@; \</span><br><span class="line">	        echo &quot;# from $(file)&quot; &gt;&gt; $@; \</span><br><span class="line">	        echo &quot;#&quot; &gt;&gt; $@; \</span><br><span class="line">	        cat $(file) &gt;&gt; $@; \</span><br><span class="line">	        echo &quot;# end of $(file)&quot; &gt;&gt; $@; \</span><br><span class="line">	    fi;)</span><br><span class="line">	$(if $(FINAL_BUILD_PROPERTIES), \</span><br><span class="line">	    $(hide) echo &gt;&gt; $@; \</span><br><span class="line">	            echo &quot;#&quot; &gt;&gt; $@; \</span><br><span class="line">	            echo &quot;# ADDITIONAL_BUILD_PROPERTIES&quot; &gt;&gt; $@; \</span><br><span class="line">	            echo &quot;#&quot; &gt;&gt; $@; )</span><br><span class="line">	$(hide) $(foreach line,$(FINAL_BUILD_PROPERTIES), \</span><br><span class="line">	    echo &quot;$(line)&quot; &gt;&gt; $@;)</span><br><span class="line">	$(hide) $(POST_PROCESS_PROPS) $@ $(PRODUCT_SYSTEM_PROPERTY_BLACKLIST)</span><br><span class="line"></span><br><span class="line">build_desc :=</span><br><span class="line"></span><br><span class="line">INSTALLED_RECOVERYIMAGE_TARGET :=</span><br><span class="line">ifdef BUILDING_RECOVERY_IMAGE</span><br><span class="line">ifneq ($(BOARD_USES_RECOVERY_AS_BOOT),true)</span><br><span class="line">INSTALLED_RECOVERYIMAGE_TARGET := $(PRODUCT_OUT)/recovery.img</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">$(INSTALLED_BUILD_PROP_TARGET): $(intermediate_system_build_prop)</span><br><span class="line">	@echo &quot;Target build info: $@&quot;</span><br><span class="line">	$(hide) grep -v &#x27;ro.product.first_api_level&#x27; $(intermediate_system_build_prop) &gt; $@</span><br></pre></td></tr></table></figure>

<p>生成的属性在ROM中的路径（system&#x2F;build.prop）可以参考以下逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -----------------------------------------------------------------</span><br><span class="line"># build.prop</span><br><span class="line">INSTALLED_BUILD_PROP_TARGET := $(TARGET_OUT)/build.prop</span><br><span class="line">ALL_DEFAULT_INSTALLED_MODULES += $(INSTALLED_BUILD_PROP_TARGET)</span><br><span class="line">FINAL_BUILD_PROPERTIES := \</span><br><span class="line">    $(call collapse-pairs, $(ADDITIONAL_BUILD_PROPERTIES))</span><br><span class="line">FINAL_BUILD_PROPERTIES := $(call uniq-pairs-by-first-component, \</span><br><span class="line">    $(FINAL_BUILD_PROPERTIES),=)</span><br></pre></td></tr></table></figure>

<p>build&#x2F;make&#x2F;core&#x2F;envsetup.mk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TARGET_OUT := $(PRODUCT_OUT)/$(TARGET_COPY_OUT_SYSTEM)</span><br><span class="line"></span><br><span class="line">TARGET_COPY_OUT_SYSTEM := system</span><br><span class="line"></span><br><span class="line">PRODUCT_OUT := $(TARGET_PRODUCT_OUT_ROOT)/$(TARGET_DEVICE)</span><br><span class="line"></span><br><span class="line">TARGET_PRODUCT_OUT_ROOT := $(TARGET_OUT_ROOT)/product</span><br><span class="line"></span><br><span class="line">TARGET_OUT_ROOT := $(OUT_DIR)/target</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>build&#x2F;make&#x2F;tools&#x2F;releasetools&#x2F;build_image.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Args:</span><br><span class="line">    in_dir: Path to input directory.</span><br><span class="line">    prop_dict: A property dict that contains info like partition size. Values</span><br><span class="line">        will be updated with computed values.</span><br><span class="line">    out_file: The output image file.</span><br><span class="line">    target_out: Path to the TARGET_OUT directory as in Makefile. It actually</span><br><span class="line">        points to the /system directory under PRODUCT_OUT. fs_config (the one</span><br><span class="line">        under system/core/libcutils) reads device specific FS config files from</span><br><span class="line">        there.</span><br><span class="line">    fs_config: The fs_config file that drives the prototype</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="proto文件编译成java"><a href="#proto文件编译成java" class="headerlink" title="proto文件编译成java"></a>proto文件编译成java</h2><p>在<code>build/make/core/java_common.mk</code>中有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(call transform-proto-to-java)</span><br></pre></td></tr></table></figure>
<p>该方法定义在了<code>build/make/core/definitions.mk</code><br>是用<code>$(PROTOC)</code>来进行转化的<br>在<code>build/make/core/config.mk</code>中找到了<code>$(PROTOC)</code>的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROTOC := $(HOST_OUT_EXECUTABLES)/aprotoc$(HOST_EXECUTABLE_SUFFIX)</span><br></pre></td></tr></table></figure>
<p>对应文件<code>out/soong/host/linux-x86/bin/aprotoc</code></p>
<p>默认的编译指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aprotoc --proto_path=$projectDir --java_out=lite:$outputDir protoFiles</span><br></pre></td></tr></table></figure>

<p>可以通过gradle自定义任务来自定义proto转java：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//proto生成java</span><br><span class="line">tasks.register(&#x27;generateProtoJava&#x27;) &#123;</span><br><span class="line">    String protoDir = &quot;$projectDir/protos&quot;</span><br><span class="line"></span><br><span class="line">    //要处理的Proto文件</span><br><span class="line">    FileTree protoFileTree = fileTree(dir: protoDir, include: &quot;**/*.proto&quot;)</span><br><span class="line">    String protoFiles = protoFileTree.files.join(&quot; &quot;)</span><br><span class="line">    println protoFiles</span><br><span class="line"></span><br><span class="line">    //生成的java文件路径</span><br><span class="line">    String outputDir = &quot;$projectDir/.tmp&quot;</span><br><span class="line">    String outputParams = &quot;lite:$outputDir&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    println &quot;proto生成的java文件将放在$outputDir&quot;</span><br><span class="line"></span><br><span class="line">    //protoc路径</span><br><span class="line">    String protoc = &quot;/home/lifeifei/workspace/changan_75a121/lagvm/lagvm/LINUX/android/out/soong/host/linux-x86/bin/aprotoc&quot;</span><br><span class="line"></span><br><span class="line">    exec &#123;</span><br><span class="line">        commandLine protoc, &quot;--proto_path=$projectDir&quot;, &quot;--java_out=$outputParams&quot;, protoFiles</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="aidl文件编译成java"><a href="#aidl文件编译成java" class="headerlink" title="aidl文件编译成java"></a>aidl文件编译成java</h2><p><code>build/make/core/java.mk</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###########################################################</span><br><span class="line">## AIDL: Compile .aidl files to .java</span><br><span class="line">###########################################################</span><br><span class="line">aidl_sources := $(filter %.aidl,$(LOCAL_SRC_FILES))</span><br><span class="line">aidl_java_sources :=</span><br><span class="line"></span><br><span class="line">ifneq ($(strip $(aidl_sources)),)</span><br><span class="line"></span><br><span class="line">aidl_preprocess_import :=</span><br><span class="line">ifdef LOCAL_SDK_VERSION</span><br><span class="line">ifneq ($(filter current system_current test_current core_current, $(LOCAL_SDK_VERSION)$(TARGET_BUILD_APPS_USE_PREBUILT_SDK)),)</span><br><span class="line">  # LOCAL_SDK_VERSION is current and no TARGET_BUILD_APPS</span><br><span class="line">  aidl_preprocess_import := $(FRAMEWORK_AIDL)</span><br><span class="line">else</span><br><span class="line">  aidl_preprocess_import := $(call resolve-prebuilt-sdk-aidl-path,$(LOCAL_SDK_VERSION))</span><br><span class="line">endif # not current or system_current</span><br><span class="line">else</span><br><span class="line"># build against the platform.</span><br><span class="line">LOCAL_AIDL_INCLUDES += $(FRAMEWORKS_BASE_JAVA_SRC_DIRS)</span><br><span class="line">endif # LOCAL_SDK_VERSION</span><br><span class="line"></span><br><span class="line">$(foreach s,$(aidl_sources),\</span><br><span class="line">    $(eval $(call define-aidl-java-rule,$(s),$(intermediates.COMMON)/aidl,aidl_java_sources)))</span><br><span class="line">$(foreach java,$(aidl_java_sources), \</span><br><span class="line">    $(call include-depfile,$(java:%.java=%.P),$(java)))</span><br><span class="line"></span><br><span class="line">$(aidl_java_sources) : $(LOCAL_ADDITIONAL_DEPENDENCIES) $(aidl_preprocess_import)</span><br><span class="line"></span><br><span class="line">$(aidl_java_sources): PRIVATE_AIDL_FLAGS := $(addprefix -p,$(aidl_preprocess_import)) -I$(LOCAL_PATH) -I$(LOCAL_PATH)/src $(addprefix -I,$(LOCAL_AIDL_INCLUDES))</span><br><span class="line">$(aidl_java_sources): PRIVATE_MODULE := $(LOCAL_MODULE)</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>主要参数 看 PRIVATE_AIDL_FLAGS，通过-p 指定了预编译的aidl， -I 指定了aidl搜索目录</p>
<ol>
<li>aidl使用说明<br>aidl –lang&#x3D;{java|cpp|ndk} [options] input_aidl_file。<br>在命令行中，aidl不带任何参数，打印使用说明。</li>
<li>–lang&#x3D;{java|cpp|ndk}<br>指定生成接口类型。如果不指定，默认生成Java文件。</li>
<li>-o 指定输出目录<br>Java：省略-o参数，java文件生成到aidl文件目录下。<br>C++&#x2F;Rust：必选参数。<br>为了清除查看效果，指定到单独的目录：-o .&#x2F;java</li>
<li>-I DIR, –include&#x3D;DIR<br>import搜索路径，指定依赖的aidl文件所在目录。不是C++头文件目录。<br>例如：IMyServiceInterface.aidl引用了IMyServiceCallback.aidl，在生成IMyServiceInterface.aidl的时候需要指定-I参数才能正常编译。<br>只要是AIDL文件中有依赖，生成任何类型的接口（Java、C++、Rust）都要指定这个参数</li>
</ol>
<p>所以常用的aidl转java指令如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aidl $aidlFile -p $frameworkAIDL -I $searchDir -o output</span><br></pre></td></tr></table></figure>
<p>其中 frameworkAIDL是指framework.aidl，AOSP编译后在<code>out/soong/framework.aidl</code>可以找到，<br>也可以在SDK中找到例如：<code>Sdk/platforms/android-33/framework.aidl</code></p>
<p>可以通过gradle自定义任务来自定义aidl转java：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//aidl生成java</span><br><span class="line">tasks.register(&#x27;generateAidlJava&#x27;) &#123;</span><br><span class="line">    String frameworkAIDL = &quot;/home/lifeifei/workspace/changan_75a121/lagvm/lagvm/LINUX/android/out/soong/framework.aidl&quot;</span><br><span class="line">    String dmsAIDLDir = &quot;/home/lifeifei/workspace/changan_75a121/lagvm/lagvm/LINUX/android/vendor/chinatsp/services/DMS/aidl&quot;</span><br><span class="line">    String sceneAppAIDLDir = &quot;/home/lifeifei/workspace/changan_75a121/lagvm/lagvm/LINUX/android/vendor/chinatsp/apps/SceneApp/aidl&quot;</span><br><span class="line">    // 指定需要编译的 AIDL 文件的位置</span><br><span class="line">    FileTree aidlFiles = fileTree(dir: &quot;$&#123;dmsAIDLDir&#125;&quot;, include: &#x27;**/*.aidl&#x27;)</span><br><span class="line">    aidlFiles += fileTree(dir: &quot;$&#123;sceneAppAIDLDir&#125;&quot;, include: &#x27;**/*.aidl&#x27;)</span><br><span class="line"></span><br><span class="line">    // 生成 Java 文件的位置</span><br><span class="line">    File javaDir = new File(&quot;$&#123;projectDir&#125;/.tmp&quot;)</span><br><span class="line">    println &quot;AIDL生成的java文件将放在 $javaDir&quot;</span><br><span class="line"></span><br><span class="line">    // 定义 aidl 执行文件路径</span><br><span class="line">    String aidlCmd = &quot;/home/lifeifei/Android/Sdk/build-tools/33.0.2/aidl&quot;</span><br><span class="line"></span><br><span class="line">    // 遍历所有 AIDL 文件并编译为 Java 文件</span><br><span class="line">    aidlFiles.each &#123; File inputFile -&gt;</span><br><span class="line">        def aidlFile = inputFile.absolutePath</span><br><span class="line">        println &quot;处理 $aidlFile&quot;</span><br><span class="line">        exec &#123;</span><br><span class="line">            commandLine aidlCmd, aidlFile,</span><br><span class="line">                    &quot;-p $frameworkAIDL&quot;,</span><br><span class="line">                    &quot;-I $dmsAIDLDir&quot;,</span><br><span class="line">                    &quot;-I $sceneAppAIDLDir&quot;,</span><br><span class="line">                    &quot;-o&quot;, javaDir</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AOSP中AIDL作为源文件进行编译，编译后会在对应out下生存</p>
<h2 id="记录一些关键的tag"><a href="#记录一些关键的tag" class="headerlink" title="记录一些关键的tag"></a>记录一些关键的tag</h2><p>关于tag的描述可以参考 system&#x2F;core&#x2F;logcat&#x2F;event.logtags<br>格式：(&lt;name&gt;|data type[|data unit])<br>data type:<br>    1: int<br>    2: long<br>    3: string<br>    4: list<br>    5: float<br>data unit:<br>    1: Number of objects<br>    2: Number of bytes<br>    3: Number of milliseconds<br>    4: Number of allocations<br>    5: Id<br>    6: Percent<br>    s: Number of seconds (monotonic time)<br>    Default value for data of type int&#x2F;long is 2 (bytes).</p>
<h3 id="系统事件"><a href="#系统事件" class="headerlink" title="系统事件"></a>系统事件</h3><table>
<thead>
<tr>
<th align="left">tag</th>
<th>对应代码</th>
<th>对应方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boot_progress_ams_ready</td>
<td>writeBootProgressAmsReady</td>
<td>对应 AMS 中的 ActivityManagerService.systemReady()</td>
</tr>
</tbody></table>
<p>|commit_sys_config_file | writeCommitSysConfigFile |    记录写入&#x2F;data&#x2F;system&#x2F;下配置文件的时间</p>
<h3 id="CarService事件"><a href="#CarService事件" class="headerlink" title="CarService事件"></a>CarService事件</h3><table>
<thead>
<tr>
<th align="left">tag</th>
<th>对应代码</th>
<th>对应方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">car_service_create</td>
<td>EventLogTags.CAR_SERVICE_CREATE</td>
<td>在CarService创建和销毁的时候会有对应tag</td>
</tr>
<tr>
<td align="left">car_helper_start</td>
<td>EventLogTags.CAR_HELPER_START</td>
<td>在CarServiceHelperService start的时候打印对应的tag</td>
</tr>
</tbody></table>
<h3 id="进程启动相关"><a href="#进程启动相关" class="headerlink" title="进程启动相关"></a>进程启动相关</h3><table>
<thead>
<tr>
<th align="left">tag</th>
<th>对应代码</th>
<th>对应方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">am_proc_bound</td>
<td>EventLogTags.writeAmProcBound</td>
<td>在 attachApplicationLocked 时,对应方法ActivityManagerService.attachApplicationLocked()</td>
</tr>
<tr>
<td align="left">am_proc_died</td>
<td>EventLogTags.writeAmProcDied</td>
<td>在 ActivityManagerService.appDiedLocked()</td>
</tr>
<tr>
<td align="left">am_proc_start</td>
<td>EventLog.writeEvent(EventLogTags.AM_PROC_START)</td>
<td>在fork成功后，对应方法ProcessList.handleProcessStartedLocked()</td>
</tr>
<tr>
<td align="left">am_crash</td>
<td>EventLogTags.writeAmCrash</td>
<td>在AMS的handleApplicationCrashInner</td>
</tr>
</tbody></table>
<h2 id="stack相关tag"><a href="#stack相关tag" class="headerlink" title="stack相关tag"></a>stack相关tag</h2><p>| tag | 对应代码 | 对应方法<br>|am_task_create |<br>|am_stack_create| </p>
<h3 id="窗口切换相关"><a href="#窗口切换相关" class="headerlink" title="窗口切换相关"></a>窗口切换相关</h3><table>
<thead>
<tr>
<th align="left">tag</th>
<th>对应代码</th>
<th>对应方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">wm_restart_activity</td>
<td>EventLogTags.writeWmRestartActivity</td>
<td>在启动Actitity时，对应方法ActivityStackSupervisor.realStartActivityLocked()</td>
</tr>
<tr>
<td align="left">wm_on_create_called</td>
<td>EventLogTags.writeWmOnCreateCalled</td>
<td>在onCreate之后，对应方法：Activity.performCreate()</td>
</tr>
<tr>
<td align="left">wm_on_start_called</td>
<td>EventLogTags.writeWmOnStartCalled</td>
<td>在onStart之后，对应方法：Activity.performStart()</td>
</tr>
<tr>
<td align="left">wm_on_resume_called</td>
<td>EventLogTags.writeWmOnResumeCalled</td>
<td>在onResume之后,对应方法：Activity.performResume()</td>
</tr>
<tr>
<td align="left">wm_on_top_resumed_gained_called</td>
<td>EventLogTags.writeWmOnTopResumedGainedCalled</td>
<td>在onResume之后,对应方法：Activity.performTopResumedActivityChanged()</td>
</tr>
<tr>
<td align="left">wm_activity_launch_time</td>
<td>EventLog.writeEvent(WM_ACTIVITY_LAUNCH_TIME)</td>
<td>在onResume之后对应方法ActivityMetricsLogger.logAppDisplayed()</td>
</tr>
<tr>
<td align="left">wm_on_top_resumed_lost_called</td>
<td>EventLogTags.writeWmOnTopResumedLostCalled</td>
<td>在onResume和onPause之间，对应方法：Activity.performTopResumedActivityChanged()</td>
</tr>
<tr>
<td align="left">wm_pause_activity</td>
<td>EventLogTags.writeWmPauseActivity</td>
<td>开始调用pause时，在onPause之前，对应方法ActivityStack.startPausingLocked()</td>
</tr>
<tr>
<td align="left">wm_on_paused_called</td>
<td>EventLogTags.writeWmOnPausedCalled</td>
<td>在onPause之后，对应方法：Activity.performPause()</td>
</tr>
<tr>
<td align="left">wm_set_resumed_activity</td>
<td>EventLogTags.writeWmSetResumedActivity</td>
<td>对应方法ActivityTaskManagerService.setResumedActivityUncheckLocked()</td>
</tr>
<tr>
<td align="left">wm_add_to_stopping</td>
<td>EventLogTags.writeWmAddToStopping</td>
<td>对应方法ActvityRecord.addToStopping()</td>
</tr>
<tr>
<td align="left">wm_resume_activity</td>
<td>EventLogTags.writeWmResumeActivity</td>
<td>对应方法ActivityStack.resumeTopActivityInnerLocked()</td>
</tr>
<tr>
<td align="left">wm_on_restart_called</td>
<td>EventLogTags.writeWmOnRestartCalled</td>
<td>在onRestart之后，对应方法：Activity.performRestart()</td>
</tr>
<tr>
<td align="left">wm_stop_activity</td>
<td>EventLogTags.writeWmStopActivity</td>
<td>开始调用stop时，对应方法ActivityRecord.stopIfPossible()</td>
</tr>
<tr>
<td align="left">wm_on_stop_called</td>
<td>EventLogTags.writeWmOnStopCalled</td>
<td>在onStop之后，对应Activity.performStop()</td>
</tr>
<tr>
<td align="left">wm_finish_activity</td>
<td>EventLogTags.writeWmFinishActivity</td>
<td>调用finish时，对应方法ActivityRecord.finishIfPossible()</td>
</tr>
<tr>
<td align="left">wm_destroy_activity</td>
<td>EventLogTags.writeWmDestroyActivity</td>
<td>writeWmDestroyActivity 对应方法ActivityRecord.destroyImmediately()</td>
</tr>
<tr>
<td align="left">wm_on_destroy_called</td>
<td>EventLogTags.writeWmOnDestroyCalled</td>
<td>在onDestory之后，对应方法Activity.performDestroy(</td>
</tr>
</tbody></table>
<h2 id="关键类继承关系"><a href="#关键类继承关系" class="headerlink" title="关键类继承关系"></a>关键类继承关系</h2><p>WindowContainer<br>    WindowToken<br>        ActivityRecord<br>    RootWindowContainer<br>    Task<br>    WindowState</p>
<h2 id="查看APP组件-Components-启用-禁用状态"><a href="#查看APP组件-Components-启用-禁用状态" class="headerlink" title="查看APP组件(Components)启用&#x2F;禁用状态"></a>查看APP组件(Components)启用&#x2F;禁用状态</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dumpsys package com.omosoft.avmservice|grep --color=always -A 2 enable</span><br></pre></td></tr></table></figure>
<p>要启用或禁用可以通过pm来操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#启用组件</span><br><span class="line">pm enable --user 0 com.omosoft.avmservice/.AvmService</span><br><span class="line">#禁用组件</span><br><span class="line">pm disable --user 0 com.omosoft.avmservice/.AvmService</span><br></pre></td></tr></table></figure>

<h2 id="打开-关闭指针位置"><a href="#打开-关闭指针位置" class="headerlink" title="打开&#x2F;关闭指针位置"></a>打开&#x2F;关闭指针位置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put system pointer_location 1</span><br><span class="line">adb shell settings put system pointer_location 0</span><br></pre></td></tr></table></figure>

<h2 id="修改动画倍数"><a href="#修改动画倍数" class="headerlink" title="修改动画倍数"></a>修改动画倍数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put global window_animation_scale 0.5</span><br><span class="line">adb shell settings put global transition_animation_scale 0.5</span><br><span class="line">adb shell settings put global animator_duration_scale 0.5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法名称后缀"><a href="#方法名称后缀" class="headerlink" title="方法名称后缀"></a>方法名称后缀</h2><p><code>Lw</code> 是指 “Lightweight”，表示某个方法或功能的实现是轻量级的，通常意味着该实现不涉及复杂的逻辑或资源消耗较少。这种轻量级实现的目的是为了提高性能、减少内存占用或简化代码结构。</p>
<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>WINDOW MANAGER WINDOWS</p>
<h2 id="AAOS多用户开启-关闭"><a href="#AAOS多用户开启-关闭" class="headerlink" title="AAOS多用户开启&#x2F;关闭"></a>AAOS多用户开启&#x2F;关闭</h2><p>多用户的内容可以参考官方文档：<br><a href="https://source.android.google.cn/docs/devices/admin/multi-user#applying_the_overlay">https://source.android.google.cn/docs/devices/admin/multi-user#applying_the_overlay</a><br><a href="https://source.android.google.cn/docs/devices/admin/multi-user#enabling-the-headless-system-user">https://source.android.google.cn/docs/devices/admin/multi-user#enabling-the-headless-system-user</a><br><a href="https://source.android.google.cn/docs/automotive/users_accounts/multi_user">https://source.android.google.cn/docs/automotive/users_accounts/multi_user</a></p>
<p>在搭载车载feature的AOSP中(AAOP [Android Automotive OS])，默认启用了<code>Headless system user</code>,<a href="https://source.android.google.cn/docs/devices/admin/multi-user#enabling-the-headless-system-user">官方文档</a>有说明如何启用的。</p>
<p>同时更详细的汽车多用户也可以在<a href="https://source.android.google.cn/docs/devices/admin/multi-user#android-automotive-multi-user">官方文档</a>中找到.<br><code>Headless system user</code>就是启动时初始化的第一个用户，不过这个用户一直运行在后台，需要额外的前台用户才能进行界面交互</p>
<p>根据官方文档所说，开启关闭多用户只需要禁用headless system user即可</p>
<ul>
<li>启用<code>Headless system user</code>后，需要将<code>config_multiuserMaximumUsers</code>的值设置为2(或以上)，</li>
<li>关闭多用户</li>
</ul>
<p><code>ro.fw.mu.headless_system_user</code>属性值控制是否启用无头系统用户<br><code>android.car.number_pre_created_users</code>预创建的user<br><code>android.car.number_pre_created_guests</code>预创建的guest<br><code>android.car.user_hal_enabled</code>是否启用<a href="https://source.android.google.cn/docs/automotive/users_accounts/user_hal?hl=zh-cn#enable-the-user-hal">用户HAL属性</a></p>
<p>如果禁用了多用户，用户HAL属性没有打开的必要，引用官方的说明：</p>
<blockquote>
<p>从 Android 11 开始，Android Automotive OS (AAOS) 在 VHAL 上引入了一组新属性，用于创建、切换、删除和关联外部配件以识别用户。例如，这些新属性使驱动程序能够将外部配件（例如密钥卡）与其 Android 用户配对。然后，当驾驶员接近车辆时，ECU 被唤醒并检测到钥匙扣。该 ECU 向 HAL 指示信息娱乐系统应启动哪个 Android 用户，从而减少驱动程序等待其 Android 用户加载的时间。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 多用户相关</span><br><span class="line">PRODUCT_PRODUCT_PROPERTIES += \</span><br><span class="line">    ro.fw.mu.headless_system_user=false \</span><br><span class="line">    android.car.number_pre_created_users=0 \</span><br><span class="line">    android.car.number_pre_created_guests=0 \</span><br><span class="line">    android.car.user_hal_enabled=false</span><br></pre></td></tr></table></figure>

<h2 id="添加系统属性"><a href="#添加系统属性" class="headerlink" title="添加系统属性"></a>添加系统属性</h2><p><a href="https://source.android.google.cn/docs/core/architecture/configuration/add-system-properties?authuser=0&hl=zh-cn">https://source.android.google.cn/docs/core/architecture/configuration/add-system-properties?authuser=0&amp;hl=zh-cn</a><br><a href="https://android.googlesource.com/platform/build/+/refs/heads/main/Changes.md">https://android.googlesource.com/platform/build/+/refs/heads/main/Changes.md</a></p>
<h2 id="特权白名单-privileged-permission"><a href="#特权白名单-privileged-permission" class="headerlink" title="特权白名单(privileged permission)"></a>特权白名单(privileged permission)</h2><p><a href="https://source.android.google.cn/docs/core/permissions/perms-allowlist?hl=zh-cn">https://source.android.google.cn/docs/core/permissions/perms-allowlist?hl=zh-cn</a></p>
<h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><ol>
<li>eventtags</li>
</ol>
<p><code>system/core/init/perfboot.py</code>可以将关键节点导出到表格<br>2. kpi_values<br><code>cat /sys/kernel/boot_kpi/kpi_values</code></p>
<h2 id="Android启动流程节点记录"><a href="#Android启动流程节点记录" class="headerlink" title="Android启动流程节点记录"></a>Android启动流程节点记录</h2><p>在finishUserUnlocked的时候，会去启动U0用户下的Persistent app</p>
<h2 id="dumpsys-activity-和-am-stack-list"><a href="#dumpsys-activity-和-am-stack-list" class="headerlink" title="dumpsys activity 和 am stack list"></a>dumpsys activity 和 am stack list</h2><p>dumpsys activity 打印的 task visible的状态不是实时状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">topDisplayFocusedStack=Task&#123;9e67f80 #1000186 visible=false type=standard mode=fullscreen translucent=true A=1001000:com.chinatsp.vehicle U=10 StackId=1000186 sz=1&#125;</span><br></pre></td></tr></table></figure>
<p>对应源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  @Override</span><br><span class="line">  public void dump(PrintWriter pw, String prefix, boolean dumpAll) &#123;</span><br><span class="line">      super.dump(pw, prefix, dumpAll);</span><br><span class="line">      pw.print(prefix);</span><br><span class="line">//这里其实是获取到ActivityStack,调用的ActivityStack的toString（父类Task的toString）</span><br><span class="line">      pw.println(&quot;topDisplayFocusedStack=&quot; + getTopDisplayFocusedStack());</span><br><span class="line">      for (int i = getChildCount() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">          final DisplayContent display = getChildAt(i);</span><br><span class="line">          display.dump(pw, prefix, dumpAll);</span><br><span class="line">      &#125;</span><br><span class="line">      pw.println();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>来看Task的toString</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  String stringName;      // caching of toString() result.</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String toString() &#123;</span><br><span class="line">      StringBuilder sb = new StringBuilder(128);</span><br><span class="line">      if (stringName != null) &#123;</span><br><span class="line">	//后续调用toString都是缓存</span><br><span class="line">          sb.append(stringName);</span><br><span class="line">          sb.append(&quot; U=&quot;);</span><br><span class="line">          sb.append(mUserId);</span><br><span class="line">          sb.append(&quot; StackId=&quot;);</span><br><span class="line">          sb.append(getRootTaskId());</span><br><span class="line">          sb.append(&quot; sz=&quot;);</span><br><span class="line">          sb.append(getChildCount());</span><br><span class="line">          sb.append(&#x27;&#125;&#x27;);</span><br><span class="line">          return sb.toString();</span><br><span class="line">      &#125;</span><br><span class="line">//第一次生成 stringName</span><br><span class="line">      sb.append(&quot;Task&#123;&quot;);</span><br><span class="line">      sb.append(Integer.toHexString(System.identityHashCode(this)));</span><br><span class="line">      sb.append(&quot; #&quot;);</span><br><span class="line">      sb.append(mTaskId);</span><br><span class="line">      sb.append(&quot; visible=&quot; + shouldBeVisible(null /* starting */));</span><br><span class="line">      sb.append(&quot; type=&quot; + activityTypeToString(getActivityType()));</span><br><span class="line">      sb.append(&quot; mode=&quot; + windowingModeToString(getWindowingMode()));</span><br><span class="line">      sb.append(&quot; translucent=&quot; + isTranslucent(null /* starting */));</span><br><span class="line">      if (affinity != null) &#123;</span><br><span class="line">          sb.append(&quot; A=&quot;);</span><br><span class="line">          sb.append(affinity);</span><br><span class="line">      &#125; else if (intent != null &amp;&amp; intent.getComponent() != null) &#123;</span><br><span class="line">          sb.append(&quot; I=&quot;);</span><br><span class="line">          sb.append(intent.getComponent().flattenToShortString());</span><br><span class="line">      &#125; else if (affinityIntent != null &amp;&amp; affinityIntent.getComponent() != null) &#123;</span><br><span class="line">          sb.append(&quot; aI=&quot;);</span><br><span class="line">          sb.append(affinityIntent.getComponent().flattenToShortString());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          sb.append(&quot; ??&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      stringName = sb.toString();</span><br><span class="line">      return toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>am stack list获取的 task visiable 是实时的，因为每次都会调用shouldBeVisible来计算</p>
<h2 id="AOSP中查看版本号"><a href="#AOSP中查看版本号" class="headerlink" title="AOSP中查看版本号"></a>AOSP中查看版本号</h2><p>在<code>build/make/core/version_defaults.mk</code>中 PLATFORM_SDK_VERSION</p>
<h2 id="关于app的uid"><a href="#关于app的uid" class="headerlink" title="关于app的uid"></a>关于app的uid</h2><p>在System Server启动时，会在PKMS中进行APK的扫描，扫描完成后会去计算uid，uid是从10000开始，到19999结束，超出范围就会返回-1，<br>addForInitLI中有如下逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GuardedBy(&#123;&quot;mInstallLock&quot;, &quot;mLock&quot;&#125;)</span><br><span class="line">private AndroidPackage addForInitLI(ParsedPackage parsedPackage,</span><br><span class="line">        @ParseFlags int parseFlags, @ScanFlags int scanFlags, long currentTime,</span><br><span class="line">        @Nullable UserHandle user)</span><br><span class="line">                throws PackageManagerException &#123;</span><br><span class="line">    //......</span><br><span class="line">    if (scanResult.success) &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            boolean appIdCreated = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                final String pkgName = scanResult.pkgSetting.name;</span><br><span class="line">                final Map&lt;String, ReconciledPackage&gt; reconcileResult = reconcilePackagesLocked(</span><br><span class="line">                        new ReconcileRequest(</span><br><span class="line">                                Collections.singletonMap(pkgName, scanResult),</span><br><span class="line">                                mSharedLibraries,</span><br><span class="line">                                mPackages,</span><br><span class="line">                                Collections.singletonMap(</span><br><span class="line">                                        pkgName, getSettingsVersionForPackage(parsedPackage)),</span><br><span class="line">                                Collections.singletonMap(pkgName,</span><br><span class="line">                                        getSharedLibLatestVersionSetting(scanResult))),</span><br><span class="line">                        mSettings.mKeySetManagerService);</span><br><span class="line">                //这里去处理的appid（即uid）</span><br><span class="line">                appIdCreated = optimisticallyRegisterAppId(scanResult);</span><br><span class="line">                commitReconciledScanResultLocked(</span><br><span class="line">                        reconcileResult.get(pkgName), mUserManager.getUserIds());</span><br><span class="line">            &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">                if (appIdCreated) &#123;</span><br><span class="line">                    cleanUpAppIdCreation(scanResult);</span><br><span class="line">                &#125;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (shouldHideSystemApp) &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            mSettings.disableSystemPackageLPw(parsedPackage.getPackageName(), true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return scanResult.pkgSetting.pkg;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">private boolean optimisticallyRegisterAppId(@NonNull ScanResult result)</span><br><span class="line">        throws PackageManagerException &#123;</span><br><span class="line">    if (!result.existingSettingCopied) &#123;</span><br><span class="line">        // THROWS: when we can&#x27;t allocate a user id. add call to check if there&#x27;s</span><br><span class="line">        // enough space to ensure we won&#x27;t throw; otherwise, don&#x27;t modify state</span><br><span class="line">        return mSettings.registerAppIdLPw(result.pkgSetting);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;                          </span><br></pre></td></tr></table></figure>

<p>在Settings.java中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Registers a user ID with the system. Potentially allocates a new user ID.</span><br><span class="line"> * @return &#123;@code true&#125; if a new app ID was created in the process. &#123;@code false&#125; can be</span><br><span class="line"> *         returned in the case that a shared user ID already exists or the explicit app ID is</span><br><span class="line"> *         already registered.</span><br><span class="line"> * @throws PackageManagerException If a user ID could not be allocated.</span><br><span class="line"> */</span><br><span class="line">boolean registerAppIdLPw(PackageSetting p) throws PackageManagerException &#123;</span><br><span class="line">    final boolean createdNew;</span><br><span class="line">    if (p.appId == 0) &#123;</span><br><span class="line">        // Assign new user ID</span><br><span class="line">        p.appId = acquireAndRegisterNewAppIdLPw(p);</span><br><span class="line">        createdNew = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Add new setting to list of user IDs</span><br><span class="line">        createdNew = registerExistingAppIdLPw(p.appId, p, p.name);</span><br><span class="line">    &#125;</span><br><span class="line">    if (p.appId &lt; 0) &#123;</span><br><span class="line">        PackageManagerService.reportSettingsProblem(Log.WARN,</span><br><span class="line">                &quot;Package &quot; + p.name + &quot; could not be assigned a valid UID&quot;);</span><br><span class="line">        throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,</span><br><span class="line">                &quot;Package &quot; + p.name + &quot; could not be assigned a valid UID&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return createdNew;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="隐式"><a href="#隐式" class="headerlink" title="隐式"></a>隐式</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>window动画流程</title>
    <url>/2024/09/05/android_fw/113.window%E5%8A%A8%E7%94%BB%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>SurfaceAnimationRunner.java<br>在SurfaceAnimationRunner中startAnimation</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void startAnimation(AnimationSpec a, SurfaceControl animationLeash, Transaction t,</span><br><span class="line">        Runnable finishCallback) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        final RunningAnimation runningAnim = new RunningAnimation(a, animationLeash,</span><br><span class="line">                finishCallback);</span><br><span class="line">        mPendingAnimations.put(animationLeash, runningAnim);</span><br><span class="line">        if (!mAnimationStartDeferred) &#123;</span><br><span class="line">            mChoreographer.postFrameCallback(this::startAnimations);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Some animations (e.g. move animations) require the initial transform to be applied</span><br><span class="line">        // immediately.</span><br><span class="line">        applyTransformation(runningAnim, t, 0 /* currentPlayTime */);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行窗口切换时，会去调用AppTransitionController的handleAppTransitionReady</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void handleAppTransitionReady() &#123;</span><br><span class="line">    //......</span><br><span class="line">    final AppTransition appTransition = mDisplayContent.mAppTransition;</span><br><span class="line">    int transit = appTransition.getAppTransition();  </span><br><span class="line">    //......</span><br><span class="line">    //找到找到最上层应用窗口的布局参数。这些布局参数会影响动画的主题，决定动画的表现方式。</span><br><span class="line">    final ArraySet&lt;Integer&gt; activityTypes = collectActivityTypes(mDisplayContent.mOpeningApps,</span><br><span class="line">            mDisplayContent.mClosingApps, mDisplayContent.mChangingContainers);</span><br><span class="line">    final ActivityRecord animLpActivity = findAnimLayoutParamsToken(transit, activityTypes);</span><br><span class="line">    //......</span><br><span class="line">    overrideWithRemoteAnimationIfSet(animLpActivity, transit, activityTypes);</span><br><span class="line">    final int layoutRedo;</span><br><span class="line">    //给SurfaceAnimationRunner设置了一个flag，用来判断是否需要立即执行动画</span><br><span class="line">    mService.mSurfaceAnimationRunner.deferStartingAnimations();</span><br><span class="line">    try &#123;</span><br><span class="line">        applyAnimations(mDisplayContent.mOpeningApps, mDisplayContent.mClosingApps, transit,</span><br><span class="line">                animLp, voiceInteraction);</span><br><span class="line">        handleClosingApps();</span><br><span class="line">        handleOpeningApps();</span><br><span class="line">        handleChangingApps(transit);</span><br><span class="line"></span><br><span class="line">        appTransition.setLastAppTransition(transit, topOpeningApp,</span><br><span class="line">                topClosingApp, topChangingApp);</span><br><span class="line"></span><br><span class="line">        final int flags = appTransition.getTransitFlags();</span><br><span class="line">        layoutRedo = appTransition.goodToGo(transit, topOpeningApp,</span><br><span class="line">                mDisplayContent.mOpeningApps);</span><br><span class="line">        handleNonAppWindowsInTransition(transit, flags);</span><br><span class="line">        appTransition.postAnimationCallback();</span><br><span class="line">        appTransition.clear();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //清除之前设置的flag，如果有需要执行的动画会去执行</span><br><span class="line">        mService.mSurfaceAnimationRunner.continueStartingAnimations();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里是通知TaskSnapshotController去进行快照截取</span><br><span class="line">    mService.mTaskSnapshotController.onTransitionStarting(mDisplayContent);                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间这几个步骤:</p>
<ul>
<li>applyAnimations</li>
<li>handleClosingApps</li>
<li>handleChangingApps</li>
</ul>
<h2 id="AppTransitionController-applyAnimations"><a href="#AppTransitionController-applyAnimations" class="headerlink" title="AppTransitionController-applyAnimations"></a>AppTransitionController-applyAnimations</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void applyAnimations(ArraySet&lt;ActivityRecord&gt; openingApps,</span><br><span class="line">        ArraySet&lt;ActivityRecord&gt; closingApps, @TransitionType int transit,</span><br><span class="line">        LayoutParams animLp, boolean voiceInteraction) &#123;</span><br><span class="line">    if (transit == WindowManager.TRANSIT_UNSET</span><br><span class="line">            || (openingApps.isEmpty() &amp;&amp; closingApps.isEmpty())) &#123;</span><br><span class="line">        //没有过渡，或者没有要过渡的Activity直接就返回了</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //找到要打开的app对应的父容器</span><br><span class="line">    final ArraySet&lt;WindowContainer&gt; openingWcs = getAnimationTargets(</span><br><span class="line">            openingApps, closingApps, true /* visible */);</span><br><span class="line">    //找到要关闭的app对应的父容器</span><br><span class="line">    final ArraySet&lt;WindowContainer&gt; closingWcs = getAnimationTargets(</span><br><span class="line">            openingApps, closingApps, false /* visible */);</span><br><span class="line">    //针对父容器进行动画</span><br><span class="line">    applyAnimations(openingWcs, openingApps, transit, true /* visible */, animLp,</span><br><span class="line">            voiceInteraction);</span><br><span class="line">    applyAnimations(closingWcs, closingApps, transit, false /* visible */, animLp,</span><br><span class="line">            voiceInteraction);</span><br><span class="line">    </span><br><span class="line">    //通知无障碍服务</span><br><span class="line">    final AccessibilityController accessibilityController =</span><br><span class="line">            mDisplayContent.mWmService.mAccessibilityController;</span><br><span class="line">    if (accessibilityController != null) &#123;</span><br><span class="line">        accessibilityController.onAppWindowTransitionLocked(</span><br><span class="line">                mDisplayContent.getDisplayId(), transit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void applyAnimations(ArraySet&lt;WindowContainer&gt; wcs, ArraySet&lt;ActivityRecord&gt; apps,</span><br><span class="line">        @TransitionType int transit, boolean visible, LayoutParams animLp,</span><br><span class="line">        boolean voiceInteraction) &#123;</span><br><span class="line">    final int wcsCount = wcs.size();</span><br><span class="line">    for (int i = 0; i &lt; wcsCount; i++) &#123;</span><br><span class="line">        final WindowContainer wc = wcs.valueAt(i);</span><br><span class="line">        // If app transition animation target is promoted to higher level, SurfaceAnimator</span><br><span class="line">        // triggers WC#onAnimationFinished only on the promoted target. So we need to take care</span><br><span class="line">        // of triggering AR#onAnimationFinished on each ActivityRecord which is a part of the</span><br><span class="line">        // app transition.</span><br><span class="line">        //这里的逻辑是找到任务栈中的所有子窗口（ActivityRecord），保存起来，在动画结束时一起通知</span><br><span class="line">        final ArrayList&lt;ActivityRecord&gt; transitioningDescendants = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int j = 0; j &lt; apps.size(); ++j) &#123;</span><br><span class="line">            final ActivityRecord app = apps.valueAt(j);</span><br><span class="line">            if (app.isDescendantOf(wc)) &#123;</span><br><span class="line">                transitioningDescendants.add(app);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //针对任务栈进行动画,执行WindowContainer中的applyAnimation</span><br><span class="line">        wc.applyAnimation(animLp, transit, visible, voiceInteraction, transitioningDescendants);</span><br><span class="line">    &#125;                            </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>WindowContainer.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean applyAnimation(WindowManager.LayoutParams lp, int transit, boolean enter,</span><br><span class="line">        boolean isVoiceInteraction, @Nullable ArrayList&lt;WindowContainer&gt; sources) &#123;</span><br><span class="line">    if (mWmService.mDisableTransitionAnimation) &#123;</span><br><span class="line">        ProtoLog.v(WM_DEBUG_APP_TRANSITIONS_ANIM,</span><br><span class="line">                &quot;applyAnimation: transition animation is disabled or skipped. &quot;</span><br><span class="line">                        + &quot;container=%s&quot;, this);</span><br><span class="line">        cancelAnimation();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Only apply an animation if the display isn&#x27;t frozen. If it is frozen, there is no reason</span><br><span class="line">    // to animate and it can cause strange artifacts when we unfreeze the display if some</span><br><span class="line">    // different animation is running.</span><br><span class="line">    try &#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;WC#applyAnimation&quot;);</span><br><span class="line">        if (okToAnimate()) &#123;</span><br><span class="line">            applyAnimationUnchecked(lp, enter, transit, isVoiceInteraction, sources);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cancelAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return isAnimating();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void applyAnimationUnchecked(WindowManager.LayoutParams lp, boolean enter,</span><br><span class="line">        int transit, boolean isVoiceInteraction,</span><br><span class="line">        @Nullable ArrayList&lt;WindowContainer&gt; sources) &#123;</span><br><span class="line">    //调用 getAnimationAdapter 方法来获取两个 AnimationAdapter 对象，第一个用于主动画，第二个用于缩略图动画。</span><br><span class="line">    final Pair&lt;AnimationAdapter, AnimationAdapter&gt; adapters = getAnimationAdapter(lp,</span><br><span class="line">            transit, enter, isVoiceInteraction);</span><br><span class="line">    AnimationAdapter adapter = adapters.first;</span><br><span class="line">    AnimationAdapter thumbnailAdapter = adapters.second;</span><br><span class="line">    if (adapter != null) &#123;</span><br><span class="line">        if (sources != null) &#123;</span><br><span class="line">            mSurfaceAnimationSources.addAll(sources);</span><br><span class="line">        &#125;</span><br><span class="line">        startAnimation(getPendingTransaction(), adapter, !isVisible(),</span><br><span class="line">                ANIMATION_TYPE_APP_TRANSITION);</span><br><span class="line">        if (adapter.getShowWallpaper()) &#123;</span><br><span class="line">            getDisplayContent().pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">        &#125;</span><br><span class="line">        if (thumbnailAdapter != null) &#123;</span><br><span class="line">            mSurfaceFreezer.mSnapshot.startAnimation(getPendingTransaction(),</span><br><span class="line">                    thumbnailAdapter, ANIMATION_TYPE_APP_TRANSITION, (type, anim) -&gt; &#123; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">void startAnimation(Transaction t, AnimationAdapter anim, boolean hidden,</span><br><span class="line">        @AnimationType int type) &#123;</span><br><span class="line">    startAnimation(t, anim, hidden, type, null /* animationFinishedCallback */);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void startAnimation(Transaction t, AnimationAdapter anim, boolean hidden,</span><br><span class="line">        @AnimationType int type,</span><br><span class="line">        @Nullable OnAnimationFinishedCallback animationFinishedCallback) &#123;</span><br><span class="line">    if (DEBUG_ANIM) &#123;</span><br><span class="line">        Slog.v(TAG, &quot;Starting animation on &quot; + this + &quot;: type=&quot; + type + &quot;, anim=&quot; + anim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // TODO: This should use isVisible() but because isVisible has a really weird meaning at</span><br><span class="line">    // the moment this doesn&#x27;t work for all animatable window containers.</span><br><span class="line">    //将动画的执行交给SurfaceAnimator</span><br><span class="line">    mSurfaceAnimator.startAnimation(t, anim, hidden, type, animationFinishedCallback,</span><br><span class="line">            mSurfaceFreezer);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">//在WC的构造方法中初始化了SurfaceAnimator</span><br><span class="line">WindowContainer(WindowManagerService wms) &#123;</span><br><span class="line">    mWmService = wms;</span><br><span class="line">    mPendingTransaction = wms.mTransactionFactory.get();</span><br><span class="line">    mBLASTSyncTransaction = wms.mTransactionFactory.get();</span><br><span class="line">    //初始化SurfaceAnimator，定义了动画结束时的回调</span><br><span class="line">    mSurfaceAnimator = new SurfaceAnimator(this, this::onAnimationFinished, wms);</span><br><span class="line">    mSurfaceFreezer = new SurfaceFreezer(this, wms);</span><br><span class="line">&#125;     </span><br><span class="line">/**</span><br><span class="line"> * Called when an animation has finished running.</span><br><span class="line"> */</span><br><span class="line">protected void onAnimationFinished(@AnimationType int type, AnimationAdapter anim) &#123;</span><br><span class="line">    //触发之前保存的ActivityRecord的回调</span><br><span class="line">    doAnimationFinished(type, anim);</span><br><span class="line">    mWmService.onAnimationFinished();</span><br><span class="line">    mNeedsZBoost = false;</span><br><span class="line">&#125;  </span><br><span class="line">private void doAnimationFinished(@AnimationType int type, AnimationAdapter anim) &#123;</span><br><span class="line">    for (int i = 0; i &lt; mSurfaceAnimationSources.size(); ++i) &#123;</span><br><span class="line">        mSurfaceAnimationSources.valueAt(i).onAnimationFinished(type, anim);</span><br><span class="line">    &#125;</span><br><span class="line">    mSurfaceAnimationSources.clear();</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>
<p>所以WindowContainer中的动画是交给SurfaceAnimator去处理的<br>SurfaceAnimator.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void startAnimation(Transaction t, AnimationAdapter anim, boolean hidden,</span><br><span class="line">        @AnimationType int type,</span><br><span class="line">        @Nullable OnAnimationFinishedCallback animationFinishedCallback,</span><br><span class="line">        @Nullable SurfaceFreezer freezer) &#123;</span><br><span class="line">    cancelAnimation(t, true /* restarting */, true /* forwardCancel */);</span><br><span class="line">    mAnimation = anim;</span><br><span class="line">    mAnimationType = type;</span><br><span class="line">    mAnimationFinishedCallback = animationFinishedCallback;</span><br><span class="line">    //获取到对应的SurfaceControl</span><br><span class="line">    final SurfaceControl surface = mAnimatable.getSurfaceControl();</span><br><span class="line">    if (surface == null) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Unable to start animation, surface is null or no children.&quot;);</span><br><span class="line">        cancelAnimation();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //这里的mLeash也是一个SurfaceControl</span><br><span class="line">    mLeash = freezer != null ? freezer.takeLeashForAnimation() : null;</span><br><span class="line">    if (mLeash == null) &#123;</span><br><span class="line">        //没有就创建一个leash，用来包裹WindowContainer的SurfaceContainer</span><br><span class="line">        //也就是会创建一个leash放在task和其父容器DefaultTaskDisplayArea中间</span><br><span class="line">        mLeash = createAnimationLeash(mAnimatable, surface, t, type,</span><br><span class="line">                mAnimatable.getSurfaceWidth(), mAnimatable.getSurfaceHeight(), 0 /* x */,</span><br><span class="line">                0 /* y */, hidden, mService.mTransactionFactory);</span><br><span class="line">        //这里会去刷新layer</span><br><span class="line">        mAnimatable.onAnimationLeashCreated(t, mLeash);</span><br><span class="line">    &#125;</span><br><span class="line">    mAnimatable.onLeashAnimationStarting(t, mLeash);</span><br><span class="line">    if (mAnimationStartDelayed) &#123;</span><br><span class="line">        if (DEBUG_ANIM) Slog.i(TAG, &quot;Animation start delayed&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //将动画的处理交给AnimationAdapter</span><br><span class="line">    mAnimation.startAnimation(mLeash, t, type, mInnerAnimationFinishedCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static SurfaceControl createAnimationLeash(Animatable animatable, SurfaceControl surface,</span><br><span class="line">        Transaction t, @AnimationType int type, int width, int height, int x, int y,</span><br><span class="line">        boolean hidden, Supplier&lt;Transaction&gt; transactionFactory) &#123;</span><br><span class="line">    if (DEBUG_ANIM) Slog.i(TAG, &quot;Reparenting to leash&quot;);</span><br><span class="line">    //animatable.makeAnimationLeash实际上是创建了一个SurfaceControl.Builder，标记为ContainerLayer</span><br><span class="line">    //将WindowContainer的parent的SurfaceControl设置为自己的parent</span><br><span class="line">    final SurfaceControl.Builder builder = animatable.makeAnimationLeash()</span><br><span class="line">            .setParent(animatable.getAnimationLeashParent())</span><br><span class="line">            .setName(surface + &quot; - animation-leash&quot;)</span><br><span class="line">            // TODO(b/151665759) Defer reparent calls</span><br><span class="line">            // We want the leash to be visible immediately because the transaction which shows</span><br><span class="line">            // the leash may be deferred but the reparent will not. This will cause the leashed</span><br><span class="line">            // surface to be invisible until the deferred transaction is applied. If this</span><br><span class="line">            // doesn&#x27;t work, you will can see the 2/3 button nav bar flicker during seamless</span><br><span class="line">            // rotation.</span><br><span class="line">            .setHidden(hidden)</span><br><span class="line">            .setEffectLayer()</span><br><span class="line">            .setCallsite(&quot;SurfaceAnimator.createAnimationLeash&quot;);</span><br><span class="line">    final SurfaceControl leash = builder.build();</span><br><span class="line">    t.setWindowCrop(leash, width, height);</span><br><span class="line">    t.setPosition(leash, x, y);</span><br><span class="line">    t.show(leash);</span><br><span class="line">    t.setAlpha(leash, hidden ? 0 : 1);</span><br><span class="line"></span><br><span class="line">    //将WindowContainer的SurfaceControl放在leash中</span><br><span class="line">    t.reparent(surface, leash);</span><br><span class="line">    return leash;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>在SurfaceAnimator中发现，又把动画的处理交给了AnimationAdapter，这个是从WindowContainer的applyAnimationUnchecked中传递过来的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair&lt;AnimationAdapter, AnimationAdapter&gt; getAnimationAdapter(WindowManager.LayoutParams lp,</span><br><span class="line">        int transit, boolean enter, boolean isVoiceInteraction) &#123;</span><br><span class="line">    final Pair&lt;AnimationAdapter, AnimationAdapter&gt; resultAdapters;</span><br><span class="line">    final int appStackClipMode = getDisplayContent().mAppTransition.getAppStackClipMode();</span><br><span class="line"></span><br><span class="line">    // Separate position and size for use in animators.</span><br><span class="line">    final Rect screenBounds = getAnimationBounds(appStackClipMode);</span><br><span class="line">    mTmpRect.set(screenBounds);</span><br><span class="line">    getAnimationPosition(mTmpPoint);</span><br><span class="line">    if (!sHierarchicalAnimations) &#123;</span><br><span class="line">        // Non-hierarchical animation uses position in global coordinates.</span><br><span class="line">        mTmpPoint.set(mTmpRect.left, mTmpRect.top);</span><br><span class="line">    &#125;</span><br><span class="line">    mTmpRect.offsetTo(0, 0);</span><br><span class="line"></span><br><span class="line">    //这里是判断是否有远程动画控制器（如果存在就不去加载app自己的配置了）</span><br><span class="line">    final RemoteAnimationController controller =</span><br><span class="line">            getDisplayContent().mAppTransition.getRemoteAnimationController();</span><br><span class="line">    final boolean isChanging = AppTransition.isChangeTransit(transit) &amp;&amp; enter</span><br><span class="line">            &amp;&amp; isChangingAppTransition();</span><br><span class="line"></span><br><span class="line">    // Delaying animation start isn&#x27;t compatible with remote animations at all.</span><br><span class="line">    if (controller != null &amp;&amp; !mSurfaceAnimator.isAnimationStartDelayed()) &#123;</span><br><span class="line">        final Rect localBounds = new Rect(mTmpRect);</span><br><span class="line">        localBounds.offsetTo(mTmpPoint.x, mTmpPoint.y);</span><br><span class="line">        final RemoteAnimationController.RemoteAnimationRecord adapters =</span><br><span class="line">                controller.createRemoteAnimationRecord(this, mTmpPoint, localBounds,</span><br><span class="line">                        screenBounds, (isChanging ? mSurfaceFreezer.mFreezeBounds : null));</span><br><span class="line">        resultAdapters = new Pair&lt;&gt;(adapters.mAdapter, adapters.mThumbnailAdapter);</span><br><span class="line">    &#125; else if (isChanging) &#123;</span><br><span class="line">        final float durationScale = mWmService.getTransitionAnimationScaleLocked();</span><br><span class="line">        final DisplayInfo displayInfo = getDisplayContent().getDisplayInfo();</span><br><span class="line">        mTmpRect.offsetTo(mTmpPoint.x, mTmpPoint.y);</span><br><span class="line"></span><br><span class="line">        final AnimationAdapter adapter = new LocalAnimationAdapter(</span><br><span class="line">                new WindowChangeAnimationSpec(mSurfaceFreezer.mFreezeBounds, mTmpRect,</span><br><span class="line">                        displayInfo, durationScale, true /* isAppAnimation */,</span><br><span class="line">                        false /* isThumbnail */),</span><br><span class="line">                getSurfaceAnimationRunner());</span><br><span class="line"></span><br><span class="line">        final AnimationAdapter thumbnailAdapter = mSurfaceFreezer.mSnapshot != null</span><br><span class="line">                ? new LocalAnimationAdapter(new WindowChangeAnimationSpec(</span><br><span class="line">                mSurfaceFreezer.mFreezeBounds, mTmpRect, displayInfo, durationScale,</span><br><span class="line">                true /* isAppAnimation */, true /* isThumbnail */), getSurfaceAnimationRunner())</span><br><span class="line">                : null;</span><br><span class="line">        resultAdapters = new Pair&lt;&gt;(adapter, thumbnailAdapter);</span><br><span class="line">        mTransit = transit;</span><br><span class="line">        mTransitFlags = getDisplayContent().mAppTransition.getTransitFlags();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mNeedsAnimationBoundsLayer = (appStackClipMode == STACK_CLIP_AFTER_ANIM);</span><br><span class="line">        //去加载动画</span><br><span class="line">        final Animation a = loadAnimation(lp, transit, enter, isVoiceInteraction);</span><br><span class="line"></span><br><span class="line">        if (a != null) &#123;</span><br><span class="line">            // Only apply corner radius to animation if we&#x27;re not in multi window mode.</span><br><span class="line">            // We don&#x27;t want rounded corners when in pip or split screen.</span><br><span class="line">            final float windowCornerRadius = !inMultiWindowMode()</span><br><span class="line">                    ? getDisplayContent().getWindowCornerRadius()</span><br><span class="line">                    : 0;</span><br><span class="line">            //创建一个LocalAnimationAdapter来处理动画</span><br><span class="line">            AnimationAdapter adapter = new LocalAnimationAdapter(</span><br><span class="line">                    new WindowAnimationSpec(a, mTmpPoint, mTmpRect,</span><br><span class="line">                            getDisplayContent().mAppTransition.canSkipFirstFrame(),</span><br><span class="line">                            appStackClipMode, true /* isAppAnimation */, windowCornerRadius),</span><br><span class="line">                    getSurfaceAnimationRunner());</span><br><span class="line"></span><br><span class="line">            resultAdapters = new Pair&lt;&gt;(adapter, null);</span><br><span class="line">            mNeedsZBoost = a.getZAdjustment() == Animation.ZORDER_TOP</span><br><span class="line">                    || AppTransition.isClosingTransit(transit);</span><br><span class="line">            mTransit = transit;</span><br><span class="line">            mTransitFlags = getDisplayContent().mAppTransition.getTransitFlags();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            resultAdapters = new Pair&lt;&gt;(null, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return resultAdapters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final SurfaceAnimationRunner getSurfaceAnimationRunner() &#123;</span><br><span class="line">    //取到WMS中的SurfaceAnimationRunner</span><br><span class="line">    return mWmService.mSurfaceAnimationRunner;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">private Animation loadAnimation(WindowManager.LayoutParams lp, int transit, boolean enter,</span><br><span class="line">                                boolean isVoiceInteraction) &#123;</span><br><span class="line">    //......</span><br><span class="line">    final Configuration displayConfig = displayContent.getConfiguration();</span><br><span class="line">    //通过DisplayContent的AppTransition去加载动画</span><br><span class="line">    final Animation a = getDisplayContent().mAppTransition.loadAnimation(lp, transit, enter,</span><br><span class="line">            displayConfig.uiMode, displayConfig.orientation, frame, displayFrame, insets,</span><br><span class="line">            surfaceInsets, stableInsets, isVoiceInteraction, inFreeformWindowingMode(), this);</span><br><span class="line">    //......        </span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>在SurfaceAnimator中，调用AnimationAdapter.startAnimation来处理动画，这里的AnimationAdapter是一个LocalAnimationAdapter<br>LocalAnimationAdapter.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalAnimationAdapter(AnimationSpec spec, SurfaceAnimationRunner animator) &#123;</span><br><span class="line">    mSpec = spec;</span><br><span class="line">    mAnimator = animator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void startAnimation(SurfaceControl animationLeash, Transaction t,</span><br><span class="line">        @AnimationType int type, OnAnimationFinishedCallback finishCallback) &#123;</span><br><span class="line">    //调用SurfaceAnimationRunner去处理动画，这里的SurfaceAnimationRunner是WMS中的SurfaceAnimationRunner</span><br><span class="line">    mAnimator.startAnimation(mSpec, animationLeash, t,</span><br><span class="line">            () -&gt; finishCallback.onAnimationFinished(type, this));</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>继续看SurfaceAnimationRunner中的动画处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void startAnimation(AnimationSpec a, SurfaceControl animationLeash, Transaction t,</span><br><span class="line">        Runnable finishCallback) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        final RunningAnimation runningAnim = new RunningAnimation(a, animationLeash,</span><br><span class="line">                finishCallback);</span><br><span class="line">        mPendingAnimations.put(animationLeash, runningAnim);</span><br><span class="line">        if (!mAnimationStartDeferred) &#123;</span><br><span class="line">            mChoreographer.postFrameCallback(this::startAnimations);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Some animations (e.g. move animations) require the initial transform to be applied</span><br><span class="line">        // immediately.</span><br><span class="line">        //应用动画的初始状态</span><br><span class="line">        applyTransformation(runningAnim, t, 0 /* currentPlayTime */);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void applyTransformation(RunningAnimation a, Transaction t, long currentPlayTime) &#123;</span><br><span class="line">    //调用WindowAnimationSpec的apply</span><br><span class="line">    a.mAnimSpec.apply(t, a.mLeash, currentPlayTime);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>WindowAnimationSpec.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void apply(Transaction t, SurfaceControl leash, long currentPlayTime) &#123;</span><br><span class="line">    final TmpValues tmp = mThreadLocalTmps.get();</span><br><span class="line">    tmp.transformation.clear();</span><br><span class="line">    //根据当前动画时间，计算对应的矩阵</span><br><span class="line">    mAnimation.getTransformation(currentPlayTime, tmp.transformation);</span><br><span class="line">    tmp.transformation.getMatrix().postTranslate(mPosition.x, mPosition.y);</span><br><span class="line">    //对leash进行矩阵变化</span><br><span class="line">    t.setMatrix(leash, tmp.transformation.getMatrix(), tmp.floats);</span><br><span class="line">    t.setAlpha(leash, tmp.transformation.getAlpha());</span><br><span class="line"></span><br><span class="line">    boolean cropSet = false;</span><br><span class="line">    if (mStackClipMode == STACK_CLIP_NONE) &#123;</span><br><span class="line">        if (tmp.transformation.hasClipRect()) &#123;</span><br><span class="line">            t.setWindowCrop(leash, tmp.transformation.getClipRect());</span><br><span class="line">            cropSet = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mTmpRect.set(mStackBounds);</span><br><span class="line">        if (tmp.transformation.hasClipRect()) &#123;</span><br><span class="line">            mTmpRect.intersect(tmp.transformation.getClipRect());</span><br><span class="line">        &#125;</span><br><span class="line">        t.setWindowCrop(leash, mTmpRect);</span><br><span class="line">        cropSet = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We can only apply rounded corner if a crop is set, as otherwise the value is meaningless,</span><br><span class="line">    // since it doesn&#x27;t have anything it&#x27;s relative to.</span><br><span class="line">    if (cropSet &amp;&amp; mAnimation.hasRoundedCorners() &amp;&amp; mWindowCornerRadius &gt; 0) &#123;</span><br><span class="line">        t.setCornerRadius(leash, mWindowCornerRadius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="AnimationLeash"><a href="#AnimationLeash" class="headerlink" title="AnimationLeash"></a>AnimationLeash</h2><p>AnimationLeash 是一种用于管理动画的虚拟 SurfaceControl。<br>它并不是一个真正的surface，而是一个用来“捆绑”目标surface的辅助层。通过这种方式，可以在动画过程中对目标表面的显示进行精确控制。</p>
<p>AnimationLeash 用于将目标表面和动画效果分开管理。在动画开始时，目标表面被附加到 AnimationLeash 上，这样可以在不影响原始表面的情况下对其进行动画处理</p>
]]></content>
  </entry>
  <entry>
    <title>Android_SELinux</title>
    <url>//pages/71b18a/</url>
    <content><![CDATA[<p>SELinux: Security-Enhanced Linux</p>
<h2 id="安全上下文格式"><a href="#安全上下文格式" class="headerlink" title="安全上下文格式"></a>安全上下文格式</h2><p>Security Context 安全上下文 格式：user:role:type:sensitivity[:categories]</p>
<p>在Android中，通常可以忽略user、role、sensitivity这几个字段，因为Android并没有启用SELinux提供的所有功能</p>
<p>Android中的Security Context：</p>
<ol>
<li>user只定义了一个<code>u</code>,必要时，系统会通过categories字段来表示实际用户</li>
<li>role只定义了2个：<code>r</code>来表示subjects(主体，如某个进程、服务)，<code>object_r</code>来表示objects（客体，如某个文件）</li>
<li>没有使用sensitivity，始终都是默认值<code>s0</code></li>
<li>categories配合sensitivity会出现多级安全权限问题MLS,</li>
</ol>
<h2 id="关键文件"><a href="#关键文件" class="headerlink" title="关键文件"></a>关键文件</h2><h3 id="Policy-file"><a href="#Policy-file" class="headerlink" title="Policy file"></a>Policy file</h3><p><code>*.te</code>文件时SELinux策略源文件，定义了domain和标签</p>
<h3 id="Context-files"><a href="#Context-files" class="headerlink" title="Context files"></a>Context files</h3><p>上下文文件是为对象（客体）指定标签的文件，主要有以下几个</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>一般用途</th>
</tr>
</thead>
<tbody><tr>
<td>file_contexts</td>
<td>为文件分配安全上下文</td>
</tr>
<tr>
<td>service_contexts</td>
<td>用于为 Android Binder 服务分配标签，以便控制哪些进程可以为相应服务添加（注册）和查找（查询）Binder 引用。在启动期间，<code>servicemanager</code> 进程会读取此配置</td>
</tr>
<tr>
<td>seapp_contexts</td>
<td>用于为应用进程和 其对应<code>/data/data</code> 目录分配标签。在每次应用启动时，<code>zygote</code> 进程都会读取此配置；在启动期间，<code>installd</code> 会读取此配置</td>
</tr>
<tr>
<td>property_contexts</td>
<td>用于为 Android 系统属性分配标签，以便控制哪些进程可以设置这些属性。在启动期间，<code>init</code> 进程会读取此配置</td>
</tr>
<tr>
<td>genfs_contexts</td>
<td>用于为不支持扩展属性的文件系统（例如，<code>proc</code> 或 <code>vfat</code>）分配标签</td>
</tr>
<tr>
<td>mac_permissions.xml</td>
<td>用于根据应用签名和应用软件包名称（后者可选）为应用分配 <code>seinfo</code> 标记。随后，分配的 <code>seinfo</code> 标记可在 <code>seapp_contexts</code> 文件中用作密钥，以便为带有该 <code>seinfo</code> 标记的所有应用分配特定标签。在启动期间，<code>system_server</code> 会读取此配置</td>
</tr>
</tbody></table>
<h2 id="SELinux-policy"><a href="#SELinux-policy" class="headerlink" title="SELinux policy"></a>SELinux policy</h2><p>官网对不同目录的sepolicy的解释 <a href="https://source.android.google.cn/docs/security/features/selinux/build?hl=zh-cn">https://source.android.google.cn/docs/security/features/selinux/build?hl=zh-cn</a></p>
<p>Android8.0 之后，SELinux policy分成了platform和vendor 两个部分，允许独立更新</p>
<p>platform sepolicy被进一步拆成了platform private和 platform public两个部分，来 暴露指定的类型和属性给vendor策略编写者。所以只有定义在public中的type和attribute才能在vendor中直接使用</p>
<h3 id="Platform-public-sepolicy"><a href="#Platform-public-sepolicy" class="headerlink" title="Platform public sepolicy"></a>Platform public sepolicy</h3><p>平台公共策略文件，路径<code> system/sepolicy/public</code>，这部分是用来导出对vendor可见的</p>
<p>其中<code>PLATFORM_SEPOLICY_VERSION</code>定义了vendor可见的版本，这个宏定义可以在<code>build/make/core/config.mk</code>中找到</p>
<h3 id="Platform-private-sepolicy"><a href="#Platform-private-sepolicy" class="headerlink" title="Platform private sepolicy"></a>Platform private sepolicy</h3><p>平台私有策略文件，路径<code> /system/sepolicy/private</code>,这部分vendor不可见</p>
<p>Android11开始又增加了system_ext policy 和 product policy，system_ext和product策略也区分公共策略和私有策略。</p>
<p>原生AOSP有以下几个目录：</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>system&#x2F;sepolicy&#x2F;public</td>
<td>平台公共策略一般是定义的一些type和attribute，对外可见</td>
</tr>
<tr>
<td>system&#x2F;sepolicy&#x2F;private</td>
<td>平台实现的具体策略，外部不可见</td>
</tr>
<tr>
<td>system&#x2F;sepolicy&#x2F;vendor</td>
<td>供应商可以使用的政策和上下文文件</td>
</tr>
</tbody></table>
<p>另外还有一些定义的宏，编译时，会去找这些宏定义的目录下的策略文件：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>BOARD_SEPOLICY_DIRS</td>
<td>供应商的 sepolicy目录，但是在sepolicy的Android.mk中看到这个已经被废弃了，实际是用的BOARD_VENDOR_SEPOLICY_DIRS</td>
</tr>
<tr>
<td>BOARD_ODM_SEPOLICY_DIRS</td>
<td>Odm sepolicy</td>
</tr>
<tr>
<td>SYSTEM_EXT_PUBLIC_SEPOLICY_DIR</td>
<td>System_ext公共策略，对vendor可见 （Android11之前用的是BOARD_PLAT_PUBLIC_SEPOLICY_DIR）</td>
</tr>
<tr>
<td>SYSTEM_EXT_PRIVATE_SEPOLICY_DIRS</td>
<td>System_ext 实现的具体策略，对外不可见（Android11之前用的BOARD_PLAT_PRIVATE_SEPOLICY_DIR）</td>
</tr>
<tr>
<td>PRODUCT_PUBLIC_SEPOLICY_DIRS</td>
<td>Product公共策略，对vendor可见</td>
</tr>
<tr>
<td>PRODUCT_PRIVATE_SEPOLICY_DIRS</td>
<td>Product实现的具体策略，外部不可见</td>
</tr>
</tbody></table>
<p>变量的定义可以在AOSP的system&#x2F;sepolicy&#x2F;Android.mk中找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLAT_PUBLIC_POLICY := $(LOCAL_PATH)/public</span><br><span class="line">PLAT_PRIVATE_POLICY := $(LOCAL_PATH)/private</span><br><span class="line">PLAT_VENDOR_POLICY := $(LOCAL_PATH)/vendor</span><br><span class="line">REQD_MASK_POLICY := $(LOCAL_PATH)/reqd_mask</span><br><span class="line">SYSTEM_EXT_PUBLIC_POLICY := $(BOARD_PLAT_PUBLIC_SEPOLICY_DIR)</span><br><span class="line">SYSTEM_EXT_PRIVATE_POLICY := $(BOARD_PLAT_PRIVATE_SEPOLICY_DIR)</span><br><span class="line">PRODUCT_PUBLIC_POLICY := $(PRODUCT_PUBLIC_SEPOLICY_DIRS)</span><br><span class="line">PRODUCT_PRIVATE_POLICY := $(PRODUCT_PRIVATE_SEPOLICY_DIRS)</span><br></pre></td></tr></table></figure>


<p>构建系统会采用以上定义的policy，在对应的分区system、system_ext、product、vendor、odm下生成对应的策略组件</p>
<ol>
<li><p>将策略转换为 SELinux 通用中间语言(Common Intermediate Language) (CIL) 格式，具体如下</p>
<p>a. 公共平台策略（包含system、system_ext、product）</p>
<p>b. 私有 + 公共组合</p>
<p>c. 公共+ vendor and <code>BOARD_SEPOLICY_DIRS</code> policy</p>
</li>
</ol>
<h2 id="type、attribute访问权限"><a href="#type、attribute访问权限" class="headerlink" title="type、attribute访问权限"></a>type、attribute访问权限</h2><p>本地验证发现：</p>
<ol>
<li>平台的公共部分，system_ext、vendor、product中都可以引用到</li>
<li>在product定义的public部分，system_ext访问不到，vendor可以访问。（如 在 product中定义的carservice_app，system_ext访问不到，但是vendor可以访问）</li>
<li>在system_ext定义的public部分，product和vendor都可以访问</li>
<li>system中的只能访问system中的定义的</li>
</ol>
<h2 id="在system中新增type和attribute的兼容性处理"><a href="#在system中新增type和attribute的兼容性处理" class="headerlink" title="在system中新增type和attribute的兼容性处理"></a>在system中新增type和attribute的兼容性处理</h2><p>修改system&#x2F;sepolicy&#x2F;public或system&#x2F;sepolicy&#x2F;private下的策略时，会出现兼容性问题，编译会报 sepolicy_freeze_test，因为selinux权限有校验，修改后的文件会和预编译目录&#x2F;system&#x2F;sepolicy&#x2F;prebuilts&#x2F;api&#x2F;30.0&#x2F;下的文件进行比较，文件内容不同，校验不通过，所以需要将&#x2F;system&#x2F;sepolicy&#x2F;private和&#x2F;system&#x2F;sepolicy&#x2F;public修改过的地方，同步在&#x2F;system&#x2F;sepolicy&#x2F;prebuilts&#x2F;api&#x2F;30.0&#x2F;对应文件中进行修改。</p>
<p>另外如果在system&#x2F;sepolicy&#x2F;public或system&#x2F;sepolicy&#x2F;private中新增了type或attribute，还需要对新增的进行忽略，编译才能通过：</p>
<p>在&#x2F;system&#x2F;sepolicy&#x2F;private&#x2F;compat 目录下，找到最新的api目录，修改其中的ignore.cil，将新增的type加入到new_objects，不做兼容性校验。记得同步更新prebuilts&#x2F;api&#x2F;30.0&#x2F;private&#x2F;compat下对应文件。</p>
<h2 id="SELinux例子–rc自启bin文件"><a href="#SELinux例子–rc自启bin文件" class="headerlink" title="SELinux例子–rc自启bin文件"></a>SELinux例子–rc自启bin文件</h2><ol>
<li><p>先定义一个进程的type，和二进制文件的type</p>
<p>fdb_native_server.te</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 声明一个fdb_native_server的类型，它和domain、coredomain2个属性相关联</span><br><span class="line">type fdb_native_server, domain, coredomain;</span><br><span class="line"># 声明一个fdb_native_server_exec的类型，它和exec_type, file_type这些属性相关联，</span><br><span class="line">type fdb_native_server_exec, exec_type, file_type, system_file_type;</span><br><span class="line"># system目录下的文件需要指定system_file_type属性，不然编译不过</span><br><span class="line"># 可以通过typeattribute关键字，给已经定义的type继续关联属性: typeattribute type attribute</span><br><span class="line">typeattribute fdb_native_server_exec system_file_type;</span><br><span class="line"></span><br><span class="line"># 初始化相关权限，从init进程转换到对应类型的权限</span><br><span class="line"># 允许init去执行对应的_exec，并将其转换成对应的domain</span><br><span class="line"># 会去找 对应的_exec，没有定义对应的_exec会编译失败</span><br><span class="line"># 这里会添加进程selinux标签转换程fdb_native_server标签的权限</span><br><span class="line">init_daemon_domain(fdb_native_server)</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define(`init_daemon_domain&#x27;, `</span><br><span class="line">domain_auto_trans(init, $1_exec, $1)</span><br><span class="line">&#x27;)</span><br><span class="line"></span><br><span class="line">define(`domain_auto_trans&#x27;, `</span><br><span class="line"># Allow the necessary permissions.</span><br><span class="line">domain_trans($1,$2,$3)</span><br><span class="line"># Make the transition occur by default.</span><br><span class="line">type_transition $1 $2:process $3;</span><br><span class="line">&#x27;)</span><br><span class="line"></span><br><span class="line">define(`domain_trans&#x27;, `</span><br><span class="line"># Old domain may exec the file and transition to the new domain.</span><br><span class="line">allow $1 $2:file &#123; getattr open read execute map &#125;;</span><br><span class="line">allow $1 $3:process transition;</span><br><span class="line"># New domain is entered by executing the file.</span><br><span class="line">allow $3 $2:file &#123; entrypoint open read execute getattr map &#125;;</span><br><span class="line"># New domain can send SIGCHLD to its caller.</span><br><span class="line">ifelse($1, `init&#x27;, `&#x27;, `allow $3 $1:process sigchld;&#x27;)</span><br><span class="line"># Enable AT_SECURE, i.e. libc secure mode.</span><br><span class="line">dontaudit $1 $3:process noatsecure;</span><br><span class="line"># XXX dontaudit candidate but requires further study.</span><br><span class="line">allow $1 $3:process &#123; siginh rlimitinh &#125;;</span><br><span class="line">&#x27;)</span><br></pre></td></tr></table></figure>


<p>cannot setexeccon(‘u:r:test_fdb:s0’) for nativefdbserver: Invalid argument<br>   test_fdb不是一个domain，查看是否有定义<br>init    : type&#x3D;1400 audit(0.0:23): avc: denied { entrypoint } for path&#x3D;”&#x2F;system&#x2F;bin&#x2F;NativeFdbServerTest” dev&#x3D;”vda” ino&#x3D;322561 scontext&#x3D;u:r:test_fdb:s0 tcontext&#x3D;u:object_r:system_file:s0 tclass&#x3D;file permissive&#x3D;0<br>   无法正常执行这个程序，将init标签转成指定的domain后，无法执行system_file的bin文件，需要将对应的文件标记为之前定义好的_exec</p>
<p>The following types on &#x2F;system&#x2F; must be associated with the “system_file_type” attribute: test_fdb_exec<br>   &#x2F;system&#x2F;下面的文件对应的标签需要添加system_file_type属性</p>
<p>The following domain(s) must be associated with the “coredomain” attribute because they are executed off of &#x2F;system:<br>   &#x2F;system分区下运行的进程对应的标签需要加上coredomain属性</p>
<p>所以一个最基础的进程的selinxu标签定义,以 test_app为例：<br>在public&#x2F;test_app.te中定义类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type test_app, domain, coredomain;</span><br><span class="line">type test_app_exec, exec_type, file_type, system_file_type;</span><br></pre></td></tr></table></figure>
<p>在private&#x2F;test_app.te中初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init_daemon_domain(test_app)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>指定要自启的二进制文件的 安全上下文</p>
<p>file_contexts</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将/system/bin/fdb_native_server这个文件 上下文 指定为 定义好的 fdb_native_server_exec</span><br><span class="line">/system/bin/fdb_native_server   u:object_r:fdb_native_server_exec:s0</span><br></pre></td></tr></table></figure>


</li>
<li><p>在rc文件中自启</p>
<p>在rc文件中自启fdb_native_server</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service fdb_native_server /system/bin/fdb_native_server</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br><span class="line">    # 指定服务启动时使用的上下文，不指定的话是bin文件对应的domain（去掉_exec）</span><br><span class="line">    seclabel u:r:fdb_native_server:s0</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="seapp-contexts"><a href="#seapp-contexts" class="headerlink" title="seapp_contexts"></a>seapp_contexts</h2><p>seapp_contexts的文档可以看AOSP中的注释：<a href="http://aospxref.com/android-11.0.0_r21/xref/system/sepolicy/private/seapp_contexts">http://aospxref.com/android-11.0.0_r21/xref/system/sepolicy/private/seapp_contexts</a></p>
<p>seapp_contexts定义了确定app安全上下文的规则。</p>
<p>每个条目都列出了用于匹配应用程序的输入 和 输出，用于确定匹配应用程序的安全上下文</p>
<p>即 条件1&amp;&amp;条件2&amp;&amp;条件3 … 结果1 结果2…,例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># user=system 并且 seinfo=platform， 这个APP的domain是system_app,APP的data数据上下文类型为system_app_data_file</span><br><span class="line">user=system seinfo=platform domain=system_app type=system_app_data_file</span><br></pre></td></tr></table></figure>

<p>可以匹配的输入有以下几类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Input selectors:</span><br><span class="line">#       isSystemServer (boolean)	是否是systemserver</span><br><span class="line">#       isEphemeralApp (boolean)	是否被PMS标记为临时app</span><br><span class="line">#       isOwner (boolean)			是否是主用户</span><br><span class="line">#       user (string)				所属用户 _app|_isolated|system|...</span><br><span class="line">#       seinfo (string)				和签名配置相关，暂时认为签名类型</span><br><span class="line">#       name (string)				包名</span><br><span class="line">#       path (string)				app路径</span><br><span class="line">#       isPrivApp (boolean)			是否是预编译到/system/priv-app目录下的app</span><br><span class="line">#       minTargetSdkVersion (unsigned integer)	targetSdkVersion是否是大于等于指定值</span><br><span class="line">#       fromRunAs (boolean)			是否由run-as启动</span><br></pre></td></tr></table></figure>

<p>匹配的输出有以下几种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Outputs:</span><br><span class="line">#       domain (string)				app的domain，即app运行后进程的安全上下文</span><br><span class="line">#       type (string)				app的data数据的安全上下文</span><br><span class="line">#       levelFrom (string; one of none, all, app, or user)  用来确定安全级别 (sensitivity + categories)</span><br><span class="line">#       level (string)</span><br></pre></td></tr></table></figure>

<p>匹配有优先级,seapp_contexts在初始化时，被加载到内存，然后会根据优先级进行排序，排序规则如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.isSystemServer=true 会优先于 isSystemServer=false。</span><br><span class="line">2.指定了 isEphemeralApp=true 会优先于未指定的 isEphemeralApp。</span><br><span class="line">3.指定了 isOwner=true 会优先于未指定的 isOwner。</span><br><span class="line">4.指定了 user=string 会优先于未指定的 user=string；更具体的 user=string 会优先于较不具体的匹配。</span><br><span class="line">5.指定了 seinfo=string 会优先于未指定的 seinfo。</span><br><span class="line">6.指定了 name=string 会优先于未指定的 name；更具体的 name=string 会优先于较不具体的。</span><br><span class="line">7.指定了 path=string 会优先于未指定的 path。</span><br><span class="line">8.指定了 isPrivApp=true 会优先于未指定的 isPrivApp。</span><br><span class="line">9.更高的 minTargetSdkVersion 会优先于较低的 minTargetSdkVersion。如果未指定，默认为 0。</span><br><span class="line">10.fromRunAs=true 会优先于 fromRunAs=false。</span><br><span class="line">注：一个固定的选择器比以 * 结尾的前缀更具特定性，而较长的前缀比短前缀更具特定性。</span><br></pre></td></tr></table></figure>

<p>对seapp_contexts的解析可以看external&#x2F;selinux&#x2F;libselinux&#x2F;src&#x2F;android&#x2F;android_platform.c的<br>selinux_android_seapp_context_reload<br>seapp_context_cmp<br>seapp_context_lookup<br>selinux_android_setcontext<br>pkgdir_selabel_lookup<br>方法</p>
<p>所有可以自定义app私有目录的标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将com.local.test私有目录下的所有文件标记为system_app_data_file</span><br><span class="line">user=system seinfo=platform name=com.local.test path=* type=system_app_data_file</span><br><span class="line"># 将com.local.test私有目录下的files标记为app_data_file</span><br><span class="line">user=system seinfo=platform name=com.local.test path=files type=app_data_file</span><br><span class="line"># 将com.local.test私有目录下的tmp标记为app_data_file</span><br><span class="line">user=system seinfo=platform name=com.local.test path=tmp type=app_data_file</span><br></pre></td></tr></table></figure>


<h2 id="Android中定义好的attribute"><a href="#Android中定义好的attribute" class="headerlink" title="Android中定义好的attribute"></a>Android中定义好的attribute</h2><p>Android中定义的attribute可以在<a href="http://aospxref.com/android-11.0.0_r21/xref/system/sepolicy/public/attributes">system&#x2F;sepolicy&#x2F;public&#x2F;attributes</a>中查看.</p>
<p>常用的如下：</p>
<table>
<thead>
<tr>
<th>attribute</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>dev_type</td>
<td>所有设备类型</td>
</tr>
<tr>
<td>domain</td>
<td>所有进程类型</td>
</tr>
<tr>
<td>appdomain</td>
<td>所有app进程</td>
</tr>
<tr>
<td>file_type</td>
<td>所有文件类型</td>
</tr>
<tr>
<td>exec_type</td>
<td>所有可执行进程入口</td>
</tr>
<tr>
<td>data_file_type</td>
<td>所有&#x2F;data 目录下的文件</td>
</tr>
<tr>
<td>system_file_type</td>
<td>所有&#x2F;system目录下的文件</td>
</tr>
<tr>
<td>vendor_file_type</td>
<td>所有&#x2F;vendor目录下的文件</td>
</tr>
<tr>
<td>service_manager_type</td>
<td>所有通过servicemanager管理的服务</td>
</tr>
<tr>
<td>hwservice_manager_type</td>
<td>所有通过hwservicemanager管理的服务</td>
</tr>
<tr>
<td>mlstrustedsubject</td>
<td>所有能越过MLS检查的主体（进程）</td>
</tr>
<tr>
<td>mlstrustedobject</td>
<td>所有能越过MLS检查的客体（低权限用户可读，高权限用户可写的文件）</td>
</tr>
</tbody></table>
<h2 id="Android-SELinux定义的一些宏"><a href="#Android-SELinux定义的一些宏" class="headerlink" title="Android SELinux定义的一些宏"></a>Android SELinux定义的一些宏</h2><p><a href="https://source.android.google.cn/docs/security/features/selinux/concepts?hl=zh-cn#macros">https://source.android.google.cn/docs/security/features/selinux/concepts?hl=zh-cn#macros</a></p>
<p><a href="http://aospxref.com/android-12.0.0_r3/xref/system/sepolicy/private/access_vectors">system&#x2F;sepolicy&#x2F;private&#x2F;access_vectors</a> 定义的访问向量及相关的权限</p>
<p><a href="http://aospxref.com/android-12.0.0_r3/xref/system/sepolicy/private/security_classes">system&#x2F;sepolicy&#x2F;private&#x2F;security_classes</a> </p>
<p><a href="http://aospxref.com/android-12.0.0_r3/xref/system/sepolicy/private/mls_macros">system&#x2F;sepolicy&#x2F;private&#x2F;mls_macro</a></p>
<p><a href="http://aospxref.com/android-12.0.0_r3/xref/system/sepolicy/public/global_macros">system&#x2F;sepolicy&#x2F;public&#x2F;global_macros</a> 全局可用的宏，主要是操作对象组、权限组</p>
<p><a href="http://aospxref.com/android-12.0.0_r3/xref/system/sepolicy/public/ioctl_defines">system&#x2F;sepolicy&#x2F;public&#x2F;ioctl_defines</a> 定义的ioctlcmd对应的宏，针对ioctl权限需要 使用<code>allowxperm subject object:ioctl &#123; ioctlcmd &#125;</code> <a href="https://github.com/SELinuxProject/selinux-notebook/blob/main/src/xperm_rules.md#ioctl-operation-rules">参考octl-operation-rules</a></p>
<p><a href="http://aospxref.com/android-12.0.0_r3/xref/system/sepolicy/public/ioctl_macros">system&#x2F;sepolicy&#x2F;public&#x2F;ioctl_macros</a> 定义了一些iocltcmd的分组宏</p>
<p><a href="http://aospxref.com/android-12.0.0_r3/xref/system/sepolicy/public/neverallow_macros">system&#x2F;sepolicy&#x2F;public&#x2F;neverallow_macros</a> </p>
<p><a href="http://aospxref.com/android-12.0.0_r3/xref/system/sepolicy/public/te_macros">system&#x2F;sepolicy&#x2F;public&#x2F;te_macros</a>  定义一些在te文件中使用的宏函数</p>
<h3 id="所有第三方app"><a href="#所有第三方app" class="headerlink" title="所有第三方app"></a>所有第三方app</h3><p><code>untrusted_app_all</code>,<br>所有调用了<code>untrusted_app_domain()</code>的domain都被定义成了untrusted_app_all<br>在 <code>system/sepolicy/public/te_macros</code>中有定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#####################################</span><br><span class="line"># untrusted_app_domain(domain)</span><br><span class="line"># Allow a base set of permissions required for all untrusted apps.</span><br><span class="line">define(`untrusted_app_domain&#x27;, `</span><br><span class="line">typeattribute $1 untrusted_app_all;</span><br><span class="line">&#x27;)</span><br></pre></td></tr></table></figure>
<h2 id="file-contexts为文件指定安全上下文"><a href="#file-contexts为文件指定安全上下文" class="headerlink" title="file_contexts为文件指定安全上下文"></a>file_contexts为文件指定安全上下文</h2><p>在 android&#x2F;external&#x2F;selinux&#x2F;libselinux&#x2F;src&#x2F;label.c 中 有个selabel_file_init函数，可以先跟一下源码<br>它会调用process_line去解析每行的定义，process_line函数在android&#x2F;external&#x2F;selinux&#x2F;libselinux&#x2F;src&#x2F;label_file.h中定义的</p>
<h2 id="为指定APP添加一个新的安全上下文"><a href="#为指定APP添加一个新的安全上下文" class="headerlink" title="为指定APP添加一个新的安全上下文"></a>为指定APP添加一个新的安全上下文</h2><ol>
<li><p>先定义一个app的类型，暂时定为omo_app, sepolicy目录下新建omo_app.te</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type omo_app, domain, coredomain;</span><br><span class="line">#允许omo_app拥有app的基本权限集</span><br><span class="line">app_domain(omo_app)</span><br><span class="line">#允许omo_app拥有基本的网络权限集</span><br><span class="line">net_domain(omo_app)</span><br><span class="line"># 剩余的权限可以根据需求进行添加，可以参考system_app补全</span><br></pre></td></tr></table></figure>
</li>
<li><p>在seapp_contexts中定义app安全上下文，这里在结尾换行时需要注意不要用windows回车换行，需要用linux下的换行，不然编译时无法通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user=system seinfo=platform name=com.omosoft.localtest domain=omo_app type=system_app_data_file</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="selinux权限配置"><a href="#selinux权限配置" class="headerlink" title="selinux权限配置"></a>selinux权限配置</h2><p>mlstrustedsubject</p>
<p>selinux权限的宏定义：<a href="http://aospxref.com/android-11.0.0_r21/xref/system/sepolicy/public/global_macros">global_macros</a></p>
<p>快速配置权限可以使用audit2allow：<a href="https://source.android.google.cn/security/selinux/validate?hl=zh_cn#using_audit2allow">https://source.android.google.cn/security/selinux/validate?hl=zh_cn#using_audit2allow</a></p>
<p><a href="https://source.android.google.cn/docs/security/features/selinux/validate?hl=zh-cn#using_audit2allow">https://source.android.google.cn/docs/security/features/selinux/validate?hl=zh-cn#using_audit2allow</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull /sys/fs/selinux/policy</span><br><span class="line">adb logcat -b all -d | audit2allow -p policy</span><br></pre></td></tr></table></figure>

<p>添加权限容易，但实际中会遇到和Android selinux权限策略冲突，编译无法通过（neverallow问题）。</p>
<p>neverallow的问题解决思路是，在对应的地方添加 过滤。将冲突的地方添加例外。</p>
<p>但由于兼容性检查，需要处理当前api版本和前一个api版本的selinux权限</p>
<p>以adasService为例：</p>
<ol>
<li><p>运行时报错， init 没有 通过process对 adasService进行 transition的权限</p>
</li>
<li><p>直接<code>allow init adasService:process transition;</code>是不行的，编译无法通过，违法了neverallow规则。</p>
</li>
<li><p>找到对应的neverallow规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neverallow &#123; domain -kernel &#125; init:process transition;</span><br></pre></td></tr></table></figure>

<p>添加例外，将adasService添加进去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neverallow &#123; domain -kernel -adasService &#125; init:process transition;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时规则正确，但selinux校验会失败，编译会报 sepolicy_freeze_test ，因为selinux权限有校验，修改后的文件会和&#x2F;system&#x2F;sepolicy&#x2F;prebuilts&#x2F;api&#x2F;30.0&#x2F;中进行比较，文件内容不同，校验不通过，所以需要将&#x2F;system&#x2F;sepolicy&#x2F;private和&#x2F;system&#x2F;sepolicy&#x2F;public修改过的地方，同步在&#x2F;system&#x2F;sepolicy&#x2F;prebuilts&#x2F;api&#x2F;30.0&#x2F;对应文件中进行修改</p>
</li>
<li><p>还有兼容性问题，在&#x2F;system&#x2F;sepolicy&#x2F;private&#x2F;compat 目录下，找到最新的api目录，修改其中的ignore.cil，将新增的type加入到new_objects，不做兼容性校验。记得同步更新prebuilts&#x2F;api&#x2F;30.0&#x2F;private&#x2F;compat下对应文件。</p>
</li>
</ol>
<h2 id="hal-vehicle-neverallow"><a href="#hal-vehicle-neverallow" class="headerlink" title="hal_vehicle neverallow"></a>hal_vehicle neverallow</h2><p>libsepol.report_failure: neverallow on line 6 of system&#x2F;sepolicy&#x2F;public&#x2F;hal_vehicle.te (or line 20021 of policy.conf) violated by allow avm3d_service hal_vehicle_hwservice:hwservice_manager { find };</p>
<p>居然出现了neverallow，hal_vehicle是android原生的车载服务标签，查看对应的te，发现没有限制。跑去对比其他te发现是需要添加：</p>
<p>hal_client_domain(avm3d_service, hal_vehicle)</p>
<p>即需要跟hal_vehicle进行client绑定</p>
<h2 id="enforce节点"><a href="#enforce节点" class="headerlink" title="enforce节点"></a>enforce节点</h2><p>setenforce 和 getenforce都是 读写的 <code>/sys/fs/selinux/enforce</code></p>
<h2 id="type和typeattribute"><a href="#type和typeattribute" class="headerlink" title="type和typeattribute"></a>type和typeattribute</h2><p>type 用来定义一个类型并可以声明它的属性<br>typeattribute 用来对已经定义过的type进行属性追加，特别是在一些宏定义中，都是通过typeattribute来进行属性追加</p>
<p>type重复定义会报错，typeattribute可以多次对同一个type进行属性追加</p>
<h2 id="关于一些宏中的never-allow"><a href="#关于一些宏中的never-allow" class="headerlink" title="关于一些宏中的never allow"></a>关于一些宏中的never allow</h2><p>add_hwservice(domain, service): 允许domain 通过hwservice_manager对service进行find和add，不允许其它domain来add这个service了<br>hal_attribute_hwservice(attribute, service):<br>   允许attribute_client通过hwservice_manager对service进行find<br>   允许attribute_server通过hwservice_manager对service进行find和add，不允许其它domain来add这个service<br>   不允许attribute_client和attribute_server之外的其它domain通过hwservice_manager对service进行find</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###########################################</span><br><span class="line"># add_hwservice(domain, service)</span><br><span class="line"># Ability for domain to add a service to hwservice_manager</span><br><span class="line"># and find it. It also creates a neverallow preventing</span><br><span class="line"># others from adding it.</span><br><span class="line">define(`add_hwservice&#x27;, `</span><br><span class="line">  allow $1 $2:hwservice_manager &#123; add find &#125;;</span><br><span class="line">  allow $1 hidl_base_hwservice:hwservice_manager add;</span><br><span class="line">  neverallow &#123; domain -$1 &#125; $2:hwservice_manager add;</span><br><span class="line">&#x27;)</span><br><span class="line"></span><br><span class="line">###########################################</span><br><span class="line"># hal_attribute_hwservice(attribute, service)</span><br><span class="line"># Ability for domain to get a service to hwservice_manager</span><br><span class="line"># and find it. It also creates a neverallow preventing</span><br><span class="line"># others from adding it.</span><br><span class="line">#</span><br><span class="line"># Used to pair hal_foo_client with hal_foo_hwservice</span><br><span class="line">define(`hal_attribute_hwservice&#x27;, `</span><br><span class="line">  allow $1_client $2:hwservice_manager find;</span><br><span class="line">  add_hwservice($1_server, $2)</span><br><span class="line"></span><br><span class="line">  build_test_only(`</span><br><span class="line">    neverallow &#123; domain -$1_client -$1_server &#125; $2:hwservice_manager find;</span><br><span class="line">  &#x27;)</span><br><span class="line">&#x27;)</span><br></pre></td></tr></table></figure>

<p>所以针对这类的，就是将需要权限的domain追加一个attribute_client的属性，通过hal_client_domain(domain, hal_type)即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#####################################</span><br><span class="line"># hal_client_domain(domain, hal_type)</span><br><span class="line"># Allow a base set of permissions required for a domain to be a</span><br><span class="line"># client of a HAL of the specified type.</span><br><span class="line">#</span><br><span class="line"># For example, make some_domain a client of Foo HAL:</span><br><span class="line">#   hal_client_domain(some_domain, hal_foo)</span><br><span class="line">#</span><br><span class="line">define(`hal_client_domain&#x27;, `</span><br><span class="line">typeattribute $1 halclientdomain;</span><br><span class="line">typeattribute $1 $2_client;</span><br></pre></td></tr></table></figure>


<h2 id="新增attribute"><a href="#新增attribute" class="headerlink" title="新增attribute"></a>新增attribute</h2><p>在<code>attributes</code>文件中定义新的attributes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attributes test_domain</span><br></pre></td></tr></table></figure>
<p>然后可以针对这个属性进行权限配置<br>在test_domain.te中做配置</p>
<h2 id="新增宏定义"><a href="#新增宏定义" class="headerlink" title="新增宏定义"></a>新增宏定义</h2><p>在te_macros中添加一些宏，让每次的配置更方便</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#####################################</span><br><span class="line"># define_custom_executable(name)</span><br><span class="line"># 传入一个名字，根据这个名字定义必须的类型</span><br><span class="line">define(`define_custom_executable&#x27;,`</span><br><span class="line">type $1, domain, coredomain, custom_executable_domain;</span><br><span class="line">type $1_exec, exec_type, file_type, system_file_type;</span><br><span class="line">&#x27;)</span><br><span class="line"></span><br><span class="line">#####################################</span><br><span class="line"># custom_use_socket(domain)</span><br><span class="line"># 添加使用socket需要的权限</span><br><span class="line">define(`custom_use_socket&#x27;,`</span><br><span class="line">allow $1 self:udp_socket create_socket_perms;</span><br><span class="line">allow $1 node:udp_socket node_bind;</span><br><span class="line">allow $1 self:tcp_socket create_stream_socket_perms;</span><br><span class="line">allow $1 node:tcp_socket node_bind;</span><br><span class="line">&#x27;)</span><br></pre></td></tr></table></figure>



<h2 id="网络相关权限"><a href="#网络相关权限" class="headerlink" title="网络相关权限"></a>网络相关权限</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># te_macros中有宏定义，net.te中有相关的权限配置</span><br><span class="line">net_domain(domain)</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>IMMS</title>
    <url>//pages/0b0586/</url>
    <content><![CDATA[<h2 id="输入法基本框架"><a href="#输入法基本框架" class="headerlink" title="输入法基本框架"></a>输入法基本框架</h2><p>输入法框架整体分为三个部分:</p>
<ol>
<li><p>输入法管理端 IMMS  </p>
<p> 主要指 InputMethodManagerService</p>
</li>
<li><p>输入法服务端 IMS</p>
<p> InputMethodService</p>
</li>
<li><p>输入法客户端 IMM</p>
<p> InputMethodManager</p>
</li>
</ol>
<h2 id="输入法初始化过程"><a href="#输入法初始化过程" class="headerlink" title="输入法初始化过程"></a>输入法初始化过程</h2><h3 id="输入法客户端初始化（IMM）"><a href="#输入法客户端初始化（IMM）" class="headerlink" title="输入法客户端初始化（IMM）"></a>输入法客户端初始化（IMM）</h3><p>每个app都有一个IMM实例, 并且在应用内是单例存在. 当app需要输入法时操作IMM来请求IMMS进行输入法操作; 当IMMS需要通知app时, 则通过IMM告知app下一步操作.</p>
<p>输入法的初始话从添加window开始的, 每次添加window时会实例化 ViewRootImpl, ViewRootImpl 在获取 IWindowSession时会检查输入法是否已经初始化.</p>
<p>回顾一下Activty的启动流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityThread.handleLaunchActivity</span><br><span class="line">    ActivityThread.performLaunchActivity</span><br><span class="line">        Activity.attach() 方法内部创建PhoneWindow</span><br><span class="line"></span><br><span class="line">ActivityThread.handleResumeActivity</span><br><span class="line">    WindowManagerGlobal.addView 方法内部会创建ViewRootImpl</span><br><span class="line">        ViewRootImpl.setView</span><br><span class="line">            ViewRootImpl.requestLayout</span><br><span class="line">                ViewRootImpl.scheduleTraversals</span><br><span class="line">                    ViewRootImpl.performTraversals()</span><br><span class="line">            mWindowSession.addToDisplayAsUser</span><br><span class="line">                WindowManagerService.addWindow</span><br></pre></td></tr></table></figure>
<p>这里主要看WindowManagerGlobal.addView中ViewRootImpl的初始化<br>ViewRootImpl：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ViewRootImpl(Context context, Display display) &#123;</span><br><span class="line">    this(context, display, WindowManagerGlobal.getWindowSession(),</span><br><span class="line">            false /* useSfChoreographer */);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowManagerGlobal:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static IWindowSession getWindowSession() &#123;</span><br><span class="line">    synchronized (WindowManagerGlobal.class) &#123;</span><br><span class="line">        if (sWindowSession == null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // Emulate the legacy behavior.  The global instance of InputMethodManager</span><br><span class="line">                // was instantiated here.</span><br><span class="line">                // TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage</span><br><span class="line">                //这里也有注释，历史行为，初始化全局InputMethodManager，后续可能会变方案</span><br><span class="line">                InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary();</span><br><span class="line">                IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        new IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void onAnimatorScaleChanged(float scale) &#123;</span><br><span class="line">                                ValueAnimator.setDurationScale(scale);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputMethodManager.java：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void ensureDefaultInstanceForDefaultDisplayIfNecessary() &#123;</span><br><span class="line">    forContextInternal(Display.DEFAULT_DISPLAY, Looper.getMainLooper());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static InputMethodManager forContextInternal(int displayId, Looper looper) &#123;</span><br><span class="line">    final boolean isDefaultDisplay = displayId == Display.DEFAULT_DISPLAY;</span><br><span class="line">    synchronized (sLock) &#123;</span><br><span class="line">        //从缓存取</span><br><span class="line">        InputMethodManager instance = sInstanceMap.get(displayId);</span><br><span class="line">        if (instance != null) &#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">        //缓存中没有就创建一个</span><br><span class="line">        instance = createInstance(displayId, looper);</span><br><span class="line">        // For backward compatibility, store the instance also to sInstance for default display.</span><br><span class="line">        if (sInstance == null &amp;&amp; isDefaultDisplay) &#123;</span><br><span class="line">            sInstance = instance;</span><br><span class="line">        &#125;</span><br><span class="line">        sInstanceMap.put(displayId, instance);</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">private static InputMethodManager createRealInstance(int displayId, Looper looper) &#123;</span><br><span class="line">    final IInputMethodManager service;</span><br><span class="line">    try &#123;</span><br><span class="line">        service = IInputMethodManager.Stub.asInterface(</span><br><span class="line">                ServiceManager.getServiceOrThrow(Context.INPUT_METHOD_SERVICE));</span><br><span class="line">    &#125; catch (ServiceNotFoundException e) &#123;</span><br><span class="line">        throw new IllegalStateException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    final InputMethodManager imm = new InputMethodManager(service, displayId, looper);</span><br><span class="line">    // InputMethodManagerService#addClient() relies on Binder.getCalling&#123;Pid, Uid&#125;() to</span><br><span class="line">    // associate PID/UID with each IME client. This means:</span><br><span class="line">    //  A. if this method call will be handled as an IPC, there is no problem.</span><br><span class="line">    //  B. if this method call will be handled as an in-proc method call, we need to</span><br><span class="line">    //     ensure that Binder.getCalling&#123;Pid, Uid&#125;() return Process.my&#123;Pid, Uid&#125;()</span><br><span class="line">    // Either ways we can always call Binder.&#123;clear, restore&#125;CallingIdentity() because</span><br><span class="line">    // 1) doing so has no effect for A and 2) doing so is sufficient for B.</span><br><span class="line">    final long identity = Binder.clearCallingIdentity();</span><br><span class="line">    try &#123;</span><br><span class="line">        service.addClient(imm.mClient, imm.mIInputContext, displayId);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        e.rethrowFromSystemServer();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(identity);</span><br><span class="line">    &#125;</span><br><span class="line">    return imm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private InputMethodManager(IInputMethodManager service, int displayId, Looper looper) &#123;</span><br><span class="line">    mService = service;</span><br><span class="line">    mMainLooper = looper;</span><br><span class="line">    mH = new H(looper);</span><br><span class="line">    mDisplayId = displayId;</span><br><span class="line">    //创建一个虚拟的输入法上下文, 接收输入事件, 主要用于监听输入法服务的激活状态</span><br><span class="line">    mIInputContext = new ControlledInputConnectionWrapper(looper, mDummyInputConnection, this,</span><br><span class="line">            null);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">private static class ControlledInputConnectionWrapper extends IInputConnectionWrapper &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean isActive() &#123;</span><br><span class="line">        // 处理事件之一, 判断输入法是否激活状态</span><br><span class="line">        return mParentInputMethodManager.mActive &amp;&amp; !isFinished();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void deactivate() &#123;</span><br><span class="line">        // 处理事件之二, 关闭 InputConnection</span><br><span class="line">        if (isFinished()) &#123;</span><br><span class="line">            // This is a small performance optimization.  Still only the 1st call of</span><br><span class="line">            // reportFinish() will take effect.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        closeConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<h2 id="输入法管理端（IMMS）的初始化"><a href="#输入法管理端（IMMS）的初始化" class="headerlink" title="输入法管理端（IMMS）的初始化"></a>输入法管理端（IMMS）的初始化</h2><p>IMMS 运行在system_server进程, 属于系统服务的一部分, 用于控制输入法的切换, 显示&#x2F;隐藏状态, 输入法服务的绑定等操作.</p>
<h2 id="输入法服务端（IMS）的初始化"><a href="#输入法服务端（IMS）的初始化" class="headerlink" title="输入法服务端（IMS）的初始化"></a>输入法服务端（IMS）的初始化</h2><p>IMS 运行在输入法进程, 是一个Service<br>InputMethodService extends AbstractInputMethodServiceService</p>
<h2 id="输入法官方文档"><a href="#输入法官方文档" class="headerlink" title="输入法官方文档"></a>输入法官方文档</h2><p><a href="https://developer.android.google.cn/guide/topics/text/creating-input-method?hl=zh-cn">https://developer.android.google.cn/guide/topics/text/creating-input-method?hl=zh-cn</a></p>
<h2 id="自定义输入法"><a href="#自定义输入法" class="headerlink" title="自定义输入法"></a>自定义输入法</h2><ol>
<li>需要自定义一个service继承自InputMethodService</li>
<li>需要配置该service的权限,intent-filter及meta-data,meta-data是输入法的配置IME子类型等<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;service android:name=&quot;com.omosoft.cusime.LocalIMEService&quot;</span><br><span class="line">    android:label=&quot;@string/app_name&quot;</span><br><span class="line">    android:permission=&quot;android.permission.BIND_INPUT_METHOD&quot;</span><br><span class="line">    android:exported=&quot;true&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.view.InputMethod&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">    &lt;meta-data android:name=&quot;android.view.im&quot; android:resource=&quot;@xml/method&quot; /&gt;</span><br><span class="line">&lt;/service&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
method.xml<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;input-method xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:settingsActivity=&quot;com.omosoft.cusime.MainActivity&quot;</span><br><span class="line">    android:supportsSwitchingToNextInputMethod=&quot;true&quot;&gt;</span><br><span class="line">    &lt;subtype</span><br><span class="line">        android:label=&quot;子类型1&quot;</span><br><span class="line">        android:imeSubtypeLocale=&quot;en_US&quot;</span><br><span class="line">        android:imeSubtypeExtraValue=&quot;KeyboardLayoutSet=spanish,AsciiCapable,EmojiCapable&quot;</span><br><span class="line">        android:imeSubtypeMode=&quot;keyboard&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/input-method&gt;</span><br></pre></td></tr></table></figure></li>
<li>重写onCreateInputView(),返回输入区域用来显示键盘相关的布局</li>
</ol>
<p>到此一个简单的输入法就完成了。</p>
<h2 id="输入法全屏"><a href="#输入法全屏" class="headerlink" title="输入法全屏"></a>输入法全屏</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onEvaluateFullscreenMode() &#123;</span><br><span class="line">    //重写，不全屏</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发送文本"><a href="#发送文本" class="headerlink" title="发送文本"></a>发送文本</h2><p>输入法需要将用户输入的文本显示到输入框，调用<code>getCurrentInputConnection().commitText</code>即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getCurrentInputConnection().commitText(&quot;测试&quot;, 1);</span><br></pre></td></tr></table></figure>

<p>另外可以重写onKeyDown和onKeyUp处理key事件</p>
<p>在ViewRootImpl中处理了输入事件的大体流程：<br>ViewRootImpl持有一个WindowInputEventReceiver继承自InputEventReceiver，在InputEventReceiver的dispatchInputEvent中<br>会去调用onInputEvent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WindowInputEventReceiver.onInputEvent</span><br><span class="line">ViewRootImpl.enqueueInputEvent</span><br><span class="line">    doProcessInputEvents</span><br><span class="line">    deliverInputEvent</span><br></pre></td></tr></table></figure>
<p>在deliverInputEvent中抽象了InputStage对象，总共大概有6个阶段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mSyntheticInputStage = new SyntheticInputStage();</span><br><span class="line">InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);</span><br><span class="line">InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage,</span><br><span class="line">        &quot;aq:native-post-ime:&quot; + counterSuffix);</span><br><span class="line">InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);</span><br><span class="line">InputStage imeStage = new ImeInputStage(earlyPostImeStage,</span><br><span class="line">        &quot;aq:ime:&quot; + counterSuffix);</span><br><span class="line">InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);</span><br><span class="line">InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage,</span><br><span class="line">        &quot;aq:native-pre-ime:&quot; + counterSuffix);</span><br></pre></td></tr></table></figure>

<p>其中的ImeInputStage就是输入法处理输入事件的阶段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final class ImeInputStage extends AsyncInputStage</span><br><span class="line">        implements InputMethodManager.FinishedInputEventCallback &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected int onProcess(QueuedInputEvent q) &#123;</span><br><span class="line">        final int result = mImeFocusController.onProcessImeInputStage(</span><br><span class="line">                q, q.mEvent, mWindowAttributes, this);</span><br><span class="line">        switch (result) &#123;</span><br><span class="line">            case InputMethodManager.DISPATCH_IN_PROGRESS:</span><br><span class="line">                // callback will be invoked later</span><br><span class="line">                return DEFER;</span><br><span class="line">            case InputMethodManager.DISPATCH_NOT_HANDLED:</span><br><span class="line">                // The IME could not handle it, so skip along to the next InputStage</span><br><span class="line">                return FORWARD;</span><br><span class="line">            case InputMethodManager.DISPATCH_HANDLED:</span><br><span class="line">                return FINISH_HANDLED;</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalStateException(&quot;Unexpected result=&quot; + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ImeFocusController.java:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int onProcessImeInputStage(Object token, InputEvent event,</span><br><span class="line">        WindowManager.LayoutParams windowAttribute,</span><br><span class="line">        InputMethodManager.FinishedInputEventCallback callback) &#123;</span><br><span class="line">    if (!mHasImeFocus || isInLocalFocusMode(windowAttribute)) &#123;</span><br><span class="line">        return InputMethodManager.DISPATCH_NOT_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">    final InputMethodManager imm =</span><br><span class="line">            mViewRootImpl.mContext.getSystemService(InputMethodManager.class);</span><br><span class="line">    if (imm == null) &#123;</span><br><span class="line">        return InputMethodManager.DISPATCH_NOT_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">    //调用了imm的dispatchInputEvent</span><br><span class="line">    return imm.dispatchInputEvent(event, token, callback, mViewRootImpl.mHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="IME相关的shell指令"><a href="#IME相关的shell指令" class="headerlink" title="IME相关的shell指令"></a>IME相关的shell指令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出所有输入法</span><br><span class="line">ime list</span><br><span class="line"># 切换输入法</span><br><span class="line">ime set --user current &lt;ID&gt;</span><br><span class="line"># 启用输入法</span><br><span class="line">ime enable --user current &lt;ID&gt;</span><br><span class="line"># 禁用输入法</span><br><span class="line">ime disable --user current &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<p>有些输入法会拦截输入事件，这种情况下就会导致 inut text 时效，<br>可以通过先禁用输入法，input text之后再启用输入法的方式来实现快速输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell &quot;ime disable com.dt.huihan/.PinyinIME&quot;</span><br><span class="line">adb shell input text 123456</span><br><span class="line">adb shell &quot;ime enable com.dt.huihan/.PinyinIME&quot;</span><br></pre></td></tr></table></figure>

<h2 id="app切换时输入法流程记录"><a href="#app切换时输入法流程记录" class="headerlink" title="app切换时输入法流程记录"></a>app切换时输入法流程记录</h2><p>在 <code>ViewRootImpl</code>中的<code>windowFocusChanged</code>方法中通过handler调用<code>handleWindowFocusChanged</code></p>
<p>在<code>handleWindowFocusChanged</code>中会去调用 <code>ImeFocusController</code>去控制输入法的焦点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mImeFocusController.onPostWindowFocus(mView != null ? mView.findFocus() : null, hasWindowFocus, mWindowAttributes);</span><br></pre></td></tr></table></figure>

<p>可以看一下ImeFocusController的onPostWindowFocus做了啥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@UiThread</span><br><span class="line">void onPostWindowFocus(View focusedView, boolean hasWindowFocus,</span><br><span class="line">        WindowManager.LayoutParams windowAttribute) &#123;</span><br><span class="line">    //只要没有window焦点 或者 没有Ime焦点  或者 使用本地焦点，就不处理后续</span><br><span class="line">    if (!hasWindowFocus || !mHasImeFocus || isInLocalFocusMode(windowAttribute)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        Log.v(TAG, &quot;onWindowFocus: &quot; + focusedView</span><br><span class="line">                + &quot; softInputMode=&quot; + InputMethodDebug.softInputModeToString(</span><br><span class="line">                windowAttribute.softInputMode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean forceFocus = false;</span><br><span class="line">    final InputMethodManagerDelegate immDelegate = getImmDelegate();</span><br><span class="line">    if (immDelegate.isRestartOnNextWindowFocus(true /* reset */)) &#123;</span><br><span class="line">        if (DEBUG) Log.v(TAG, &quot;Restarting due to isRestartOnNextWindowFocus as true&quot;);</span><br><span class="line">        forceFocus = true;</span><br><span class="line">    &#125;</span><br><span class="line">    // Update mNextServedView when focusedView changed.</span><br><span class="line">    final View viewForWindowFocus = focusedView != null ? focusedView : mViewRootImpl.mView;</span><br><span class="line">    onViewFocusChanged(viewForWindowFocus, true);</span><br><span class="line"></span><br><span class="line">    // Starting new input when the next focused view is same as served view but the currently</span><br><span class="line">    // active connection (if any) is not associated with it.</span><br><span class="line">    final boolean nextFocusIsServedView = mServedView == viewForWindowFocus;</span><br><span class="line">    if (nextFocusIsServedView &amp;&amp; !immDelegate.hasActiveConnection(viewForWindowFocus)) &#123;</span><br><span class="line">        forceFocus = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //最后会调用IMM的代理类的startInputAsyncOnWindowFocusGain方法处理window获取到焦点的情况</span><br><span class="line">    immDelegate.startInputAsyncOnWindowFocusGain(viewForWindowFocus,</span><br><span class="line">            windowAttribute.softInputMode, windowAttribute.flags, forceFocus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看DelegateImpl中的startInputAsyncOnWindowFocusGain</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void startInputAsyncOnWindowFocusGain(View focusedView,</span><br><span class="line">        @SoftInputModeFlags int softInputMode, int windowFlags, boolean forceNewFocus) &#123;</span><br><span class="line">    int startInputFlags = getStartInputFlags(focusedView, 0);</span><br><span class="line">    startInputFlags |= StartInputFlags.WINDOW_GAINED_FOCUS;</span><br><span class="line"></span><br><span class="line">    final ImeFocusController controller = getFocusController();</span><br><span class="line">    if (controller == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (controller.checkFocus(forceNewFocus, false)) &#123;</span><br><span class="line">        // We need to restart input on the current focus view.  This</span><br><span class="line">        // should be done in conjunction with telling the system service</span><br><span class="line">        // about the window gaining focus, to help make the transition</span><br><span class="line">        // smooth.</span><br><span class="line">        if (startInput(StartInputReason.WINDOW_FOCUS_GAIN,</span><br><span class="line">                focusedView, startInputFlags, softInputMode, windowFlags)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (mH) &#123;</span><br><span class="line">        // For some reason we didn&#x27;t do a startInput + windowFocusGain, so</span><br><span class="line">        // we&#x27;ll just do a window focus gain and call it a day.</span><br><span class="line">        try &#123;</span><br><span class="line">            View servedView = controller.getServedView();</span><br><span class="line">            boolean nextFocusHasConnection = servedView != null &amp;&amp; servedView == focusedView</span><br><span class="line">                    &amp;&amp; hasActiveConnection(focusedView);</span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                Log.v(TAG, &quot;Reporting focus gain, without startInput&quot;</span><br><span class="line">                        + &quot;, nextFocusIsServedView=&quot; + nextFocusHasConnection);</span><br><span class="line">            &#125;</span><br><span class="line">            final int startInputReason =</span><br><span class="line">                    nextFocusHasConnection ? WINDOW_FOCUS_GAIN_REPORT_WITH_CONNECTION</span><br><span class="line">                            : WINDOW_FOCUS_GAIN_REPORT_WITHOUT_CONNECTION;</span><br><span class="line">            mService.startInputOrWindowGainedFocus(</span><br><span class="line">                    startInputReason, mClient,</span><br><span class="line">                    focusedView.getWindowToken(), startInputFlags, softInputMode,</span><br><span class="line">                    windowFlags,</span><br><span class="line">                    null,</span><br><span class="line">                    null,</span><br><span class="line">                    0 /* missingMethodFlags */,</span><br><span class="line">                    mCurRootView.mContext.getApplicationInfo().targetSdkVersion);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>TaskSnapshotController</title>
    <url>//pages/2db764/</url>
    <content><![CDATA[<h2 id="TaskSnapshotController的简介"><a href="#TaskSnapshotController的简介" class="headerlink" title="TaskSnapshotController的简介"></a>TaskSnapshotController的简介</h2><p>在AOSP源码中有相关的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * When an app token becomes invisible, we take a snapshot (bitmap) of the corresponding task and</span><br><span class="line"> * put it into our cache. Internally we use gralloc buffers to be able to draw them wherever we</span><br><span class="line"> * like without any copying.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * System applications may retrieve a snapshot to represent the current state of a task, and draw</span><br><span class="line"> * them in their own process.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * When we task becomes visible again, we show a starting window with the snapshot as the content to</span><br><span class="line"> * make app transitions more responsive.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * To access this class, acquire the global window manager lock.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>当app开始不可见时，会对相应的任务抓拍一个快照放入缓存。在内部使用图形缓冲区（gralloc buffers）以便在任何位置绘制它们，而无需进行任何复制操作</p>
<p>系统应用程序可以检索快照来表示任务的当前状态，并在它们自己的进程中进行绘制。</p>
<p>当任务再次变为可见时，我们会显示一个启动窗口，其中的内容是快照，使应用程序的过渡看起来更快。</p>
<p>要访问此类，请获取全局窗口管理器锁。</p>
<h2 id="快照截取时机"><a href="#快照截取时机" class="headerlink" title="快照截取时机"></a>快照截取时机</h2><p>app进行切换时，在 AppTransitionController.java 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Handle application transition for given display.</span><br><span class="line"> */</span><br><span class="line">void handleAppTransitionReady() &#123;</span><br><span class="line">    //......</span><br><span class="line">    //调用TaskSnapshotController的onTransitionStarting</span><br><span class="line">    mService.mTaskSnapshotController.onTransitionStarting(mDisplayContent);</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TaskSnapshotController.java：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void onTransitionStarting(DisplayContent displayContent) &#123;</span><br><span class="line">    handleClosingApps(displayContent.mClosingApps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleClosingApps(ArraySet&lt;ActivityRecord&gt; closingApps) &#123;</span><br><span class="line">    if (shouldDisableSnapshots()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We need to take a snapshot of the task if and only if all activities of the task are</span><br><span class="line">    // either closing or hidden.</span><br><span class="line">    getClosingTasks(closingApps, mTmpTasks);</span><br><span class="line">    snapshotTasks(mTmpTasks);</span><br><span class="line">    mSkipClosingAppSnapshotTasks.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void snapshotTasks(ArraySet&lt;Task&gt; tasks) &#123;</span><br><span class="line">    snapshotTasks(tasks, false /* allowSnapshotHome */);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void snapshotTasks(ArraySet&lt;Task&gt; tasks, boolean allowSnapshotHome) &#123;</span><br><span class="line">    for (int i = tasks.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        final Task task = tasks.valueAt(i);</span><br><span class="line">        final TaskSnapshot snapshot;</span><br><span class="line">        final boolean snapshotHome = allowSnapshotHome &amp;&amp; task.isActivityTypeHome();</span><br><span class="line">        if (snapshotHome) &#123;</span><br><span class="line">            snapshot = snapshotTask(task);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //这里有个逻辑，判断快照抓取的模式，NONE就直接跳过了</span><br><span class="line">            switch (getSnapshotMode(task)) &#123;</span><br><span class="line">                case SNAPSHOT_MODE_NONE:</span><br><span class="line">                    continue;</span><br><span class="line">                case SNAPSHOT_MODE_APP_THEME:</span><br><span class="line">                    snapshot = drawAppThemeSnapshot(task);</span><br><span class="line">                    break;</span><br><span class="line">                case SNAPSHOT_MODE_REAL:</span><br><span class="line">                    snapshot = snapshotTask(task);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    snapshot = null;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (snapshot != null) &#123;</span><br><span class="line">            final GraphicBuffer buffer = snapshot.getSnapshot();</span><br><span class="line">            if (buffer.getWidth() == 0 || buffer.getHeight() == 0) &#123;</span><br><span class="line">                buffer.destroy();</span><br><span class="line">                Slog.e(TAG, &quot;Invalid task snapshot dimensions &quot; + buffer.getWidth() + &quot;x&quot;</span><br><span class="line">                        + buffer.getHeight());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mCache.putSnapshot(task, snapshot);</span><br><span class="line">                // Don&#x27;t persist or notify the change for the temporal snapshot.</span><br><span class="line">                if (!snapshotHome) &#123;</span><br><span class="line">                    mPersister.persistSnapshot(task.mTaskId, task.mUserId, snapshot);</span><br><span class="line">                    task.onSnapshotChanged(snapshot);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快照销毁时机"><a href="#快照销毁时机" class="headerlink" title="快照销毁时机"></a>快照销毁时机</h2><p>看TaskSnapshotController类中有4个方法，<br>onAppRemoved，onAppDied，notifyTaskRemovedFromRecents，removeSnapshotCache，这几个方法都会去移除对应task的快照</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Called when an &#123;@link ActivityRecord&#125; has been removed.</span><br><span class="line"> */</span><br><span class="line">void onAppRemoved(ActivityRecord activity) &#123;</span><br><span class="line">    mCache.onAppRemoved(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Called when the process of an &#123;@link ActivityRecord&#125; has died.</span><br><span class="line"> */</span><br><span class="line">void onAppDied(ActivityRecord activity) &#123;</span><br><span class="line">    mCache.onAppDied(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void notifyTaskRemovedFromRecents(int taskId, int userId) &#123;</span><br><span class="line">    mCache.onTaskRemoved(taskId);</span><br><span class="line">    mPersister.onTaskRemovedFromRecents(taskId, userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void removeSnapshotCache(int taskId) &#123;</span><br><span class="line">    mCache.removeRunningEntry(taskId);</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>
<ol>
<li>在startActivity的时候，会更新task，此时会去调用notifyTaskRemovedFromRecents</li>
<li>在Activity destroy的时候，会去调用onAppRemoved</li>
<li>在app进程异常crash时，会走onAppDied</li>
<li>针对Type为Home的Activity，在StartActivity过程中去showStartingWindow时会调用removeSnapshotCache</li>
</ol>
<p>另外在showStartingWindow中最终是调用addStartingWindow来加载快照的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void showStartingWindow(ActivityRecord prev, boolean newTask, boolean taskSwitch) &#123;</span><br><span class="line">    if (mTaskOverlay) &#123;</span><br><span class="line">        // We don&#x27;t show starting window for overlay activities.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pendingOptions != null</span><br><span class="line">            &amp;&amp; pendingOptions.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class="line">        // Don&#x27;t show starting window when using shared element transition.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final CompatibilityInfo compatInfo =</span><br><span class="line">            mAtmService.compatibilityInfoForPackageLocked(info.applicationInfo);</span><br><span class="line">    //在这里加载快照，其中allowTaskSnapshot()是判断是否允许添加快照</span><br><span class="line">    final boolean shown = addStartingWindow(packageName, theme,</span><br><span class="line">            compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags,</span><br><span class="line">            prev != null ? prev.appToken : null, newTask, taskSwitch, isProcessRunning(),</span><br><span class="line">            allowTaskSnapshot(),</span><br><span class="line">            mState.ordinal() &gt;= STARTED.ordinal() &amp;&amp; mState.ordinal() &lt;= STOPPED.ordinal());</span><br><span class="line">    if (shown) &#123;</span><br><span class="line">        mStartingWindowState = STARTING_WINDOW_SHOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快照的一些参数配置"><a href="#快照的一些参数配置" class="headerlink" title="快照的一些参数配置"></a>快照的一些参数配置</h2><p>可以参考<a href="https://source.android.com/docs/core/perf/task-snapshots?hl=zh-cn">官方的文档</a></p>
<blockquote>
<p>任务快照以两种比例写入磁盘。从磁盘恢复任务快照时，会先读取低分辨率快照，然后将其替换为对应的高分辨率快照。这项优化可缩短映像加载时间。否则，从磁盘读取快照文件时可能会有轻微的延迟，并且在映像可用之前，用户将看到一张空白任务卡。您可以通过设置 config_highResTaskSnapshotScale 和 config_lowResTaskSnapshotScale，在设备叠加层配置文件 overlay&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;res&#x2F;res&#x2F;values&#x2F;config.xml 中配置比例。默认情况下，这两个值分别设置为 1.0 和 0.5。将 config_lowResTaskSnapshotScale 设置为 0.0 可停用低分辨率快照。</p>
</blockquote>
<p>可以通过配置 <code>config_highResTaskSnapshotScale</code>和 <code>config_lowResTaskSnapshotScale</code>来控制快照的分辨率</p>
<p>对应源码：<br>TaskSnapshotController.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TaskSnapshotController(WindowManagerService service) &#123;</span><br><span class="line">    mService = service;</span><br><span class="line">    mPersister = new TaskSnapshotPersister(mService, Environment::getDataSystemCeDirectory);</span><br><span class="line">    mLoader = new TaskSnapshotLoader(mPersister);</span><br><span class="line">    mCache = new TaskSnapshotCache(mService, mLoader);</span><br><span class="line">    mIsRunningOnTv = mService.mContext.getPackageManager().hasSystemFeature(</span><br><span class="line">            PackageManager.FEATURE_LEANBACK);</span><br><span class="line">    mIsRunningOnIoT = mService.mContext.getPackageManager().hasSystemFeature(</span><br><span class="line">            PackageManager.FEATURE_EMBEDDED);</span><br><span class="line">    mIsRunningOnWear = mService.mContext.getPackageManager().hasSystemFeature(</span><br><span class="line">        PackageManager.FEATURE_WATCH);</span><br><span class="line">    //配置的config_highResTaskSnapshotScale</span><br><span class="line">    mHighResTaskSnapshotScale = mService.mContext.getResources().getFloat(</span><br><span class="line">            com.android.internal.R.dimen.config_highResTaskSnapshotScale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TaskSnapshotPersister.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TaskSnapshotPersister(WindowManagerService service, DirectoryResolver resolver) &#123;</span><br><span class="line">    mDirectoryResolver = resolver;</span><br><span class="line">    mUserManagerInternal = LocalServices.getService(UserManagerInternal.class);</span><br><span class="line"></span><br><span class="line">    //拿到配置的config_highResTaskSnapshotScale</span><br><span class="line">    final float highResTaskSnapshotScale = service.mContext.getResources().getFloat(</span><br><span class="line">            com.android.internal.R.dimen.config_highResTaskSnapshotScale);</span><br><span class="line">    //拿到配置的config_lowResTaskSnapshotScale</span><br><span class="line">    final float lowResTaskSnapshotScale = service.mContext.getResources().getFloat(</span><br><span class="line">            com.android.internal.R.dimen.config_lowResTaskSnapshotScale);</span><br><span class="line"></span><br><span class="line">    if (lowResTaskSnapshotScale &lt; 0 || 1 &lt;= lowResTaskSnapshotScale) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Low-res scale must be between 0 and 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (highResTaskSnapshotScale &lt;= 0 || 1 &lt; highResTaskSnapshotScale) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;High-res scale must be between 0 and 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (highResTaskSnapshotScale &lt;= lowResTaskSnapshotScale) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;High-res scale must be greater than low-res scale&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (lowResTaskSnapshotScale &gt; 0) &#123;</span><br><span class="line">        //计算 低分辨率值 与 高分辨率值 的比例</span><br><span class="line">        mLowResScaleFactor = lowResTaskSnapshotScale / highResTaskSnapshotScale;</span><br><span class="line">        mEnableLowResSnapshots = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mLowResScaleFactor = 0;</span><br><span class="line">        mEnableLowResSnapshots = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据config_use16BitTaskSnapshotPixelFormat判断是否用16位像素来节省内存</span><br><span class="line">    mUse16BitFormat = service.mContext.getResources().getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_use16BitTaskSnapshotPixelFormat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快照截取流程"><a href="#快照截取流程" class="headerlink" title="快照截取流程"></a>快照截取流程</h2><p>主要是调用snapshotTask，去获取TaskSnapshot</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void snapshotTasks(ArraySet&lt;Task&gt; tasks, boolean allowSnapshotHome) &#123;</span><br><span class="line">    for (int i = tasks.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        final Task task = tasks.valueAt(i);</span><br><span class="line">        final TaskSnapshot snapshot;</span><br><span class="line">        final boolean snapshotHome = allowSnapshotHome &amp;&amp; task.isActivityTypeHome();</span><br><span class="line">        if (snapshotHome) &#123;</span><br><span class="line">            snapshot = snapshotTask(task);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            switch (getSnapshotMode(task)) &#123;</span><br><span class="line">                case SNAPSHOT_MODE_NONE:</span><br><span class="line">                    continue;</span><br><span class="line">                case SNAPSHOT_MODE_APP_THEME:</span><br><span class="line">                    snapshot = drawAppThemeSnapshot(task);</span><br><span class="line">                    break;</span><br><span class="line">                case SNAPSHOT_MODE_REAL:</span><br><span class="line">                    snapshot = snapshotTask(task);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    snapshot = null;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (snapshot != null) &#123;</span><br><span class="line">            final GraphicBuffer buffer = snapshot.getSnapshot();</span><br><span class="line">            if (buffer.getWidth() == 0 || buffer.getHeight() == 0) &#123;</span><br><span class="line">                buffer.destroy();</span><br><span class="line">                Slog.e(TAG, &quot;Invalid task snapshot dimensions &quot; + buffer.getWidth() + &quot;x&quot;</span><br><span class="line">                        + buffer.getHeight());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //有正常的buffer，会先将其保存在TaskSnapshotCache，后面调用getSnapshot时去取出来</span><br><span class="line">                mCache.putSnapshot(task, snapshot);</span><br><span class="line">                // Don&#x27;t persist or notify the change for the temporal snapshot.</span><br><span class="line">                if (!snapshotHome) &#123;</span><br><span class="line">                    //这是进行持久化存储，会将bitmap保存为图片在/data/system_ce/&lt;userid&gt;/snapshots/ 下面</span><br><span class="line">                    mPersister.persistSnapshot(task.mTaskId, task.mUserId, snapshot);</span><br><span class="line">                    task.onSnapshotChanged(snapshot);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快照的显示隐藏"><a href="#快照的显示隐藏" class="headerlink" title="快照的显示隐藏"></a>快照的显示隐藏</h2><p>在启动Activity的时候，会去找快照，找到就会进行显示<br>ActivityStarter.executeRequest<br>    ActivityStarter.startActivityUnchecked<br>        ActivityStarter.startActivityInner<br>在startActivityInner内部会去找要启动的Activity，如果从缓存中找到对应的Activity会进行复用，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int startActivityInner()&#123;</span><br><span class="line">    //......</span><br><span class="line">            if (targetTaskTop != null) &#123;</span><br><span class="line">        // Recycle the target task for this launch.</span><br><span class="line">        startResult = recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);</span><br><span class="line">        if (startResult != START_SUCCESS) &#123;</span><br><span class="line">            return startResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mAddingToTask = true;</span><br><span class="line">    &#125;</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int recycleTask()&#123;</span><br><span class="line">    //......</span><br><span class="line">    if (mMovedToFront) &#123;</span><br><span class="line">        // We moved the task to front, use starting window to hide initial drawn delay.</span><br><span class="line">        //关键点在这里，调用ActivityRecord的showStartingWindow</span><br><span class="line">        targetTaskTop.showStartingWindow(null /* prev */, false /* newTask */,</span><br><span class="line">                true /* taskSwitch */);</span><br><span class="line">    &#125; else if (mDoResume) &#123;</span><br><span class="line">        // Make sure the stack and its belonging display are moved to topmost.</span><br><span class="line">        mTargetStack.moveToFront(&quot;intentActivityFound&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //......        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即在进行从后台切换到前台的时候，会调用目标ActvityRecord的showStartingWindow</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void showStartingWindow(ActivityRecord prev, boolean newTask, boolean taskSwitch) &#123;</span><br><span class="line">    //......</span><br><span class="line">    //这里去添加StartingWindow，这里的allowTaskSnapshot()可以控制是否显示快照，</span><br><span class="line">    //原生逻辑针对同一个Activity收到不同intent时，不显示快照</span><br><span class="line">    final boolean shown = addStartingWindow(packageName, theme,</span><br><span class="line">            compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags,</span><br><span class="line">            prev != null ? prev.appToken : null, newTask, taskSwitch, isProcessRunning(),</span><br><span class="line">            allowTaskSnapshot(),</span><br><span class="line">            mState.ordinal() &gt;= STARTED.ordinal() &amp;&amp; mState.ordinal() &lt;= STOPPED.ordinal());</span><br><span class="line">    if (shown) &#123;</span><br><span class="line">        mStartingWindowState = STARTING_WINDOW_SHOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean addStartingWindow()&#123;</span><br><span class="line">    //......</span><br><span class="line">    //这里从TaskSnapshotController中取出快照</span><br><span class="line">    final ActivityManager.TaskSnapshot snapshot =</span><br><span class="line">            mWmService.mTaskSnapshotController.getSnapshot(task.mTaskId, task.mUserId,</span><br><span class="line">                    false /* restoreFromDisk */, false /* isLowResolution */);</span><br><span class="line">    //判断启动窗口的类型（主要是 快照类型 和 闪屏类型），后续根据类型来创建对应的启动窗口</span><br><span class="line">    final int type = getStartingWindowType(newTask, taskSwitch, processRunning,</span><br><span class="line">            allowTaskSnapshot, activityCreated, snapshot);</span><br><span class="line"></span><br><span class="line">    if (type == STARTING_WINDOW_TYPE_SNAPSHOT) &#123;</span><br><span class="line">        if (isActivityTypeHome()) &#123;</span><br><span class="line">            // The snapshot of home is only used once because it won&#x27;t be updated while screen</span><br><span class="line">            // is on (see &#123;@link TaskSnapshotController#screenTurningOff&#125;).</span><br><span class="line">            mWmService.mTaskSnapshotController.removeSnapshotCache(task.mTaskId);</span><br><span class="line">            if ((mDisplayContent.mAppTransition.getTransitFlags()</span><br><span class="line">                    &amp; WindowManager.TRANSIT_FLAG_KEYGUARD_GOING_AWAY_NO_ANIMATION) == 0) &#123;</span><br><span class="line">                // Only use snapshot of home as starting window when unlocking directly.</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //这里就去创建快照窗口了</span><br><span class="line">        return createSnapshot(snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">    //......        </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">private int getStartingWindowType(boolean newTask, boolean taskSwitch, boolean processRunning,</span><br><span class="line">        boolean allowTaskSnapshot, boolean activityCreated,</span><br><span class="line">        ActivityManager.TaskSnapshot snapshot) &#123;</span><br><span class="line">    if (newTask || !processRunning || (taskSwitch &amp;&amp; !activityCreated)) &#123;</span><br><span class="line">        return STARTING_WINDOW_TYPE_SPLASH_SCREEN;</span><br><span class="line">    &#125; else if (taskSwitch &amp;&amp; allowTaskSnapshot) &#123;</span><br><span class="line">        //这里可以看到只有是task切换，并且允许快照的情况下，才有机会返回快照类型</span><br><span class="line">        if (isSnapshotCompatible(snapshot)) &#123;</span><br><span class="line">            return STARTING_WINDOW_TYPE_SNAPSHOT;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!isActivityTypeHome()) &#123;</span><br><span class="line">            return STARTING_WINDOW_TYPE_SPLASH_SCREEN;</span><br><span class="line">        &#125;</span><br><span class="line">        return STARTING_WINDOW_TYPE_NONE;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return STARTING_WINDOW_TYPE_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return Whether a task snapshot starting window may be shown.</span><br><span class="line"> */</span><br><span class="line">private boolean allowTaskSnapshot() &#123;</span><br><span class="line"></span><br><span class="line">    if (newIntents == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Restrict task snapshot starting window to launcher start, or is same as the last</span><br><span class="line">    // delivered intent, or there is no intent at all (eg. task being brought to front). If</span><br><span class="line">    // the intent is something else, likely the app is going to show some specific page or</span><br><span class="line">    // view, instead of what&#x27;s left last time.</span><br><span class="line">    for (int i = newIntents.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        final Intent intent = newIntents.get(i);</span><br><span class="line">        if (intent == null || ActivityRecord.isMainIntent(intent)) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean sameIntent = mLastNewIntent != null ? mLastNewIntent.filterEquals(intent)</span><br><span class="line">                : this.intent.filterEquals(intent);</span><br><span class="line">        //如果意图是其他内容，说明将显示某个特定的页面或视图，而不是上次留下的内容，这里就不显示快照</span><br><span class="line">        if (!sameIntent || intent.getExtras() != null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>
<p>接下来看看快照具体添加流程createSnapshot</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean createSnapshot(ActivityManager.TaskSnapshot snapshot) &#123;</span><br><span class="line">    if (snapshot == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProtoLog.v(WM_DEBUG_STARTING_WINDOW, &quot;Creating SnapshotStartingData&quot;);</span><br><span class="line">    //将快照截图传给构造方法，创建了一个SnapshotStartingData</span><br><span class="line">    mStartingData = new SnapshotStartingData(mWmService, snapshot);</span><br><span class="line">    //通过postAtFrontOfQueue把快照显示尽可能提前</span><br><span class="line">    scheduleAddStartingWindow();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void scheduleAddStartingWindow() &#123;</span><br><span class="line">    // Note: we really want to do sendMessageAtFrontOfQueue() because we</span><br><span class="line">    // want to process the message ASAP, before any other queued</span><br><span class="line">    // messages.</span><br><span class="line">    if (!mWmService.mAnimationHandler.hasCallbacks(mAddStartingWindow)) &#123;</span><br><span class="line">        ProtoLog.v(WM_DEBUG_STARTING_WINDOW, &quot;Enqueueing ADD_STARTING&quot;);</span><br><span class="line">        mWmService.mAnimationHandler.postAtFrontOfQueue(mAddStartingWindow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class AddStartingWindow implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        WindowManagerPolicy.StartingSurface surface = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //这里是用之前创建好的SnapshotStartingData调用createStartingSurface</span><br><span class="line">            //内部调用的TaskSnapshotController的createStartingSurface</span><br><span class="line">            //返回一个StartingSurface，这个会被保存为全局变量，后续移除会用到</span><br><span class="line">            surface = startingData.createStartingSurface(ActivityRecord.this);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Exception when adding starting window&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        //......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">StartingSurface createStartingSurface(ActivityRecord activity) &#123;</span><br><span class="line">    return mService.mTaskSnapshotController.createStartingSurface(activity, mSnapshot);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">StartingSurface createStartingSurface(ActivityRecord activity,</span><br><span class="line">        TaskSnapshot snapshot) &#123;</span><br><span class="line">    return TaskSnapshotSurface.create(mService, activity, snapshot);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>最终快照弹窗的创建，就看TaskSnapshotSurface中的create</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final String TITLE_FORMAT = &quot;SnapshotStartingWindow for taskId=%s&quot;;</span><br><span class="line"></span><br><span class="line">static TaskSnapshotSurface create(WindowManagerService service, ActivityRecord activity,</span><br><span class="line">        TaskSnapshot snapshot) &#123;</span><br><span class="line"></span><br><span class="line">    //......构造一个window,标题为 SnapshotStartingWindow for taskId=xxx</span><br><span class="line">    layoutParams.setTitle(String.format(TITLE_FORMAT, task.mTaskId));</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //将创建好的window添加到屏幕进行显示</span><br><span class="line">        final int res = session.addToDisplay(window, window.mSeq, layoutParams,</span><br><span class="line">                View.GONE, activity.getDisplayContent().getDisplayId(), tmpFrame, tmpRect,</span><br><span class="line">                tmpRect, tmpCutout, null, mTmpInsetsState, mTempControls);</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Failed to add snapshot starting window res=&quot; + res);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        // Local call.</span><br><span class="line">    &#125;</span><br><span class="line">    final TaskSnapshotSurface snapshotSurface = new TaskSnapshotSurface(service, window,</span><br><span class="line">            surfaceControl, snapshot, layoutParams.getTitle(), taskDescription, sysUiVis,</span><br><span class="line">            windowFlags, windowPrivateFlags, taskBounds, currentOrientation, activityType,</span><br><span class="line">            insetsState);</span><br><span class="line">    window.setOuter(snapshotSurface);</span><br><span class="line">    try &#123;</span><br><span class="line">        session.relayout(window, window.mSeq, layoutParams, -1, -1, View.VISIBLE, 0, -1,</span><br><span class="line">                tmpFrame, tmpContentInsets, tmpRect, tmpStableInsets, tmpRect,</span><br><span class="line">                tmpCutout, tmpMergedConfiguration, surfaceControl, mTmpInsetsState,</span><br><span class="line">                mTempControls, sTmpSurfaceSize, sTmpSurfaceControl);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        // Local call.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Rect systemBarInsets = getSystemBarInsets(tmpFrame, insetsState);</span><br><span class="line">    snapshotSurface.setFrames(tmpFrame, systemBarInsets);</span><br><span class="line">    snapshotSurface.drawSnapshot();</span><br><span class="line">    return snapshotSurface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后显示的快照移除的时机，在ActivityRecord中的onFirstWindowDrawn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void onFirstWindowDrawn(WindowState win, WindowStateAnimator winAnimator) &#123;</span><br><span class="line">    firstWindowDrawn = true;</span><br><span class="line"></span><br><span class="line">    // We now have a good window to show, remove dead placeholders</span><br><span class="line">    removeDeadWindows();</span><br><span class="line"></span><br><span class="line">    if (startingWindow != null) &#123;</span><br><span class="line">        ProtoLog.v(WM_DEBUG_STARTING_WINDOW, &quot;Finish starting %s&quot;</span><br><span class="line">                + &quot;: first real window is shown, no animation&quot;, win.mToken);</span><br><span class="line">        // If this initial window is animating, stop it -- we will do an animation to reveal</span><br><span class="line">        // it from behind the starting window, so there is no need for it to also be doing its</span><br><span class="line">        // own stuff.</span><br><span class="line">        win.cancelAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">    removeStartingWindow();</span><br><span class="line">    updateReportedVisibilityLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void removeStartingWindow() &#123;</span><br><span class="line"></span><br><span class="line">    // Use the same thread to remove the window as we used to add it, as otherwise we end up</span><br><span class="line">    // with things in the view hierarchy being called from different threads.</span><br><span class="line">    mWmService.mAnimationHandler.post(() -&gt; &#123;</span><br><span class="line">        ProtoLog.v(WM_DEBUG_STARTING_WINDOW, &quot;Removing startingView=%s&quot;, surface);</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建快照截图时返回的StartingSurface，现在调用StartingSurface的remove方法（TaskSnapshotSurface的remove）</span><br><span class="line">            surface.remove();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Slog.w(TAG_WM, &quot;Exception when removing starting window&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>TaskSnapshotSurface</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    //......</span><br><span class="line">    try &#123;</span><br><span class="line">        ProtoLog.v(WM_DEBUG_STARTING_WINDOW, &quot;Removing snapshot surface&quot;);</span><br><span class="line">        //就是直接将window移除</span><br><span class="line">        mSession.remove(mWindow);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        // Local call.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="关于屏幕截图"><a href="#关于屏幕截图" class="headerlink" title="关于屏幕截图"></a>关于屏幕截图</h2><p>查看screencap的源码，调用的ScreenshotClient::capture<br>对应SurfaceControl中的nativeScreenshot也调用了此方法，发现在SurfaceControl中有截图的静态方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @see SurfaceControl#screenshot(Rect, int, int, boolean, int)</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">public static Bitmap screenshot(Rect sourceCrop, int width, int height, int rotation) &#123;</span><br><span class="line">    return screenshot(sourceCrop, width, height, false, rotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>临时问题记录</title>
    <url>/2024/07/03/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/10.%E4%B8%B4%E6%97%B6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="输入法层级"><a href="#输入法层级" class="headerlink" title="输入法层级"></a>输入法层级</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private void updateImeParent() &#123;</span><br><span class="line">    final SurfaceControl newParent = computeImeParent();</span><br><span class="line">    if (newParent != null) &#123;</span><br><span class="line">        getPendingTransaction().reparent(mImeWindowsContainers.mSurfaceControl, newParent);</span><br><span class="line">        scheduleAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@VisibleForTesting</span><br><span class="line">SurfaceControl computeImeParent() &#123;</span><br><span class="line">    // Force attaching IME to the display when magnifying, or it would be magnified with</span><br><span class="line">    // target app together.</span><br><span class="line">    </span><br><span class="line">    final boolean allowAttachToApp = (mMagnificationSpec == null) &amp;&amp; allowReparentIme();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // Attach it to app if the target is part of an app and such app is covering the entire</span><br><span class="line">    // screen. If it&#x27;s not covering the entire screen the IME might extend beyond the apps</span><br><span class="line">    // bounds.</span><br><span class="line">    if (allowAttachToApp &amp;&amp; isImeAttachedToApp()) &#123;</span><br><span class="line">        return mInputMethodTarget.mActivityRecord.getSurfaceControl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Otherwise, we just attach it to where the display area policy put it.</span><br><span class="line">    return mImeWindowsContainers.getParent().getSurfaceControl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class WindowContainers extends DisplayChildWindowContainer&lt;WindowContainer&gt; &#123;</span><br><span class="line">    //......</span><br><span class="line">    @Override</span><br><span class="line">    void assignChildLayers(SurfaceControl.Transaction t) &#123;</span><br><span class="line">        mImeWindowsContainers.setNeedsLayer();</span><br><span class="line"></span><br><span class="line">        mRootDisplayArea.assignLayer(t, 0);</span><br><span class="line"></span><br><span class="line">        final WindowState imeTarget = mInputMethodTarget;</span><br><span class="line">        // In the case where we have an IME target that is not in split-screen mode IME</span><br><span class="line">        // assignment is easy. We just need the IME to go directly above the target. This way</span><br><span class="line">        // children of the target will naturally go above the IME and everyone is happy.</span><br><span class="line">        //</span><br><span class="line">        // In the case of split-screen windowing mode, we need to elevate the IME above the</span><br><span class="line">        // docked divider while keeping the app itself below the docked divider, so instead</span><br><span class="line">        // we use relative layering of the IME targets child windows, and place the IME in</span><br><span class="line">        // the non-app layer (see &#123;@link AboveAppWindowContainers#assignChildLayers&#125;).</span><br><span class="line">        //</span><br><span class="line">        // In the case the IME target is animating, the animation Z order may be different</span><br><span class="line">        // than the WindowContainer Z order, so it&#x27;s difficult to be sure we have the correct</span><br><span class="line">        // IME target. In this case we just layer the IME over all transitions by placing it</span><br><span class="line">        // in the above applications layer.</span><br><span class="line">        //</span><br><span class="line">        // In the case where we have no IME target we assign it where its base layer would</span><br><span class="line">        // place it in the AboveAppWindowContainers.</span><br><span class="line">        //</span><br><span class="line">        // Keep IME window in mAboveAppWindowsContainers as long as app&#x27;s starting window</span><br><span class="line">        // exists so it get&#x27;s layered above the starting window.</span><br><span class="line">        if (imeTarget != null &amp;&amp; !(imeTarget.mActivityRecord != null</span><br><span class="line">                &amp;&amp; imeTarget.mActivityRecord.hasStartingWindow()) &amp;&amp; (</span><br><span class="line">                !(imeTarget.inMultiWindowMode()</span><br><span class="line">                        || imeTarget.mToken.isAppTransitioning()) &amp;&amp; (</span><br><span class="line">                        imeTarget.getSurfaceControl() != null)) &amp;&amp; allowReparentIme()) &#123;</span><br><span class="line">            mImeWindowsContainers.assignRelativeLayer(t, imeTarget.getSurfaceControl(),</span><br><span class="line">                    // TODO: We need to use an extra level on the app surface to ensure</span><br><span class="line">                    // this is always above SurfaceView but always below attached window.</span><br><span class="line">                    1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Above we have assigned layers to our children, now we ask them to assign</span><br><span class="line">        // layers to their children.</span><br><span class="line">        mRootDisplayArea.assignChildLayers(t);</span><br><span class="line">    &#125;</span><br><span class="line">    //......</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 原生逻辑每次都会根据mInputMethodTarget来重新设置输入法的parent</span><br><span class="line"> * 新增逻辑：</span><br><span class="line"> * 固定mImeWindowsContainers的层级</span><br><span class="line"> * 当mInputMethodTarget的层级比mImeWindowsContainers的层级更高的时候才走原生逻辑</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">private boolean allowReparentIme() &#123;</span><br><span class="line">    if (mInputMethodTarget == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取到唤起输入法的window所在的layer</span><br><span class="line">    int imeTargetLayer = mInputMethodTarget.mToken.getWindowLayerFromType();</span><br><span class="line">    WindowManagerPolicy policy = mWmService.mPolicy;</span><br><span class="line">    int imeLayer = policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD);</span><br><span class="line">    return imeTargetLayer &gt;= imeLayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于Activity的启动源"><a href="#关于Activity的启动源" class="headerlink" title="关于Activity的启动源"></a>关于Activity的启动源</h2><p>在启动Activity的时候，会传入context，并取到packageName给ATMS，<br>通过ActivityStarter的setCallingPackage保存在mRequest.callingPackage，<br>在AMS创建ActivityRecord的时候，保存到ActivityRecord的launchedFromPackage字段中，<br>在去launch activity的时候，会创建LaunchActivityItem，将ActivityRecord的launchedFromPackage赋值给mReferrer，<br>最终在LaunchActivityItem execute构造ActivityClientRecord的时候，赋值给ActivityClientRecord的referrer，<br>在Activity attach的时候传给Activity的mReferrer,可以通过接口getReferrer()获取</p>
<p>但是getReferrer这个方法内部是先去获取Intent中一些特殊额外值，为空的情况下才返回mReferrer。</p>
<h2 id="UserManagerService的初始化"><a href="#UserManagerService的初始化" class="headerlink" title="UserManagerService的初始化"></a>UserManagerService的初始化</h2><p>在PKMS中构造的实例<br>在AMS 的systemReady中调用UMS的onSystemReady</p>
<p>UMS也做了本地持久化存储的 用户信息保存在&#x2F;data&#x2F;system&#x2F;users&#x2F;userlist.xml中，在UMS的构造函数中会去读取</p>
<p>dumpsys activity recents</p>
<p>dumpsys activity starter</p>
<p>在第一次开机的时候会去启动一个特殊的Activity:<code>com.android.provision/.DefaultActivity</code>只是向SettingProvider中写了一些值，<br>用来标记设备已经完成初始化，然后就会调用PMS来禁用这个Activity</p>
<h2 id="启动耗时统计"><a href="#启动耗时统计" class="headerlink" title="启动耗时统计"></a>启动耗时统计</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -rni &quot;SystemServerTiming:&quot;|grep -i &quot; took to complete:&quot;|awk &#x27;FS=&quot;SystemServerTiming:&quot;&#123;print$2&#125;&#x27;|awk &#x27;FS=&quot;took to complete:&quot;&#123;print $1 $2&#125;&#x27;&gt; timing.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys user</span><br></pre></td></tr></table></figure>

<p>ApplicationInfo中会根据userId重新生成uid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** &#123;@hide&#125; */</span><br><span class="line">public void initForUser(int userId) &#123;</span><br><span class="line">    uid = UserHandle.getUid(userId, UserHandle.getAppId(uid));</span><br><span class="line"></span><br><span class="line">    if (&quot;android&quot;.equals(packageName)) &#123;</span><br><span class="line">        dataDir = Environment.getDataSystemDirectory().getAbsolutePath();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deviceProtectedDataDir = Environment</span><br><span class="line">            .getDataUserDePackageDirectory(volumeUuid, userId, packageName)</span><br><span class="line">            .getAbsolutePath();</span><br><span class="line">    credentialProtectedDataDir = Environment</span><br><span class="line">            .getDataUserCePackageDirectory(volumeUuid, userId, packageName)</span><br><span class="line">            .getAbsolutePath();</span><br><span class="line"></span><br><span class="line">    if ((privateFlags &amp; PRIVATE_FLAG_DEFAULT_TO_DEVICE_PROTECTED_STORAGE) != 0</span><br><span class="line">            &amp;&amp; PackageManager.APPLY_DEFAULT_TO_DEVICE_PROTECTED_STORAGE) &#123;</span><br><span class="line">        dataDir = deviceProtectedDataDir;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dataDir = credentialProtectedDataDir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="windowstate-的-flag丢失"><a href="#windowstate-的-flag丢失" class="headerlink" title="windowstate 的 flag丢失"></a>windowstate 的 flag丢失</h2><p>app端和systemserver不同步<br>在ViewRootImpl中，每次performTraversals会去relayoutWindow，<br>这时候会将layoutparams丢给WindowSession去relayout，最后在wms中会去将app端的LayoutParams进行拷贝，<br>flag是保存在app端的，不建议在system server端对flag进行赋值计算，很容易和app端的数据因为不同步导致业务异常</p>
<h2 id="WebViewFactory抛出异常"><a href="#WebViewFactory抛出异常" class="headerlink" title="WebViewFactory抛出异常"></a>WebViewFactory抛出异常</h2><p>在原生逻辑中不允许系统特权app使用webView，不过多用户下，非U0用户下SYSTEM_UID的进程获取到的uid是1001000,不会抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">static WebViewFactoryProvider getProvider() &#123;</span><br><span class="line">    synchronized (sProviderLock) &#123;</span><br><span class="line">        // For now the main purpose of this function (and the factory abstraction) is to keep</span><br><span class="line">        // us honest and minimize usage of WebView internals when binding the proxy.</span><br><span class="line">        if (sProviderInstance != null) return sProviderInstance;</span><br><span class="line"></span><br><span class="line">        final int uid = android.os.Process.myUid();</span><br><span class="line">        if (uid == android.os.Process.ROOT_UID || uid == android.os.Process.SYSTEM_UID</span><br><span class="line">                || uid == android.os.Process.PHONE_UID || uid == android.os.Process.NFC_UID</span><br><span class="line">                || uid == android.os.Process.BLUETOOTH_UID) &#123;</span><br><span class="line">            throw new UnsupportedOperationException(</span><br><span class="line">                    &quot;For security reasons, WebView is not allowed in privileged processes&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //......</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>再ActivityStarter的execute中，根据intent会去找对应的Activity</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (mRequest.activityInfo == null) &#123;</span><br><span class="line">    mRequest.resolveActivity(mSupervisor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityStackSupervisor.resolveIntent<br>    PackageManagerInternal.resolveIntent</p>
<pre><code>PMS中queryIntentActivitiesInternal
ComponentResolver.queryActivities
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o remount,rw /system</span><br></pre></td></tr></table></figure>

<p>no permissions (missing udev rules? user is in the plugdev group)<br><a href="https://blog.csdn.net/weixin_45423659/article/details/137929767">https://blog.csdn.net/weixin_45423659/article/details/137929767</a></p>
<p>soong_config配置条件编译：<br><a href="https://blog.csdn.net/FranzKafka95/article/details/136002469">https://blog.csdn.net/FranzKafka95/article/details/136002469</a></p>
<p>Deleting system pkg from data partition</p>
<p>PhoneWindow中的mContentParent是DecorView中id为content的ViewGroup<br>在PhoneWindow中的generateLayout的时候调用DecorView的onResourcesLoaded去实例化布局，并添加到DecorView中的，mContentRoot是Decorview的直接子布局</p>
<p>Window的显示隐藏通过SurfaceControl控制</p>
<p>soong_config_module_type</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soong_config_module_type &#123;</span><br><span class="line">    //定义</span><br><span class="line">    name: &quot;project_java_defaults&quot;,</span><br><span class="line"></span><br><span class="line">    module_type: &quot;java_defaults&quot;,</span><br><span class="line"></span><br><span class="line">    config_namespace: &quot;coc&quot;,</span><br><span class="line"></span><br><span class="line">    variables: [&quot;project_name&quot;],</span><br><span class="line"></span><br><span class="line">    properties: [</span><br><span class="line">        &quot;srcs&quot;,</span><br><span class="line">        &quot;resource_dirs&quot;,</span><br><span class="line">        &quot;asset_dirs&quot;,</span><br><span class="line">        &quot;manifest&quot;,</span><br><span class="line">        &quot;libs&quot;,</span><br><span class="line">        &quot;jni_libs&quot;,</span><br><span class="line">        &quot;static_libs&quot;,</span><br><span class="line">        &quot;plugins&quot;,</span><br><span class="line">        &quot;aidl&quot;,</span><br><span class="line">        &quot;aaptflags&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>notifyActivityLaunching<br>notifyActivityLaunched<br>    notifyActivityLaunched resultCode&#x3D;0<br>    Add pending draw<br>    notifyActivityLaunched successful<br>notifyVisibilityChanged<br>    Remove pending draw(if visible&#x3D;false||finishing&#x3D;true)<br>notifyTransitionStarting<br>notifyWindowsDrawn<br>    Remove pending draw</p>
<p>persistent属性会写入文件<code>/data/property/persistent_properties</code></p>
<p>第一次开机启动会有log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UserManagerService: Reviewing whitelisted packages due to [firstBoot]</span><br></pre></td></tr></table></figure>


<p>常用头文件<br>log:liblog</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;log/log.h&gt;</span><br><span class="line"></span><br><span class="line">ALOGI(&quot;main start&quot;);</span><br></pre></td></tr></table></figure>
<p>proto:libprotobuf-cpp-full</p>
<p>属性:libcutils</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cutils/properties.h&gt;</span><br><span class="line"></span><br><span class="line">int boot_completed = property_get_int32(&quot;sys.tmp.boot_completed&quot;, 0);</span><br></pre></td></tr></table></figure>


<h1 id="Caused-by-java-lang-ClassNotFoundException-Didn’t-find-class-“com-xxx-xxxApplication”"><a href="#Caused-by-java-lang-ClassNotFoundException-Didn’t-find-class-“com-xxx-xxxApplication”" class="headerlink" title="Caused by: java.lang.ClassNotFoundException: Didn’t find class “com.xxx.xxxApplication”"></a>Caused by: java.lang.ClassNotFoundException: Didn’t find class “com.xxx.xxxApplication”</h1><p>在启动APP时直接crash了，实际反编译apk是有这个com.xxx.xxxApplication类的，需要看更下层的堆栈信息,<br>发现xxxApplication继承自SkinCompatApplication，但apk中没有SkinCompatApplication这个类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AndroidRuntime: Caused by: java.lang.ClassNotFoundException: Didn&#x27;t find class &quot;com.xxx.xxxApplication&quot; on path: DexPathList[[zip file &quot;/system/app/xxxServer/xxxServer.apk&quot;],nativeLibraryDirectories=[/system/app/xxxServer/lib/arm64, /system/app/xxxServer/xxxServer.apk!/lib/arm64-v8a, /system/lib64, /system/system_ext/lib64, /system/lib64, /system/system_ext/lib64]]</span><br><span class="line">AndroidRuntime: 	at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:207)</span><br><span class="line">AndroidRuntime: 	at java.lang.ClassLoader.loadClass(ClassLoader.java:379)</span><br><span class="line">AndroidRuntime: 	at java.lang.ClassLoader.loadClass(ClassLoader.java:312)</span><br><span class="line">AndroidRuntime: 	at android.app.AppComponentFactory.instantiateApplication(AppComponentFactory.java:76)</span><br><span class="line">AndroidRuntime: 	at androidx.core.app.CoreComponentFactory.instantiateApplication(CoreComponentFactory.java:52)</span><br><span class="line">AndroidRuntime: 	at android.app.Instrumentation.newApplication(Instrumentation.java:1158)</span><br><span class="line">AndroidRuntime: 	at android.app.LoadedApk.makeApplication(LoadedApk.java:1260)</span><br><span class="line">AndroidRuntime: 	... 9 more</span><br><span class="line">AndroidRuntime: 	Suppressed: java.lang.NoClassDefFoundError: Failed resolution of: Lskin/support/app/SkinCompatApplication;</span><br><span class="line">AndroidRuntime: 		at java.lang.VMClassLoader.findLoadedClass(Native Method)</span><br><span class="line">AndroidRuntime: 		at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:738)</span><br><span class="line">AndroidRuntime: 		at java.lang.ClassLoader.loadClass(ClassLoader.java:363)</span><br><span class="line">AndroidRuntime: 		... 14 more</span><br><span class="line">AndroidRuntime: 	Caused by: java.lang.ClassNotFoundException: skin.support.app.SkinCompatApplication</span><br><span class="line">AndroidRuntime: 		... 17 more</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="修改状态栏颜色-深色-浅色"><a href="#修改状态栏颜色-深色-浅色" class="headerlink" title="修改状态栏颜色(深色&#x2F;浅色)"></a>修改状态栏颜色(深色&#x2F;浅色)</h2><p>第一种可以通过在xml中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;item name=&quot;android:windowLightStatusBar&quot;&gt;true&lt;/item&gt;</span><br></pre></td></tr></table></figure>
<p>这种方式其实是通过设置SystemUiVisibility实现的<br>在PhoneWindow中有对应逻辑:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</span><br><span class="line">    //......</span><br><span class="line">    if (a.getBoolean(R.styleable.Window_windowLightStatusBar, false)) &#123;</span><br><span class="line">        decor.setSystemUiVisibility(</span><br><span class="line">                decor.getSystemUiVisibility() | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</span><br><span class="line">    &#125;       </span><br><span class="line">    //...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以第二种方式直接获取DecorView设置SystemUiVisibility</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//浅色状态栏，字体黑色</span><br><span class="line">getWindow().getDecorView().setSystemUiVisibility(SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</span><br><span class="line">//深色状态栏，字体白色</span><br><span class="line">getWindow().getDecorView().setSystemUiVisibility(0);</span><br></pre></td></tr></table></figure>

<p>还有第三种方式，通过InsetsController来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//浅色状态栏，字体黑色</span><br><span class="line">getWindow().getInsetsController().setSystemBarsAppearance(WindowInsetsController.APPEARANCE_LIGHT_STATUS_BARS,WindowInsetsController.APPEARANCE_LIGHT_STATUS_BARS);</span><br><span class="line">//深色状态栏，字体白色</span><br><span class="line">getWindow().getInsetsController().setSystemBarsAppearance(0,WindowInsetsController.APPEARANCE_LIGHT_STATUS_BARS);</span><br></pre></td></tr></table></figure>
<p>在ViewRootInsetsControllerHost中是具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setSystemBarsAppearance(int appearance, int mask) &#123;</span><br><span class="line">    mViewRoot.mWindowAttributes.privateFlags |= PRIVATE_FLAG_APPEARANCE_CONTROLLED;</span><br><span class="line">    final InsetsFlags insetsFlags = mViewRoot.mWindowAttributes.insetsFlags;</span><br><span class="line">    //直接修改appearance的值</span><br><span class="line">    if (insetsFlags.appearance != appearance) &#123;</span><br><span class="line">        insetsFlags.appearance = (insetsFlags.appearance &amp; ~mask) | (appearance &amp; mask);</span><br><span class="line">        mViewRoot.mWindowAttributesChanged = true;</span><br><span class="line">        mViewRoot.scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且在ViewRootImpl.java的adjustLayoutParamsForCompatibility方法中，判断了PRIVATE_FLAG_APPEARANCE_CONTROLLED这个flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void adjustLayoutParamsForCompatibility(WindowManager.LayoutParams inOutParams) &#123;</span><br><span class="line">    //......</span><br><span class="line">    final int sysUiVis = inOutParams.systemUiVisibility | inOutParams.subtreeSystemUiVisibility;</span><br><span class="line">    //......</span><br><span class="line">    //这里的逻辑是没有PRIVATE_FLAG_APPEARANCE_CONTROLLED就去判断sysUiVis的值</span><br><span class="line">    //也就是说没有调用setSystemBarsAppearance，会去根据systemUiVisibility来重新设置值</span><br><span class="line">    if ((inOutParams.privateFlags &amp; PRIVATE_FLAG_APPEARANCE_CONTROLLED) == 0) &#123;</span><br><span class="line">        inOutParams.insetsFlags.appearance = 0;</span><br><span class="line">        if ((sysUiVis &amp; SYSTEM_UI_FLAG_LOW_PROFILE) != 0) &#123;</span><br><span class="line">            inOutParams.insetsFlags.appearance |= APPEARANCE_LOW_PROFILE_BARS;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((sysUiVis &amp; SYSTEM_UI_FLAG_LIGHT_STATUS_BAR) != 0) &#123;</span><br><span class="line">            inOutParams.insetsFlags.appearance |= APPEARANCE_LIGHT_STATUS_BARS;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((sysUiVis &amp; SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR) != 0) &#123;</span><br><span class="line">            inOutParams.insetsFlags.appearance |= APPEARANCE_LIGHT_NAVIGATION_BARS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">    //...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以通过InsetsController的setSystemBarsAppearance优先级是最高的</p>
<h2 id="KEEP-SCREEN-ON"><a href="#KEEP-SCREEN-ON" class="headerlink" title="KEEP_SCREEN_ON"></a>KEEP_SCREEN_ON</h2><p>View中设置KEEP_SCREEN_ON后在performCollectViewAttributes时会将<br>attachInfo.mKeepScreenOn &#x3D; true;<br>在ViewRootImpl中的applyKeepScreenOnFlag回去给WindowManager的layoutparams加上flag：WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;</p>
<p>RootWindowContainer的handleNotObscuredLocked方法会去判断window是否有FLAG_KEEP_SCREEN_ON，<br>如果有FLAG_KEEP_SCREEN_ON，会将此window对应的session为mHoldScreen</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean handleNotObscuredLocked(WindowState w, boolean obscured, boolean syswin) &#123;</span><br><span class="line">    //......</span><br><span class="line">    //有surface,并且对用户可见</span><br><span class="line">    if (w.mHasSurface &amp;&amp; canBeSeen) &#123;</span><br><span class="line">        if ((attrFlags &amp; FLAG_KEEP_SCREEN_ON) != 0) &#123;</span><br><span class="line">            mHoldScreen = w.mSession;</span><br><span class="line">            mHoldScreenWindow = w;</span><br><span class="line">        &#125;         </span><br><span class="line">        //......</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每次刷新界面时，将mHoldScreen置空，中间会去计算拿到最新的mHoldScreen，然后调用WMS中的setHoldScreenLocked：</p>
<p>performSurfacePlacementNoTrace中 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void performSurfacePlacementNoTrace() &#123;</span><br><span class="line">    //......</span><br><span class="line">    mHoldScreen = null;  </span><br><span class="line">    //......</span><br><span class="line">    mWmService.openSurfaceTransaction();</span><br><span class="line">    try &#123;</span><br><span class="line">        //会去调用所有DisplayContent的applySurfaceChangesTransaction</span><br><span class="line">        applySurfaceChangesTransaction();</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        Slog.wtf(TAG, &quot;Unhandled exception in Window Manager&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mWmService.closeSurfaceTransaction(&quot;performLayoutAndPlaceSurfaces&quot;);</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,</span><br><span class="line">                &quot;&lt;&lt;&lt; CLOSE TRANSACTION performLayoutAndPlaceSurfaces&quot;);</span><br><span class="line">    &#125;       </span><br><span class="line">    //......</span><br><span class="line">    mWmService.setHoldScreenLocked(mHoldScreen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DisplayContent.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void applySurfaceChangesTransaction() &#123;</span><br><span class="line">    //......</span><br><span class="line">    try &#123;</span><br><span class="line">        forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">    prepareSurfaces();   </span><br><span class="line">    //......   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final Consumer&lt;WindowState&gt; mApplySurfaceChangesTransaction = w -&gt; &#123;</span><br><span class="line">        //......</span><br><span class="line">        //去调用RootWindowContainer的handleNotObscuredLocked</span><br><span class="line">        final boolean displayHasContent = root.handleNotObscuredLocked(w,</span><br><span class="line">                mTmpApplySurfaceChangesTransactionState.obscured,</span><br><span class="line">                mTmpApplySurfaceChangesTransactionState.syswin);</span><br><span class="line">        //......                    </span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>也就是说每次刷新都会判断前台对用户可见的window是否有FLAG_KEEP_SCREEN_ON，然后调用wms的setHoldScreenLocked接口<br>WMS:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setHoldScreenLocked(final Session newHoldScreen) &#123;</span><br><span class="line">    final boolean hold = newHoldScreen != null;</span><br><span class="line"></span><br><span class="line">    if (hold &amp;&amp; mHoldingScreenOn != newHoldScreen) &#123;</span><br><span class="line">        mHoldingScreenWakeLock.setWorkSource(new WorkSource(newHoldScreen.mUid));</span><br><span class="line">    &#125;</span><br><span class="line">    mHoldingScreenOn = newHoldScreen;</span><br><span class="line"></span><br><span class="line">    final boolean state = mHoldingScreenWakeLock.isHeld();</span><br><span class="line">    if (hold != state) &#123;</span><br><span class="line">        if (hold) &#123;</span><br><span class="line">            ProtoLog.d(WM_DEBUG_KEEP_SCREEN_ON, &quot;Acquiring screen wakelock due to %s&quot;,</span><br><span class="line">                        mRoot.mHoldScreenWindow);</span><br><span class="line">            mLastWakeLockHoldingWindow = mRoot.mHoldScreenWindow;</span><br><span class="line">            mLastWakeLockObscuringWindow = null;</span><br><span class="line">            mHoldingScreenWakeLock.acquire();</span><br><span class="line">            mPolicy.keepScreenOnStartedLw();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ProtoLog.d(WM_DEBUG_KEEP_SCREEN_ON, &quot;Releasing screen wakelock, obscured by %s&quot;,</span><br><span class="line">                        mRoot.mObscuringWindow);</span><br><span class="line">            mLastWakeLockHoldingWindow = null;</span><br><span class="line">            mLastWakeLockObscuringWindow = mRoot.mObscuringWindow;</span><br><span class="line">            mPolicy.keepScreenOnStoppedLw();</span><br><span class="line">            mHoldingScreenWakeLock.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="32位-64位"><a href="#32位-64位" class="headerlink" title="32位&#x2F;64位"></a>32位&#x2F;64位</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target: &#123;</span><br><span class="line">        android_arm: &#123;</span><br><span class="line">            enabled: false,</span><br><span class="line">        &#125;,</span><br><span class="line">        android_arm64: &#123;</span><br><span class="line">            enabled: true,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>



<p>升级Python后，无法通过Ctrl+Alt+T打开Terminal <a href="https://ost.51cto.com/answer/5250">https://ost.51cto.com/answer/5250</a></p>
<p>wm_task_created<br>wm_stack_created<br>wm_create_task     在ActivityStarter中的startActivityInner中，如果是新建的task就会有这个tag<br>wm_create_activity 也是在startActivityInner中，就在wm_create_task之后<br>wm_pause_activity<br>wm_on_top_resumed_lost_called<br>wm_on_paused_called<br>wm_add_to_stopping<br>wm_restart_activity  在realStartActivityLocked中，紧接着就会调用LaunchActivityItem的事件去调用ActivityThread中的handleLaunchActivity<br>wm_set_resumed_activity<br>    在setResumedActivityUncheckLocked中，在realStartActivityLocked中如果andResume，就会调用minimalResumeActivityLocked，调用setState设置成resumed，<br>    接着触发onActivityStateChanged，调用ATMS的setResumedActivityUncheckLocked<br>wm_on_create_called  在ActivityThread中的handleLaunchActivity中的performLaunchActivity<br>wm_on_start_called<br>wm_on_resume_called<br>wm_on_top_resumed_gained_called<br>wm_activity_launch_time<br>wm_stop_activity<br>wm_on_stop_called<br>wm_task_to_front</p>
<p><a href="https://segmentfault.com/q/1010000043161760">https://segmentfault.com/q/1010000043161760</a><br> adb shell pm grant your.package.name android.permission.WRITE_SECURE_SETTINGS</p>
<h2 id="关于设置属性值-setprop"><a href="#关于设置属性值-setprop" class="headerlink" title="关于设置属性值 setprop"></a>关于设置属性值 setprop</h2><p>进程最终都是通过libc与init进程的property_service进行通信，在bionic&#x2F;libc&#x2F;bionic&#x2F;system_property_set.cpp中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __system_property_set(const char* key, const char* value) &#123;</span><br><span class="line">  //......</span><br><span class="line">    // New protocol only allows long values for ro. properties only.</span><br><span class="line">    if (strlen(value) &gt;= PROP_VALUE_MAX &amp;&amp; strncmp(key, &quot;ro.&quot;, 3) != 0) return -1;</span><br><span class="line">    // Use proper protocol</span><br><span class="line">    PropertyServiceConnection connection;</span><br><span class="line">    if (!connection.IsValid()) &#123;</span><br><span class="line">      errno = connection.GetLastError();</span><br><span class="line">      async_safe_format_log(</span><br><span class="line">          ANDROID_LOG_WARN, &quot;libc&quot;,</span><br><span class="line">          &quot;Unable to set property \&quot;%s\&quot; to \&quot;%s\&quot;: connection failed; errno=%d (%s)&quot;, key, value,</span><br><span class="line">          errno, strerror(errno));</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SocketWriter writer(&amp;connection);</span><br><span class="line">    if (!writer.WriteUint32(PROP_MSG_SETPROP2).WriteString(key).WriteString(value).Send()) &#123;</span><br><span class="line">      errno = connection.GetLastError();</span><br><span class="line">      async_safe_format_log(ANDROID_LOG_WARN, &quot;libc&quot;,</span><br><span class="line">                            &quot;Unable to set property \&quot;%s\&quot; to \&quot;%s\&quot;: write failed; errno=%d (%s)&quot;,</span><br><span class="line">                            key, value, errno, strerror(errno));</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = -1;</span><br><span class="line">    if (!connection.RecvInt32(&amp;result)) &#123;</span><br><span class="line">      errno = connection.GetLastError();</span><br><span class="line">      async_safe_format_log(ANDROID_LOG_WARN, &quot;libc&quot;,</span><br><span class="line">                            &quot;Unable to set property \&quot;%s\&quot; to \&quot;%s\&quot;: recv failed; errno=%d (%s)&quot;,</span><br><span class="line">                            key, value, errno, strerror(errno));</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result != PROP_SUCCESS) &#123;</span><br><span class="line">      async_safe_format_log(ANDROID_LOG_WARN, &quot;libc&quot;,</span><br><span class="line">                            &quot;Unable to set property \&quot;%s\&quot; to \&quot;%s\&quot;: error code: 0x%x&quot;, key, value,</span><br><span class="line">                            result);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Android广播流程</title>
    <url>//pages/357eff/</url>
    <content><![CDATA[<p>广播从AMS的broadcastIntentLocked开始<br>在broadcastIntentLocked中一些逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage,</span><br><span class="line">            @Nullable String callerFeatureId, Intent intent, String resolvedType,</span><br><span class="line">            IIntentReceiver resultTo, int resultCode, String resultData,</span><br><span class="line">            Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions,</span><br><span class="line">            boolean ordered, boolean sticky, int callingPid, int callingUid, int realCallingUid,</span><br><span class="line">            int realCallingPid, int userId, boolean allowBackgroundActivityStarts,</span><br><span class="line">            @Nullable int[] broadcastWhitelist) &#123;</span><br><span class="line">        //...</span><br><span class="line"></span><br><span class="line">        //这里会去校验受保护的广播是否由系统发送的，并且系统进程只能发送受保护的广播</span><br><span class="line">        // Verify that protected broadcasts are only being sent by system code,</span><br><span class="line">        // and that system code is only sending protected broadcasts.</span><br><span class="line">        final boolean isProtectedBroadcast;</span><br><span class="line">        try &#123;</span><br><span class="line">            isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Remote exception&quot;, e);</span><br><span class="line">            return ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean isCallerSystem;</span><br><span class="line">        switch (UserHandle.getAppId(callingUid)) &#123;</span><br><span class="line">            case ROOT_UID:</span><br><span class="line">            case SYSTEM_UID:</span><br><span class="line">            case PHONE_UID:</span><br><span class="line">            case BLUETOOTH_UID:</span><br><span class="line">            case NFC_UID:</span><br><span class="line">            case SE_UID:</span><br><span class="line">            case NETWORK_STACK_UID:</span><br><span class="line">                isCallerSystem = true;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                isCallerSystem = (callerApp != null) &amp;&amp; callerApp.isPersistent();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // First line security check before anything else: stop non-system apps from</span><br><span class="line">        // sending protected broadcasts.</span><br><span class="line">        if (!isCallerSystem) &#123;</span><br><span class="line">            if (isProtectedBroadcast) &#123;</span><br><span class="line">                String msg = &quot;Permission Denial: not allowed to send broadcast &quot;</span><br><span class="line">                        + action + &quot; from pid=&quot;</span><br><span class="line">                        + callingPid + &quot;, uid=&quot; + callingUid;</span><br><span class="line">                Slog.w(TAG, msg);</span><br><span class="line">                throw new SecurityException(msg);</span><br><span class="line"></span><br><span class="line">            &#125; else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)</span><br><span class="line">                    || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) &#123;</span><br><span class="line">                // Special case for compatibility: we don&#x27;t want apps to send this,</span><br><span class="line">                // but historically it has not been protected and apps may be using it</span><br><span class="line">                // to poke their own app widget.  So, instead of making it protected,</span><br><span class="line">                // just limit it to the caller.</span><br><span class="line">                if (callerPackage == null) &#123;</span><br><span class="line">                    String msg = &quot;Permission Denial: not allowed to send broadcast &quot;</span><br><span class="line">                            + action + &quot; from unknown caller.&quot;;</span><br><span class="line">                    Slog.w(TAG, msg);</span><br><span class="line">                    throw new SecurityException(msg);</span><br><span class="line">                &#125; else if (intent.getComponent() != null) &#123;</span><br><span class="line">                    // They are good enough to send to an explicit component...  verify</span><br><span class="line">                    // it is being sent to the calling app.</span><br><span class="line">                    if (!intent.getComponent().getPackageName().equals(</span><br><span class="line">                            callerPackage)) &#123;</span><br><span class="line">                        String msg = &quot;Permission Denial: not allowed to send broadcast &quot;</span><br><span class="line">                                + action + &quot; to &quot;</span><br><span class="line">                                + intent.getComponent().getPackageName() + &quot; from &quot;</span><br><span class="line">                                + callerPackage;</span><br><span class="line">                        Slog.w(TAG, msg);</span><br><span class="line">                        throw new SecurityException(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Limit broadcast to their own package.</span><br><span class="line">                    intent.setPackage(callerPackage);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean timeoutExempt = false;</span><br><span class="line"></span><br><span class="line">        if (action != null) &#123;</span><br><span class="line">            if (getBackgroundLaunchBroadcasts().contains(action)) &#123;</span><br><span class="line">                if (DEBUG_BACKGROUND_CHECK) &#123;</span><br><span class="line">                    Slog.i(TAG, &quot;Broadcast action &quot; + action + &quot; forcing include-background&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (action) &#123;</span><br><span class="line">                case Intent.ACTION_UID_REMOVED:</span><br><span class="line">                case Intent.ACTION_PACKAGE_REMOVED:</span><br><span class="line">                case Intent.ACTION_PACKAGE_CHANGED:</span><br><span class="line">                case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:</span><br><span class="line">                case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:</span><br><span class="line">                case Intent.ACTION_PACKAGES_SUSPENDED:</span><br><span class="line">                case Intent.ACTION_PACKAGES_UNSUSPENDED:</span><br><span class="line">                    // Handle special intents: if this broadcast is from the package</span><br><span class="line">                    // manager about a package being removed, we need to remove all of</span><br><span class="line">                    // its activities from the history stack.</span><br><span class="line">                    if (checkComponentPermission(</span><br><span class="line">                            android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,</span><br><span class="line">                            callingPid, callingUid, -1, true)</span><br><span class="line">                            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                        String msg = &quot;Permission Denial: &quot; + intent.getAction()</span><br><span class="line">                                + &quot; broadcast from &quot; + callerPackage + &quot; (pid=&quot; + callingPid</span><br><span class="line">                                + &quot;, uid=&quot; + callingUid + &quot;)&quot;</span><br><span class="line">                                + &quot; requires &quot;</span><br><span class="line">                                + android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;</span><br><span class="line">                        Slog.w(TAG, msg);</span><br><span class="line">                        throw new SecurityException(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                    switch (action) &#123;</span><br><span class="line">                        case Intent.ACTION_UID_REMOVED:</span><br><span class="line">                            final int uid = getUidFromIntent(intent);</span><br><span class="line">                            if (uid &gt;= 0) &#123;</span><br><span class="line">                                mBatteryStatsService.removeUid(uid);</span><br><span class="line">                                if (intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) &#123;</span><br><span class="line">                                    mAppOpsService.resetAllModes(UserHandle.getUserId(uid),</span><br><span class="line">                                            intent.getStringExtra(Intent.EXTRA_PACKAGE_NAME));</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    mAppOpsService.uidRemoved(uid);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            break;</span><br><span class="line">                        case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:</span><br><span class="line">                            // If resources are unavailable just force stop all those packages</span><br><span class="line">                            // and flush the attribute cache as well.</span><br><span class="line">                            String list[] =</span><br><span class="line">                                    intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">                            if (list != null &amp;&amp; list.length &gt; 0) &#123;</span><br><span class="line">                                for (int i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">                                    forceStopPackageLocked(list[i], -1, false, true, true,</span><br><span class="line">                                            false, false, userId, &quot;storage unmount&quot;);</span><br><span class="line">                                &#125;</span><br><span class="line">                                mAtmInternal.cleanupRecentTasksForUser(UserHandle.USER_ALL);</span><br><span class="line">                                sendPackageBroadcastLocked(</span><br><span class="line">                                        ApplicationThreadConstants.EXTERNAL_STORAGE_UNAVAILABLE,</span><br><span class="line">                                        list, userId);</span><br><span class="line">                            &#125;</span><br><span class="line">                            break;</span><br><span class="line">                        case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:</span><br><span class="line">                            mAtmInternal.cleanupRecentTasksForUser(UserHandle.USER_ALL);</span><br><span class="line">                            break;</span><br><span class="line">                        case Intent.ACTION_PACKAGE_REMOVED:</span><br><span class="line">                        case Intent.ACTION_PACKAGE_CHANGED:</span><br><span class="line">                            Uri data = intent.getData();</span><br><span class="line">                            String ssp;</span><br><span class="line">                            if (data != null &amp;&amp; (ssp=data.getSchemeSpecificPart()) != null) &#123;</span><br><span class="line">                                boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);</span><br><span class="line">                                final boolean replacing =</span><br><span class="line">                                        intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);</span><br><span class="line">                                final boolean killProcess =</span><br><span class="line">                                        !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false);</span><br><span class="line">                                final boolean fullUninstall = removed &amp;&amp; !replacing;</span><br><span class="line">                                if (removed) &#123;</span><br><span class="line">                                    if (killProcess) &#123;</span><br><span class="line">                                        forceStopPackageLocked(ssp, UserHandle.getAppId(</span><br><span class="line">                                                intent.getIntExtra(Intent.EXTRA_UID, -1)),</span><br><span class="line">                                                false, true, true, false, fullUninstall, userId,</span><br><span class="line">                                                removed ? &quot;pkg removed&quot; : &quot;pkg changed&quot;);</span><br><span class="line">                                    &#125; else &#123;</span><br><span class="line">                                        // Kill any app zygotes always, since they can&#x27;t fork new</span><br><span class="line">                                        // processes with references to the old code</span><br><span class="line">                                        forceStopAppZygoteLocked(ssp, UserHandle.getAppId(</span><br><span class="line">                                                intent.getIntExtra(Intent.EXTRA_UID, -1)),</span><br><span class="line">                                                userId);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    final int cmd = killProcess</span><br><span class="line">                                            ? ApplicationThreadConstants.PACKAGE_REMOVED</span><br><span class="line">                                            : ApplicationThreadConstants.PACKAGE_REMOVED_DONT_KILL;</span><br><span class="line">                                    sendPackageBroadcastLocked(cmd,</span><br><span class="line">                                            new String[] &#123;ssp&#125;, userId);</span><br><span class="line">                                    if (fullUninstall) &#123;</span><br><span class="line">                                        mAppOpsService.packageRemoved(</span><br><span class="line">                                                intent.getIntExtra(Intent.EXTRA_UID, -1), ssp);</span><br><span class="line"></span><br><span class="line">                                        // Remove all permissions granted from/to this package</span><br><span class="line">                                        mUgmInternal.removeUriPermissionsForPackage(ssp, userId,</span><br><span class="line">                                                true, false);</span><br><span class="line"></span><br><span class="line">                                        mAtmInternal.removeRecentTasksByPackageName(ssp, userId);</span><br><span class="line"></span><br><span class="line">                                        mServices.forceStopPackageLocked(ssp, userId);</span><br><span class="line">                                        mAtmInternal.onPackageUninstalled(ssp);</span><br><span class="line">                                        mBatteryStatsService.notePackageUninstalled(ssp);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    if (killProcess) &#123;</span><br><span class="line">                                        final int extraUid = intent.getIntExtra(Intent.EXTRA_UID,</span><br><span class="line">                                                -1);</span><br><span class="line">                                        mProcessList.killPackageProcessesLocked(ssp,</span><br><span class="line">                                                UserHandle.getAppId(extraUid),</span><br><span class="line">                                                userId, ProcessList.INVALID_ADJ,</span><br><span class="line">                                                ApplicationExitInfo.REASON_USER_REQUESTED,</span><br><span class="line">                                                ApplicationExitInfo.SUBREASON_UNKNOWN,</span><br><span class="line">                                                &quot;change &quot; + ssp);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    cleanupDisabledPackageComponentsLocked(ssp, userId,</span><br><span class="line">                                            intent.getStringArrayExtra(</span><br><span class="line">                                                    Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            break;</span><br><span class="line">                        case Intent.ACTION_PACKAGES_SUSPENDED:</span><br><span class="line">                        case Intent.ACTION_PACKAGES_UNSUSPENDED:</span><br><span class="line">                            final boolean suspended = Intent.ACTION_PACKAGES_SUSPENDED.equals(</span><br><span class="line">                                    intent.getAction());</span><br><span class="line">                            final String[] packageNames = intent.getStringArrayExtra(</span><br><span class="line">                                    Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">                            final int userIdExtra = intent.getIntExtra(</span><br><span class="line">                                    Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);</span><br><span class="line"></span><br><span class="line">                            mAtmInternal.onPackagesSuspendedChanged(packageNames, suspended,</span><br><span class="line">                                    userIdExtra);</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case Intent.ACTION_PACKAGE_REPLACED:</span><br><span class="line">                &#123;</span><br><span class="line">                    final Uri data = intent.getData();</span><br><span class="line">                    final String ssp;</span><br><span class="line">                    if (data != null &amp;&amp; (ssp = data.getSchemeSpecificPart()) != null) &#123;</span><br><span class="line">                        ApplicationInfo aInfo = null;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            aInfo = AppGlobals.getPackageManager()</span><br><span class="line">                                    .getApplicationInfo(ssp, STOCK_PM_FLAGS, userId);</span><br><span class="line">                        &#125; catch (RemoteException ignore) &#123;&#125;</span><br><span class="line">                        if (aInfo == null) &#123;</span><br><span class="line">                            Slog.w(TAG, &quot;Dropping ACTION_PACKAGE_REPLACED for non-existent pkg:&quot;</span><br><span class="line">                                    + &quot; ssp=&quot; + ssp + &quot; data=&quot; + data);</span><br><span class="line">                            return ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">                        &#125;</span><br><span class="line">                        updateAssociationForApp(aInfo);</span><br><span class="line">                        mAtmInternal.onPackageReplaced(aInfo);</span><br><span class="line">                        mServices.updateServiceApplicationInfoLocked(aInfo);</span><br><span class="line">                        sendPackageBroadcastLocked(ApplicationThreadConstants.PACKAGE_REPLACED,</span><br><span class="line">                                new String[] &#123;ssp&#125;, userId);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case Intent.ACTION_PACKAGE_ADDED:</span><br><span class="line">                &#123;</span><br><span class="line">                    // Special case for adding a package: by default turn on compatibility mode.</span><br><span class="line">                    Uri data = intent.getData();</span><br><span class="line">                    String ssp;</span><br><span class="line">                    if (data != null &amp;&amp; (ssp = data.getSchemeSpecificPart()) != null) &#123;</span><br><span class="line">                        final boolean replacing =</span><br><span class="line">                                intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);</span><br><span class="line">                        mAtmInternal.onPackageAdded(ssp, replacing);</span><br><span class="line"></span><br><span class="line">                        try &#123;</span><br><span class="line">                            ApplicationInfo ai = AppGlobals.getPackageManager().</span><br><span class="line">                                    getApplicationInfo(ssp, STOCK_PM_FLAGS, 0);</span><br><span class="line">                            mBatteryStatsService.notePackageInstalled(ssp,</span><br><span class="line">                                    ai != null ? ai.longVersionCode : 0);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case Intent.ACTION_PACKAGE_DATA_CLEARED:</span><br><span class="line">                &#123;</span><br><span class="line">                    Uri data = intent.getData();</span><br><span class="line">                    String ssp;</span><br><span class="line">                    if (data != null &amp;&amp; (ssp = data.getSchemeSpecificPart()) != null) &#123;</span><br><span class="line">                        mAtmInternal.onPackageDataCleared(ssp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case Intent.ACTION_TIMEZONE_CHANGED:</span><br><span class="line">                    // If this is the time zone changed action, queue up a message that will reset</span><br><span class="line">                    // the timezone of all currently running processes. This message will get</span><br><span class="line">                    // queued up before the broadcast happens.</span><br><span class="line">                    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);</span><br><span class="line">                    break;</span><br><span class="line">                case Intent.ACTION_TIME_CHANGED:</span><br><span class="line">                    // EXTRA_TIME_PREF_24_HOUR_FORMAT is optional so we must distinguish between</span><br><span class="line">                    // the tri-state value it may contain and &quot;unknown&quot;.</span><br><span class="line">                    // For convenience we re-use the Intent extra values.</span><br><span class="line">                    final int NO_EXTRA_VALUE_FOUND = -1;</span><br><span class="line">                    final int timeFormatPreferenceMsgValue = intent.getIntExtra(</span><br><span class="line">                            Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,</span><br><span class="line">                            NO_EXTRA_VALUE_FOUND /* defaultValue */);</span><br><span class="line">                    // Only send a message if the time preference is available.</span><br><span class="line">                    if (timeFormatPreferenceMsgValue != NO_EXTRA_VALUE_FOUND) &#123;</span><br><span class="line">                        Message updateTimePreferenceMsg =</span><br><span class="line">                                mHandler.obtainMessage(UPDATE_TIME_PREFERENCE_MSG,</span><br><span class="line">                                        timeFormatPreferenceMsgValue, 0);</span><br><span class="line">                        mHandler.sendMessage(updateTimePreferenceMsg);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">                    synchronized (stats) &#123;</span><br><span class="line">                        stats.noteCurrentTimeChangedLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case Intent.ACTION_CLEAR_DNS_CACHE:</span><br><span class="line">                    mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);</span><br><span class="line">                    break;</span><br><span class="line">                case Proxy.PROXY_CHANGE_ACTION:</span><br><span class="line">                    mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG));</span><br><span class="line">                    break;</span><br><span class="line">                case android.hardware.Camera.ACTION_NEW_PICTURE:</span><br><span class="line">                case android.hardware.Camera.ACTION_NEW_VIDEO:</span><br><span class="line">                    // In N we just turned these off; in O we are turing them back on partly,</span><br><span class="line">                    // only for registered receivers.  This will still address the main problem</span><br><span class="line">                    // (a spam of apps waking up when a picture is taken putting significant</span><br><span class="line">                    // memory pressure on the system at a bad point), while still allowing apps</span><br><span class="line">                    // that are already actively running to know about this happening.</span><br><span class="line">                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">                    break;</span><br><span class="line">                case android.security.KeyChain.ACTION_TRUST_STORE_CHANGED:</span><br><span class="line">                    mHandler.sendEmptyMessage(HANDLE_TRUST_STORAGE_UPDATE_MSG);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;com.android.launcher.action.INSTALL_SHORTCUT&quot;:</span><br><span class="line">                    // As of O, we no longer support this broadcasts, even for pre-O apps.</span><br><span class="line">                    // Apps should now be using ShortcutManager.pinRequestShortcut().</span><br><span class="line">                    Log.w(TAG, &quot;Broadcast &quot; + action</span><br><span class="line">                            + &quot; no longer supported. It will not be delivered.&quot;);</span><br><span class="line">                    return ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">                case Intent.ACTION_PRE_BOOT_COMPLETED:</span><br><span class="line">                    timeoutExempt = true;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (Intent.ACTION_PACKAGE_ADDED.equals(action) ||</span><br><span class="line">                    Intent.ACTION_PACKAGE_REMOVED.equals(action) ||</span><br><span class="line">                    Intent.ACTION_PACKAGE_REPLACED.equals(action)) &#123;</span><br><span class="line">                final int uid = getUidFromIntent(intent);</span><br><span class="line">                if (uid != -1) &#123;</span><br><span class="line">                    final UidRecord uidRec = mProcessList.getUidRecordLocked(uid);</span><br><span class="line">                    if (uidRec != null) &#123;</span><br><span class="line">                        uidRec.updateHasInternetPermission();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Add to the sticky list if requested.</span><br><span class="line">        if (sticky) &#123;</span><br><span class="line">            if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,</span><br><span class="line">                    callingPid, callingUid)</span><br><span class="line">                    != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                String msg = &quot;Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=&quot;</span><br><span class="line">                        + callingPid + &quot;, uid=&quot; + callingUid</span><br><span class="line">                        + &quot; requires &quot; + android.Manifest.permission.BROADCAST_STICKY;</span><br><span class="line">                Slog.w(TAG, msg);</span><br><span class="line">                throw new SecurityException(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            if (requiredPermissions != null &amp;&amp; requiredPermissions.length &gt; 0) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Can&#x27;t broadcast sticky intent &quot; + intent</span><br><span class="line">                        + &quot; and enforce permissions &quot; + Arrays.toString(requiredPermissions));</span><br><span class="line">                return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;</span><br><span class="line">            &#125;</span><br><span class="line">            if (intent.getComponent() != null) &#123;</span><br><span class="line">                throw new SecurityException(</span><br><span class="line">                        &quot;Sticky broadcasts can&#x27;t target a specific component&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // We use userId directly here, since the &quot;all&quot; target is maintained</span><br><span class="line">            // as a separate set of sticky broadcasts.</span><br><span class="line">            if (userId != UserHandle.USER_ALL) &#123;</span><br><span class="line">                // But first, if this is not a broadcast to all users, then</span><br><span class="line">                // make sure it doesn&#x27;t conflict with an existing broadcast to</span><br><span class="line">                // all users.</span><br><span class="line">                ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(</span><br><span class="line">                        UserHandle.USER_ALL);</span><br><span class="line">                if (stickies != null) &#123;</span><br><span class="line">                    ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">                    if (list != null) &#123;</span><br><span class="line">                        int N = list.size();</span><br><span class="line">                        int i;</span><br><span class="line">                        for (i=0; i&lt;N; i++) &#123;</span><br><span class="line">                            if (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">                                throw new IllegalArgumentException(</span><br><span class="line">                                        &quot;Sticky broadcast &quot; + intent + &quot; for user &quot;</span><br><span class="line">                                        + userId + &quot; conflicts with existing global broadcast&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);</span><br><span class="line">            if (stickies == null) &#123;</span><br><span class="line">                stickies = new ArrayMap&lt;&gt;();</span><br><span class="line">                mStickyBroadcasts.put(userId, stickies);</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">            if (list == null) &#123;</span><br><span class="line">                list = new ArrayList&lt;&gt;();</span><br><span class="line">                stickies.put(intent.getAction(), list);</span><br><span class="line">            &#125;</span><br><span class="line">            final int stickiesCount = list.size();</span><br><span class="line">            int i;</span><br><span class="line">            for (i = 0; i &lt; stickiesCount; i++) &#123;</span><br><span class="line">                if (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">                    // This sticky already exists, replace it.</span><br><span class="line">                    list.set(i, new Intent(intent));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt;= stickiesCount) &#123;</span><br><span class="line">                list.add(new Intent(intent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] users;</span><br><span class="line">        if (userId == UserHandle.USER_ALL) &#123;</span><br><span class="line">            // Caller wants broadcast to go to all started users.</span><br><span class="line">            users = mUserController.getStartedUserArray();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Caller wants broadcast to go to one specific user.</span><br><span class="line">            users = new int[] &#123;userId&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Figure out who all will receive this broadcast.</span><br><span class="line">        List receivers = null;</span><br><span class="line">        List&lt;BroadcastFilter&gt; registeredReceivers = null;</span><br><span class="line">        // Need to resolve the intent to interested receivers...</span><br><span class="line">        if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">                 == 0) &#123;</span><br><span class="line">            receivers = collectReceiverComponents(</span><br><span class="line">                    intent, resolvedType, callingUid, users, broadcastWhitelist);</span><br><span class="line">        &#125;</span><br><span class="line">        if (intent.getComponent() == null) &#123;</span><br><span class="line">            if (userId == UserHandle.USER_ALL &amp;&amp; callingUid == SHELL_UID) &#123;</span><br><span class="line">                // Query one target user at a time, excluding shell-restricted users</span><br><span class="line">                for (int i = 0; i &lt; users.length; i++) &#123;</span><br><span class="line">                    if (mUserController.hasUserRestriction(</span><br><span class="line">                            UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    List&lt;BroadcastFilter&gt; registeredReceiversForUser =</span><br><span class="line">                            mReceiverResolver.queryIntent(intent,</span><br><span class="line">                                    resolvedType, false /*defaultOnly*/, users[i]);</span><br><span class="line">                    if (registeredReceivers == null) &#123;</span><br><span class="line">                        registeredReceivers = registeredReceiversForUser;</span><br><span class="line">                    &#125; else if (registeredReceiversForUser != null) &#123;</span><br><span class="line">                        registeredReceivers.addAll(registeredReceiversForUser);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                        resolvedType, false /*defaultOnly*/, userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean replacePending =</span><br><span class="line">                (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing broadcast: &quot; + intent.getAction()</span><br><span class="line">                + &quot; replacePending=&quot; + replacePending);</span><br><span class="line">        if (registeredReceivers != null &amp;&amp; broadcastWhitelist != null) &#123;</span><br><span class="line">            // if a uid whitelist was provided, remove anything in the application space that wasn&#x27;t</span><br><span class="line">            // in it.</span><br><span class="line">            for (int i = registeredReceivers.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                final int owningAppId = UserHandle.getAppId(registeredReceivers.get(i).owningUid);</span><br><span class="line">                if (owningAppId &gt;= Process.FIRST_APPLICATION_UID</span><br><span class="line">                        &amp;&amp; Arrays.binarySearch(broadcastWhitelist, owningAppId) &lt; 0) &#123;</span><br><span class="line">                    registeredReceivers.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int NR = registeredReceivers != null ? registeredReceivers.size() : 0;</span><br><span class="line">        if (!ordered &amp;&amp; NR &gt; 0) &#123;</span><br><span class="line">            // If we are not serializing this broadcast, then send the</span><br><span class="line">            // registered receivers separately so they don&#x27;t wait for the</span><br><span class="line">            // components to be launched.</span><br><span class="line">            if (isCallerSystem) &#123;</span><br><span class="line">                checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                        isProtectedBroadcast, registeredReceivers);</span><br><span class="line">            &#125;</span><br><span class="line">            final BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">            BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage,</span><br><span class="line">                    callerFeatureId, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">                    requiredPermissions, appOp, brOptions, registeredReceivers, resultTo,</span><br><span class="line">                    resultCode, resultData, resultExtras, ordered, sticky, false, userId,</span><br><span class="line">                    allowBackgroundActivityStarts, timeoutExempt);</span><br><span class="line">            if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing parallel broadcast &quot; + r);</span><br><span class="line">            final boolean replaced = replacePending</span><br><span class="line">                    &amp;&amp; (queue.replaceParallelBroadcastLocked(r) != null);</span><br><span class="line">            // Note: We assume resultTo is null for non-ordered broadcasts.</span><br><span class="line">            if (!replaced) &#123;</span><br><span class="line">                queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">                queue.scheduleBroadcastsLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            registeredReceivers = null;</span><br><span class="line">            NR = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Merge into one list.</span><br><span class="line">        int ir = 0;</span><br><span class="line">        if (receivers != null) &#123;</span><br><span class="line">            // A special case for PACKAGE_ADDED: do not allow the package</span><br><span class="line">            // being added to see this broadcast.  This prevents them from</span><br><span class="line">            // using this as a back door to get run as soon as they are</span><br><span class="line">            // installed.  Maybe in the future we want to have a special install</span><br><span class="line">            // broadcast or such for apps, but we&#x27;d like to deliberately make</span><br><span class="line">            // this decision.</span><br><span class="line">            String skipPackages[] = null;</span><br><span class="line">            if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())</span><br><span class="line">                    || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())</span><br><span class="line">                    || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123;</span><br><span class="line">                Uri data = intent.getData();</span><br><span class="line">                if (data != null) &#123;</span><br><span class="line">                    String pkgName = data.getSchemeSpecificPart();</span><br><span class="line">                    if (pkgName != null) &#123;</span><br><span class="line">                        skipPackages = new String[] &#123; pkgName &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123;</span><br><span class="line">                skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">            &#125;</span><br><span class="line">            if (skipPackages != null &amp;&amp; (skipPackages.length &gt; 0)) &#123;</span><br><span class="line">                for (String skipPackage : skipPackages) &#123;</span><br><span class="line">                    if (skipPackage != null) &#123;</span><br><span class="line">                        int NT = receivers.size();</span><br><span class="line">                        for (int it=0; it&lt;NT; it++) &#123;</span><br><span class="line">                            ResolveInfo curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">                            if (curt.activityInfo.packageName.equals(skipPackage)) &#123;</span><br><span class="line">                                receivers.remove(it);</span><br><span class="line">                                it--;</span><br><span class="line">                                NT--;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int NT = receivers != null ? receivers.size() : 0;</span><br><span class="line">            int it = 0;</span><br><span class="line">            ResolveInfo curt = null;</span><br><span class="line">            BroadcastFilter curr = null;</span><br><span class="line">            while (it &lt; NT &amp;&amp; ir &lt; NR) &#123;</span><br><span class="line">                if (curt == null) &#123;</span><br><span class="line">                    curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">                &#125;</span><br><span class="line">                if (curr == null) &#123;</span><br><span class="line">                    curr = registeredReceivers.get(ir);</span><br><span class="line">                &#125;</span><br><span class="line">                if (curr.getPriority() &gt;= curt.priority) &#123;</span><br><span class="line">                    // Insert this broadcast record into the final list.</span><br><span class="line">                    receivers.add(it, curr);</span><br><span class="line">                    ir++;</span><br><span class="line">                    curr = null;</span><br><span class="line">                    it++;</span><br><span class="line">                    NT++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Skip to the next ResolveInfo in the final list.</span><br><span class="line">                    it++;</span><br><span class="line">                    curt = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (ir &lt; NR) &#123;</span><br><span class="line">            if (receivers == null) &#123;</span><br><span class="line">                receivers = new ArrayList();</span><br><span class="line">            &#125;</span><br><span class="line">            receivers.add(registeredReceivers.get(ir));</span><br><span class="line">            ir++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isCallerSystem) &#123;</span><br><span class="line">            checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                    isProtectedBroadcast, receivers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((receivers != null &amp;&amp; receivers.size() &gt; 0)</span><br><span class="line">                || resultTo != null) &#123;</span><br><span class="line">            BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">            BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage,</span><br><span class="line">                    callerFeatureId, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">                    requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">                    resultData, resultExtras, ordered, sticky, false, userId,</span><br><span class="line">                    allowBackgroundActivityStarts, timeoutExempt);</span><br><span class="line"></span><br><span class="line">            if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing ordered broadcast &quot; + r);</span><br><span class="line"></span><br><span class="line">            final BroadcastRecord oldRecord =</span><br><span class="line">                    replacePending ? queue.replaceOrderedBroadcastLocked(r) : null;</span><br><span class="line">            if (oldRecord != null) &#123;</span><br><span class="line">                // Replaced, fire the result-to receiver.</span><br><span class="line">                if (oldRecord.resultTo != null) &#123;</span><br><span class="line">                    final BroadcastQueue oldQueue = broadcastQueueForIntent(oldRecord.intent);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        oldQueue.performReceiveLocked(oldRecord.callerApp, oldRecord.resultTo,</span><br><span class="line">                                oldRecord.intent,</span><br><span class="line">                                Activity.RESULT_CANCELED, null, null,</span><br><span class="line">                                false, false, oldRecord.userId);</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Failure [&quot;</span><br><span class="line">                                + queue.mQueueName + &quot;] sending broadcast result of &quot;</span><br><span class="line">                                + intent, e);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">                queue.scheduleBroadcastsLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // There was nobody interested in the broadcast, but we still want to record</span><br><span class="line">            // that it happened.</span><br><span class="line">            if (intent.getComponent() == null &amp;&amp; intent.getPackage() == null</span><br><span class="line">                    &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123;</span><br><span class="line">                // This was an implicit broadcast... let&#x27;s record it for posterity.</span><br><span class="line">                addBroadcastStatLocked(intent.getAction(), callerPackage, 0, 0, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在broadcastIntentLocked方法中会去找接收该广播的接收者，先来看看匹配广播接收者的逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final int broadcastIntentLocked()&#123;</span><br><span class="line">    //......</span><br><span class="line">    // Figure out who all will receive this broadcast.</span><br><span class="line">    List receivers = null;</span><br><span class="line">    List&lt;BroadcastFilter&gt; registeredReceivers = null;</span><br><span class="line">    // Need to resolve the intent to interested receivers...</span><br><span class="line">    //如果发送的广播没有FLAG_RECEIVER_REGISTERED_ONLY这个flag，就会去收集</span><br><span class="line">    if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">             == 0) &#123;</span><br><span class="line">        receivers = collectReceiverComponents(</span><br><span class="line">                intent, resolvedType, callingUid, users, broadcastWhitelist);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果是隐式广播</span><br><span class="line">    if (intent.getComponent() == null) &#123;</span><br><span class="line">        if (userId == UserHandle.USER_ALL &amp;&amp; callingUid == SHELL_UID) &#123;</span><br><span class="line">            // Query one target user at a time, excluding shell-restricted users</span><br><span class="line">            //shell发送的广播暂时不关注</span><br><span class="line">            //......</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //这里根据intent去查询</span><br><span class="line">            registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                    resolvedType, false /*defaultOnly*/, userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //......</span><br><span class="line">    //取到接收者的数量</span><br><span class="line">    int NR = registeredReceivers != null ? registeredReceivers.size() : 0;</span><br><span class="line">    //针对无序广播，并且接收者数量大于0</span><br><span class="line">    if (!ordered &amp;&amp; NR &gt; 0) &#123;</span><br><span class="line">        // If we are not serializing this broadcast, then send the</span><br><span class="line">        // registered receivers separately so they don&#x27;t wait for the</span><br><span class="line">        // components to be launched.</span><br><span class="line">        if (isCallerSystem) &#123;</span><br><span class="line">            //如果是特殊uid发送的广播，会进行</span><br><span class="line">            checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                    isProtectedBroadcast, registeredReceivers);</span><br><span class="line">        &#125;</span><br><span class="line">        final BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage,</span><br><span class="line">                callerFeatureId, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">                requiredPermissions, appOp, brOptions, registeredReceivers, resultTo,</span><br><span class="line">                resultCode, resultData, resultExtras, ordered, sticky, false, userId,</span><br><span class="line">                allowBackgroundActivityStarts, timeoutExempt);</span><br><span class="line">        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing parallel broadcast &quot; + r);</span><br><span class="line">        final boolean replaced = replacePending</span><br><span class="line">                &amp;&amp; (queue.replaceParallelBroadcastLocked(r) != null);</span><br><span class="line">        // Note: We assume resultTo is null for non-ordered broadcasts.</span><br><span class="line">        if (!replaced) &#123;</span><br><span class="line">            queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        registeredReceivers = null;</span><br><span class="line">        NR = 0;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>AMS</title>
    <url>//pages/d4a6f5/</url>
    <content><![CDATA[<h2 id="startActivity流程"><a href="#startActivity流程" class="headerlink" title="startActivity流程"></a>startActivity流程</h2><p>以Activity中的startActivity为例：<br>activity中的startActivity实际调用的startActivityForResult,只是requestCode为-1.<br>在startActivityForResult中调用如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Instrumentation.execStartActivity()</span><br><span class="line">ActivityTaskManager.getService().startActivity()（这个方法有返回值，然后会调用checkStartActivityResult根据返回值抛出异常）</span><br></pre></td></tr></table></figure>
<p>后续就通过binder进入了system server，调用链如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityTaskManagerService.startActivity()</span><br><span class="line">ActivityTaskManagerService.startActivityAsUser()</span><br><span class="line">getActivityStartController().obtainStarter().execute();</span><br></pre></td></tr></table></figure>
<p>这里看到，在system server中启动activity调用的是ActivityStart.excute(),接下来看一下excute()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityStart.executeRequest()</span><br><span class="line">ActivityStart.startActivityUnchecked()</span><br><span class="line">ActivityStart.startActivityInner()</span><br></pre></td></tr></table></figure>
<p>在executeRequest中做了一些权限检查，及intent处理，然后创建了一个 ActivityRecord 保存activity的信息,<br>然后调用的startActivityUnchecked（这里传入的doResume为true），内部继续调用startActivityInner();<br>具体看看startActivityInner：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int startActivityInner(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        int startFlags, boolean doResume, ActivityOptions options, Task inTask,</span><br><span class="line">        boolean restrictedBgActivity, NeededUriGrants intentGrants) &#123;</span><br><span class="line">    //初始化变量，会将传入的参数值赋值到对应的全局变量</span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor, restrictedBgActivity);</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    mIntent.setFlags(mLaunchFlags);</span><br><span class="line">    //这里去获取activity是否有对应可以复用的task</span><br><span class="line">    final Task reusedTask = getReusableTask();</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    //新启动的app，没有可复用的task，调用computeTargetTask去获取可用的task，不过FLAG_ACTIVITY_NEW_TASK好像也会返回null</span><br><span class="line">    final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask();</span><br><span class="line">    final boolean newTask = targetTask == null;</span><br><span class="line">    mTargetTask = targetTask;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    //这里实际调用mRootWindowContainer.getLaunchStack</span><br><span class="line">    if (mTargetStack == null) &#123;</span><br><span class="line">        mTargetStack = getLaunchStack(mStartActivity, mLaunchFlags, targetTask, mOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    if (!mAvoidMoveToFront &amp;&amp; mDoResume) &#123;</span><br><span class="line">        //在这里会将stack移到栈顶</span><br><span class="line">        mTargetStack.getStack().moveToFront(&quot;reuseOrNewTask&quot;, targetTask);</span><br><span class="line">        if (mOptions != null) &#123;</span><br><span class="line">            if (mOptions.getTaskAlwaysOnTop()) &#123;</span><br><span class="line">                mTargetStack.setAlwaysOnTop(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!mTargetStack.isTopStackInDisplayArea() &amp;&amp; mService.mInternal.isDreaming()) &#123;</span><br><span class="line">            // Launching underneath dream activity (fullscreen, always-on-top). Run the launch-</span><br><span class="line">            // -behind transition so the Activity gets created and starts in visible state.</span><br><span class="line">            mLaunchTaskBehind = true;</span><br><span class="line">            r.mLaunchTaskBehind = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (newTask) &#123;</span><br><span class="line">        EventLogTags.writeWmCreateTask(mStartActivity.mUserId,</span><br><span class="line">                mStartActivity.getTask().mTaskId);</span><br><span class="line">    &#125;</span><br><span class="line">    mStartActivity.logStartActivity(</span><br><span class="line">            EventLogTags.WM_CREATE_ACTIVITY, mStartActivity.getTask());</span><br><span class="line"></span><br><span class="line">    mTargetStack.mLastPausedActivity = null;</span><br><span class="line"></span><br><span class="line">    mRootWindowContainer.sendPowerHintForLaunchStartIfNeeded(</span><br><span class="line">            false /* forceSend */, mStartActivity);</span><br><span class="line">    //在stack中处理activity的顺序</span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity,</span><br><span class="line">            topStack != null ? topStack.getTopNonFinishingActivity() : null, newTask,</span><br><span class="line">            mKeepCurTransition, mOptions);</span><br><span class="line">    if (mDoResume) &#123;</span><br><span class="line">        final ActivityRecord topTaskActivity =</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        if (!mTargetStack.isTopActivityFocusable()</span><br><span class="line">                || (topTaskActivity != null &amp;&amp; topTaskActivity.isTaskOverlay()</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            // If the activity is not focusable, we can&#x27;t resume it, but still would like to</span><br><span class="line">            // make sure it becomes visible as it starts (this will also trigger entry</span><br><span class="line">            // animation). An example of this are PIP activities.</span><br><span class="line">            // Also, we don&#x27;t want to resume activities in a task that currently has an overlay</span><br><span class="line">            // as the starting activity just needs to be in the visible paused state until the</span><br><span class="line">            // over is removed.</span><br><span class="line">            // Passing &#123;@code null&#125; as the start parameter ensures all activities are made</span><br><span class="line">            // visible.</span><br><span class="line">            mTargetStack.ensureActivitiesVisible(null /* starting */,</span><br><span class="line">                    0 /* configChanges */, !PRESERVE_WINDOWS);</span><br><span class="line">            // Go ahead and tell window manager to execute app transition for this activity</span><br><span class="line">            // since the app transition will not be triggered through the resume channel.</span><br><span class="line">            mTargetStack.getDisplay().mDisplayContent.executeAppTransition();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If the target stack was not previously focusable (previous top running activity</span><br><span class="line">            // on that stack was not visible) then any prior calls to move the stack to the</span><br><span class="line">            // will not update the focused stack.  If starting the new activity now allows the</span><br><span class="line">            // task stack to be focusable, then ensure that we now update the focused stack</span><br><span class="line">            // accordingly.</span><br><span class="line">            if (mTargetStack.isTopActivityFocusable()</span><br><span class="line">                    &amp;&amp; !mRootWindowContainer.isTopDisplayFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(&quot;startActivityInner&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //这里将对应的activity和stack聚焦移到前台</span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities(</span><br><span class="line">                    mTargetStack, mStartActivity, mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mRootWindowContainer.updateUserStack(mStartActivity.mUserId, mTargetStack);</span><br><span class="line"></span><br><span class="line">    // Update the recent tasks list immediately when the activity starts</span><br><span class="line">    mSupervisor.mRecentTasks.add(mStartActivity.getTask());</span><br><span class="line">    mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(),</span><br><span class="line">            mPreferredWindowingMode, mPreferredTaskDisplayArea, mTargetStack);</span><br><span class="line"></span><br><span class="line">    return START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说在startActivityInner中做了一系列的stack排序逻辑，最终调调用的mRootWindowContainer.resumeFocusedStacksTopActivities();<br>接着看RootWindowContainer中的resumeFocusedStacksTopActivities:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean resumeFocusedStacksTopActivities(</span><br><span class="line">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    boolean result = false;</span><br><span class="line">    if (targetStack != null &amp;&amp; (targetStack.isTopStackInDisplayArea()</span><br><span class="line">            || getTopDisplayFocusedStack() == targetStack)) &#123;</span><br><span class="line">        //确保启动的activity在对应栈的栈顶</span><br><span class="line">        result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里是去遍历所有的显示屏幕</span><br><span class="line">    for (int displayNdx = getChildCount() - 1; displayNdx &gt;= 0; --displayNdx) &#123;</span><br><span class="line">        final DisplayContent display = getChildAt(displayNdx);</span><br><span class="line">        boolean resumedOnDisplay = false;</span><br><span class="line">        for (int tdaNdx = display.getTaskDisplayAreaCount() - 1; tdaNdx &gt;= 0; --tdaNdx) &#123;</span><br><span class="line">            final TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(tdaNdx);</span><br><span class="line">            for (int sNdx = taskDisplayArea.getStackCount() - 1; sNdx &gt;= 0; --sNdx) &#123;</span><br><span class="line">                final ActivityStack stack = taskDisplayArea.getStackAt(sNdx);</span><br><span class="line">                final ActivityRecord topRunningActivity = stack.topRunningActivity();</span><br><span class="line">                if (!stack.isFocusableAndVisible() || topRunningActivity == null) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (stack == targetStack) &#123;</span><br><span class="line">                    // Simply update the result for targetStack because the targetStack had</span><br><span class="line">                    // already resumed in above. We don&#x27;t want to resume it again, especially in</span><br><span class="line">                    // some cases, it would cause a second launch failure if app process was</span><br><span class="line">                    // dead.</span><br><span class="line">                    resumedOnDisplay |= result;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (taskDisplayArea.isTopStack(stack) &amp;&amp; topRunningActivity.isState(RESUMED)) &#123;</span><br><span class="line">                    // Kick off any lingering app transitions form the MoveTaskToFront</span><br><span class="line">                    // operation, but only consider the top task and stack on that display.</span><br><span class="line">                    stack.executeAppTransition(targetOptions);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    resumedOnDisplay |= topRunningActivity.makeActiveIfNeeded(target);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果activity没有成功移到栈顶后的操作</span><br><span class="line">        if (!resumedOnDisplay) &#123;</span><br><span class="line">            // In cases when there are no valid activities (e.g. device just booted or launcher</span><br><span class="line">            // crashed) it&#x27;s possible that nothing was resumed on a display. Requesting resume</span><br><span class="line">            // of top activity in focused stack explicitly will make sure that at least home</span><br><span class="line">            // activity is started and resumed, and no recursion occurs.</span><br><span class="line">            final ActivityStack focusedStack = display.getFocusedStack();</span><br><span class="line">            if (focusedStack != null) &#123;</span><br><span class="line">                //这里会再次尝试一次</span><br><span class="line">                result |= focusedStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">            &#125; else if (targetStack == null) &#123;</span><br><span class="line">                result |= resumeHomeActivity(null /* prev */, &quot;no-focusable-task&quot;,</span><br><span class="line">                        display.getDefaultTaskDisplayArea());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那就继续看ActivityStack.resumeTopActivityUncheckedLocked():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resumeTopActivityUncheckedLocked()</span><br><span class="line">resumeTopActivityInnerLocked()</span><br><span class="line">mStackSupervisor.startSpecificActivity()</span><br></pre></td></tr></table></figure>
<p>startSpecificActivity中有逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void startSpecificActivity(ActivityRecord r, boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">    // Is this activity&#x27;s application already running?</span><br><span class="line">    final WindowProcessController wpc =</span><br><span class="line">            mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">    boolean knownToBeDead = false;</span><br><span class="line">    //判断app进程是否启动</span><br><span class="line">    if (wpc != null &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //app进程启动就调用realStartActivityLocked</span><br><span class="line">            realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If a dead object exception was thrown -- fall through to</span><br><span class="line">        // restart the application.</span><br><span class="line">        knownToBeDead = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.notifyUnknownVisibilityLaunchedForKeyguardTransition();</span><br><span class="line"></span><br><span class="line">    final boolean isTop = andResume &amp;&amp; r.isTopRunningActivity();</span><br><span class="line">    //app未启动，调用ATMS的startProcessAsync，去启动app</span><br><span class="line">    mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? &quot;top-activity&quot; : &quot;activity&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityManagerService中的startProcessAsync，是通过handler将ActivityManagerInternal::startProcess放到DisplayThread中执行的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,</span><br><span class="line">            String hostingType) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) &#123;</span><br><span class="line">                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;dispatchingStartProcess:&quot;</span><br><span class="line">                        + activity.processName);</span><br><span class="line">            &#125;</span><br><span class="line">            // Post message to start process to avoid possible deadlock of calling into AMS with the</span><br><span class="line">            // ATMS lock held.</span><br><span class="line">            //方法内部调用了Message的setCallback，在Handler的dispatchMessage中会直接执行callback，不走handleMessage</span><br><span class="line">            final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,</span><br><span class="line">                    mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,</span><br><span class="line">                    isTop, hostingType, activity.intent.getComponent());</span><br><span class="line">            mH.sendMessage(m);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityManagerInternal.startProcess()</span><br><span class="line">ActivityManagerService.startProcessLocked() 这里会在</span><br><span class="line">mProcessList.startProcessLocked() 有多个startProcessLocked的重载方法，层层调用</span><br><span class="line">ProcessList.startProcess()</span><br><span class="line">    Process.start()</span><br><span class="line">    Process.startViaZygote()</span><br><span class="line">    Process.openZygoteSocketIfNeeded() 通过socket连接到zygote</span><br><span class="line">    Process.zygoteSendArgsAndGetResult()</span><br><span class="line">    Process.attemptZygoteSendArgsAndGetResult() 向zygote发送参数fork进程，后续的fork逻辑就是在zygote中处理了</span><br><span class="line">ProcessList.handleProcessStartedLocked()    这里是Zytoge fork成功后的处理，会将pid和ProcessRecord保存到AMS的mPidsSelfLocked中</span><br></pre></td></tr></table></figure>
<p>ProcessList中的startProcessLocked中有一个判断，根据FLAG_PROCESS_START_ASYNC判断是否要异步启动APP，默认为true</p>
<p>后面进程的启动看ActivtyThread.main()，代码不长，主要就是开启主线程的looper，调用attach：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line"></span><br><span class="line">    // Install selective syscall interception</span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">    // disable it here, but selectively enable it later (via</span><br><span class="line">    // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">    CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    // Call per-process mainline module initialization.</span><br><span class="line">    initializeMainlineModules();</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line">    //初始化主线程的looper</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span><br><span class="line">    // It will be in the format &quot;seq=114&quot;</span><br><span class="line">    long startSeq = 0;</span><br><span class="line">    if (args != null) &#123;</span><br><span class="line">        for (int i = args.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                        args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //实例化ActivityThread</span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler == null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new</span><br><span class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // End of event ActivityThreadMain.</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    //looper循环，等待消息</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看ActivtyThread的attach方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivtyThread.attach()</span><br><span class="line">ActivityManager.getService().attachApplication()</span><br><span class="line">ActivityManagerService.attachApplicationLocked()</span><br><span class="line">    ActivtyThread.bindApplication()     这里就是通过handler发送消息调用 ActivtyThread.handleBindApplication()</span><br><span class="line">    ProcessRecord.makeActive()          在WindowProcessController中保存了IApplicationThread</span><br><span class="line">    mAtmInternal.attachApplication()    实际调用mRootWindowContainer.attachApplication()</span><br><span class="line">    mServices.attachApplicationLocked()</span><br><span class="line">    ....还有一些app初始化需要启动的东西</span><br><span class="line">    FrameworkStatsLog.write()</span><br></pre></td></tr></table></figure>
<p>handleBindApplication:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ContextImpl.createAppContext() 创建APP context</span><br><span class="line">mInstrumentation = new Instrumentation(); 创建Instrumentation</span><br><span class="line">Application app = data.info.makeApplication() 应用层Application创建，实际调用的mInstrumentation.newApplication()</span><br><span class="line">mInstrumentation.onCreate() 这里是空实现</span><br><span class="line">mInstrumentation.callApplicationOnCreate()  调用的application的onCreate()</span><br></pre></td></tr></table></figure>
<p>mAtmInternal.attachApplication，会调用RootWindowContainer.startActivityForAttachedApplicationIfNeeded,主要是rootTask.forAllActivities(Function&lt;ActivityRecord, Boolean&gt; callback)，其中callback是startActivityForAttachedApplicationIfNeeded方法，<br>forAllActivities中执行的是遍历所有的ActivityRecord子元素，调用子元素的forAllActivities，而在ActivityRecord中forAllActivities重写调用callback.apply(this)，<br>所以rootTask.forAllActivities就是遍历所有的ActivityRecord，对每个ActivityRecord执行一次startActivityForAttachedApplicationIfNeeded:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mRootWindowContainer.attachApplication()</span><br><span class="line">    RootWindowContainer.startActivityForAttachedApplicationIfNeeded </span><br><span class="line">        mStackSupervisor.realStartActivityLocked</span><br></pre></td></tr></table></figure>

<p>也就是不管是启动APP进程，还是APP已经启动，直接启动Activity，最后都会走到mStackSupervisor.realStartActivityLocked：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc,</span><br><span class="line">        boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">            //......</span><br><span class="line"></span><br><span class="line">            //打印event</span><br><span class="line">            EventLogTags.writeWmRestartActivity(r.mUserId, System.identityHashCode(r),</span><br><span class="line">                    task.mTaskId, r.shortComponentName);</span><br><span class="line">            if (r.isActivityTypeHome()) &#123;</span><br><span class="line">                // Home process is the root process of the task.</span><br><span class="line">                updateHomeProcess(task.getBottomMostActivity().app);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // Create activity launch transaction.</span><br><span class="line">            final ClientTransaction clientTransaction = ClientTransaction.obtain(</span><br><span class="line">                    proc.getThread(), r.appToken);</span><br><span class="line"></span><br><span class="line">            final DisplayContent dc = r.getDisplay().mDisplayContent;</span><br><span class="line">            //添加LaunchActivity的事务</span><br><span class="line">            clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    // TODO: Have this take the merged configuration instead of separate global</span><br><span class="line">                    // and override configs.</span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),</span><br><span class="line">                    r.getSavedState(), r.getPersistentSavedState(), results, newIntents,</span><br><span class="line">                    dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),</span><br><span class="line">                    r.assistToken, r.createFixedRotationAdjustmentsIfNeeded()));</span><br><span class="line"></span><br><span class="line">            // Set desired final state.</span><br><span class="line">            final ActivityLifecycleItem lifecycleItem;</span><br><span class="line">            if (andResume) &#123;</span><br><span class="line">                lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">            &#125;</span><br><span class="line">            //设置launch后的后续事务</span><br><span class="line">            clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">            // Schedule transaction.</span><br><span class="line">            //执行事务，会执行ActivityThread中的handleLaunchActivity，及handleResumeActivity</span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看ActivityThread中的handleLaunchActivity:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityThread.handleLaunchActivity()</span><br><span class="line">    ActivityThread.performLaunchActivity()</span><br><span class="line">        ContextImpl appContext = createBaseContextForActivity(r);   //创建Activity的context</span><br><span class="line">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);    //创建Activity</span><br><span class="line">        activity.attach()</span><br><span class="line">        mInstrumentation.callActivityOnCreate()</span><br><span class="line">            prePerformCreate(activity);</span><br><span class="line">            activity.performCreate(icicle);</span><br><span class="line">                onCreate()</span><br><span class="line">                mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); 方法内部window.getDecorView()确保PhoneWindow中的DecorView初始化成功</span><br><span class="line">            postPerformCreate(activity);</span><br></pre></td></tr></table></figure>
<p>也就是说在创建activity后，执行了activity的attach，就调用了onCreate，那就看看attach中做了啥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//...</span><br><span class="line">mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">//...</span><br><span class="line">mWindow.setWindowManager(</span><br><span class="line">                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">                mToken, mComponent.flattenToString(),</span><br><span class="line">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</span><br><span class="line">//...</span><br></pre></td></tr></table></figure>
<p>看起来没有什么复杂的逻辑，就是初始化了window</p>
<p>在ActivityThread中的handleResumeActivity会调用wm.addView，将DecorView添加到Window:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,</span><br><span class="line">        String reason) &#123;</span><br><span class="line">    //......</span><br><span class="line">    final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    //......</span><br><span class="line">    if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        if (r.mPreserveWindow) &#123;</span><br><span class="line">            a.mWindowAdded = true;</span><br><span class="line">            r.mPreserveWindow = false;</span><br><span class="line">            // Normally the ViewRoot sets up callbacks with the Activity</span><br><span class="line">            // in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span><br><span class="line">            // the decor view we have to notify the view root that the</span><br><span class="line">            // callbacks may have changed.</span><br><span class="line">            ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">            if (impl != null) &#123;</span><br><span class="line">                impl.notifyChildRebuilt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.mVisibleFromClient) &#123;</span><br><span class="line">            if (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = true;</span><br><span class="line">                //ViewManager的addiew，实际调用的WindowManagerGlobal.addView</span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // The activity will get a callback for this &#123;@link LayoutParams&#125; change</span><br><span class="line">                // earlier. However, at that time the decor will not be set (this is set</span><br><span class="line">                // in this method), so no action will be taken. This call ensures the</span><br><span class="line">                // callback occurs with the decor set.</span><br><span class="line">                a.onWindowAttributesChanged(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If the window has already been added, but during resume</span><br><span class="line">        // we started another activity, then don&#x27;t yet make the</span><br><span class="line">        // window visible.</span><br><span class="line">    &#125; else if (!willBeVisible) &#123;</span><br><span class="line">        if (localLOGV || enableLifeCycleLog()) Slog.v(TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);</span><br><span class="line">        r.hideForNow = true;</span><br><span class="line">    &#125;</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowManagerGlobal中的addView:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">            Display display, Window parentWindow, int userId) &#123;</span><br><span class="line">    //.....                    </span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = null;</span><br><span class="line">    //......</span><br><span class="line">    //创建ViewRootImpl</span><br><span class="line">    root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">    //保存view到WindowManagerGlobal</span><br><span class="line">    mViews.add(view);</span><br><span class="line">    mRoots.add(root);</span><br><span class="line">    mParams.add(wparams);</span><br><span class="line">    </span><br><span class="line">    // do this last because it fires off messages to start doing things</span><br><span class="line">    try &#123;</span><br><span class="line">        //最后调用ViewRootImpl的setView</span><br><span class="line">        root.setView(view, wparams, panelParentView, userId);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        // BadTokenException or InvalidDisplayException, clean up.</span><br><span class="line">        if (index &gt;= 0) &#123;</span><br><span class="line">            removeViewLocked(index, true);</span><br><span class="line">        &#125;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，Activity和window的层级关系：<br>Activity<br>    PhoneWindow<br>        ViewRootImpl<br>            DecorView</p>
<p>在ViewRootImpl的setView中：</p>
<ol>
<li>调用了requestLayout，内部继续调用 scheduleTraversals， performTraversals</li>
<li>接着又调用了 mWindowSession.addToDisplayAsUser(),内部调用的wms的addWindow</li>
</ol>
<h2 id="getCallingPackage返回null"><a href="#getCallingPackage返回null" class="headerlink" title="getCallingPackage返回null"></a>getCallingPackage返回null</h2><p>getCallingPackage获取的是 将会收到回复的package，<br>在ActivityStarter中有对应的逻辑:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int executeRequest(Request request) &#123;</span><br><span class="line">    //....</span><br><span class="line">    ActivityRecord resultRecord = null;</span><br><span class="line">    if (resultTo != null) &#123;</span><br><span class="line">        sourceRecord = mRootWindowContainer.isInAnyStack(resultTo);</span><br><span class="line">        if (DEBUG_RESULTS) &#123;</span><br><span class="line">            Slog.v(TAG_RESULTS, &quot;Will send result to &quot; + resultTo + &quot; &quot; + sourceRecord);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sourceRecord != null) &#123;</span><br><span class="line">            //只有requestCode &gt;= 0，并且启动此activity的原始activity没有调用finish，才赋值resultRecord</span><br><span class="line">            if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                resultRecord = sourceRecord;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //....</span><br><span class="line">    //在创建ActivityRecord的时候resultRecord就是最终保存的resultTo，getCallingPackage获取的其实就是这个resultRecord</span><br><span class="line">    final ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, callingFeatureId, intent, resolvedType, aInfo,</span><br><span class="line">            mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode,</span><br><span class="line">            request.componentSpecified, voiceSession != null, mSupervisor, checkedOptions,</span><br><span class="line">            sourceRecord);    </span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h2 id="在当前Activity，finish正常流程"><a href="#在当前Activity，finish正常流程" class="headerlink" title="在当前Activity，finish正常流程"></a>在当前Activity，finish正常流程</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram
APP -&gt;&gt; system_server : finish
note right of system_server : finishActivity
note right of system_server : startPausingLocked
system_server -&gt;&gt; APP : ClientLifecycleManager.scheduleTransaction
note right of APP : ActivityThread.scheduleTransaction
note right of APP : ActivityThread.handlePauseActivity
APP -&gt;&gt; system_server : ActivityTaskManagerService.activityPaused
note right of system_server : ActivityRecord.addToStopping
note right of system_server : RootWindowContainer.resumeFocusedStacksTopActivities
system_server -&gt;&gt; APP : ClientLifecycleManager.scheduleTransaction
note right of APP : ActivityThread.scheduleTransaction
note right of APP : ActivityThread.handleResumeActivity
note right of APP : addIdleHandler
APP -&gt;&gt; system_server : ActivityTaskManagerService.activityResumed
note right of APP : 等待触发IdleHandler的queueIdle
APP -&gt;&gt; system_server : ActivityTaskManagerService.activityIdle
note right of system_server : processStoppingAndFinishingActivities
system_server -&gt;&gt; APP : ClientLifecycleManager.scheduleTransaction
note right of APP : ActivityThread.scheduleTransaction
note right of APP : ActivityThread.handleDestroyActivity
note right of APP : ActivityThread.performDestroyActivity

  </pre></div>

<ol>
<li>app进程： 调用finish请求ATMS调用finishActivty</li>
<li>system_server：ATMS的逻辑处理,会调用ActivityThread的handlePauseActivity</li>
<li>app进程: handlePauseActivity，此时会回调Activity的onPause，继续调用ATMS的activityPaused</li>
<li>system_server：在ATMS中会将activty加入到ActivityStackSupervisor的mStoppingActivities，然后将上一个页面resume，添加idle超时</li>
<li>app进程: handleResumeActivity，此时会回调Activty的onResume</li>
<li>app进程: 在handleResumeActivity的最后会向MessageQueue中加入一个IdleHandler</li>
<li>app进程: 等待触发IdleHandler的queueIdle,触发时调用ATMS的activityIdle</li>
<li>system_server：activityIdle逻辑处理，移除idle超时等，然后通知APP处理destory</li>
<li>app进程: handleDestroyActivity，回调Activity的onStop，onDestroy</li>
</ol>
<h2 id="finish方法调用链"><a href="#finish方法调用链" class="headerlink" title="finish方法调用链"></a>finish方法调用链</h2><p><code>Activity#finish</code></p>
<p><code>ActivityTaskManagerService#finishActivity</code></p>
<p><code>ActivityRecord#finishIfPossible</code></p>
<p><code>ActivityStack#startPausingLocked</code></p>
<p><code>ClientLifecycleManager#scheduleTransaction</code></p>
<p><code>TransactionExecutor#execute</code>(具体细节参考<a href="#transactionexecutor%E7%9A%84execute">TransactionExecutor</a>)</p>
<p><code>PauseActivityItem#execute</code></p>
<p><code>ActivityThread#handlePauseActivity</code>(具体细节参考<a href="#handlepauseactivity">Pause处理流程</a>)</p>
<p><code>PauseActivityItem#postExecute</code></p>
<p><code>ActivityTaskManagerService#activityPaused</code></p>
<p><code>ActivityRecord#activityPaused</code></p>
<p><code>ActivityStack#completePauseLocked</code> 这个方法中有2部分，处理pause及下一个页面resume</p>
<p>处理pause逻辑</p>
<p><code>ActivityRecord#completeFinishing</code></p>
<p><code>ActivityRecord#addToStopping</code></p>
<p>将下一个页面resume</p>
<p><code>RootWindowContainer#resumeFocusedStacksTopActivities</code></p>
<p><code>ActivityStack#resumeTopActivityUncheckedLocked</code></p>
<p><code>ActivityStack#resumeTopActivityInnerLocked</code> 方法最后调用了<a href="#completeresumelocked">completeResumeLocked</a></p>
<p><code>ClientLifecycleManager#scheduleTransaction</code> </p>
<p><code>TransactionExecutor#execute</code></p>
<p><code>ResumeActivityItem#execute</code></p>
<p><code>ActivityThread#handleResumeActivity</code>(具体细节参考<a href="#handleresumeactivity">Resume处理流程</a>)</p>
<p><code>ResumeActivityItem#postExecute</code></p>
<p><code>ActivityTaskManagerService#activityResumed</code></p>
<p><code>ActivityRecord#activityResumedLocked</code></p>
<h2 id="TransactionExecutor的execute"><a href="#TransactionExecutor的execute" class="headerlink" title="TransactionExecutor的execute"></a>TransactionExecutor的execute</h2><p>主要调用了2个方法executeCallbacks(方法内部判断transaction有mActivityCallbacks才做业务)，executeLifecycleState(方法内部判断transaction有mLifecycleStateRequest才做业务)<br>ClientTransactionItem是ActivityLifecycleItem的父类，还有其他行为的子类，生命周期类型主要看executeLifecycleState</p>
<p>生命周期相关的事务就看executeLifecycleState这个方法：<br>TransactionExecutor#cycleToPath 这个方法内部去获取了从当前的生命周期到目标生命周期中间未处理的生命周期，然后按顺序执行了一遍<br>ActivityLifecycleItem#execute<br>ActivityLifecycleItem#postExecute</p>
<h2 id="handlePauseActivity"><a href="#handlePauseActivity" class="headerlink" title="handlePauseActivity"></a>handlePauseActivity</h2><p><code>ActivityThread#performPauseActivity</code></p>
<p><code>ActivityThread#performPauseActivityIfNeeded</code></p>
<p><code>Instrumentation#callActivityOnPause</code></p>
<p><code>Activity#performPause</code></p>
<p><code>Activity#onPause</code></p>
<h2 id="handleResumeActivity"><a href="#handleResumeActivity" class="headerlink" title="handleResumeActivity"></a>handleResumeActivity</h2><p><code>ActivityThread#performResumeActivity</code></p>
<p><code>Activity#performResume</code></p>
<p><code>Instrumentation#callActivityOnResume</code></p>
<p><code>Activity#onResume</code></p>
<p>在handleResumeActivity的最后一行代码是：<code>Looper.myQueue().addIdleHandler(new Idler());</code><br>向MessageQueue中添加了一个IdleHandler，在MessageQuene中空闲时会触发这个消息，此时会去处理所有待finish的activity</p>
<h2 id="completeResumeLocked"><a href="#completeResumeLocked" class="headerlink" title="completeResumeLocked"></a>completeResumeLocked</h2><p>completeResumeLocked方法中调用了ActivityStackSupervisor#scheduleIdleTimeout，向handler中发送了一个延时的消息，10s后会处理所有未finish的Activity</p>
<h2 id="startActivty的正常流程"><a href="#startActivty的正常流程" class="headerlink" title="startActivty的正常流程"></a>startActivty的正常流程</h2><p><code>Activity#startActivity</code></p>
<p><code>Activity#startActivityForResult</code></p>
<h2 id="关于ActivityNotFoundException"><a href="#关于ActivityNotFoundException" class="headerlink" title="关于ActivityNotFoundException"></a>关于ActivityNotFoundException</h2><p>在Instrumentation的execStartActivity中，调用的ATMS的startActivityAsUser，会对返回值做判断<br>具体判断逻辑在checkStartActivityResult方法中</p>
<h2 id="接口汇总（笔记）"><a href="#接口汇总（笔记）" class="headerlink" title="接口汇总（笔记）"></a>接口汇总（笔记）</h2><ul>
<li>moveTaskToFront         将对应的app移动到前台</li>
<li>moveActivityTaskToBack  将对应的app栈移动到栈底</li>
<li>getFocusedStackInfo     获取栈顶的任务栈</li>
<li>registerProcessObserver   监听进程变化</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>PMS</title>
    <url>//pages/281417/</url>
    <content><![CDATA[<h2 id="PKMS的启动流程"><a href="#PKMS的启动流程" class="headerlink" title="PKMS的启动流程"></a>PKMS的启动流程</h2><p>PKMS的启动在SystemServer的startBootstrapServices中<br>SystemServer.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void startBootstrapServices(@NonNull TimingsTraceAndSlog t) &#123;</span><br><span class="line">    //......</span><br><span class="line">    t.traceBegin(&quot;StartPackageManagerService&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        Watchdog.getInstance().pauseWatchingCurrentThread(&quot;packagemanagermain&quot;);</span><br><span class="line">        //初始化PMS</span><br><span class="line">        mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Watchdog.getInstance().resumeWatchingCurrentThread(&quot;packagemanagermain&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Now that the package manager has started, register the dex load reporter to capture any</span><br><span class="line">    // dex files loaded by system server.</span><br><span class="line">    // These dex files will be optimized by the BackgroundDexOptService.</span><br><span class="line">    SystemServerDexLoadReporter.configureSystemServerDexReporter(mPackageManagerService);</span><br><span class="line"></span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line">    t.traceEnd();        </span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PackageManagerService.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static PackageManagerService main(Context context, Installer installer,</span><br><span class="line">        boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">    // Self-check for initial settings.</span><br><span class="line">    PackageManagerServiceCompilerMapping.checkProperties();</span><br><span class="line">    final TimingsTraceAndSlog t = new TimingsTraceAndSlog(TAG + &quot;Timing&quot;,</span><br><span class="line">            Trace.TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    t.traceBegin(&quot;create package manager&quot;);</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    PackageManagerService m = new PackageManagerService(injector, onlyCore, factoryTest);</span><br><span class="line">    t.traceEnd(); // &quot;create package manager&quot;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    m.installWhitelistedSystemPackages();</span><br><span class="line">    ServiceManager.addService(&quot;package&quot;, m);</span><br><span class="line">    final PackageManagerNative pmn = m.new PackageManagerNative();</span><br><span class="line">    ServiceManager.addService(&quot;package_native&quot;, pmn);</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以主要看PKMS的构造方法,PKMS构造方法中会去扫描指定目录下的packages</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public PackageManagerService(Injector injector, boolean onlyCore, boolean factoryTest) &#123;</span><br><span class="line">    //......</span><br><span class="line">    mDirsToScanAsSystem = new ArrayList&lt;&gt;();</span><br><span class="line">    mDirsToScanAsSystem.addAll(SYSTEM_PARTITIONS);</span><br><span class="line">    mDirsToScanAsSystem.addAll(scanPartitions);</span><br><span class="line">    Slog.d(TAG, &quot;Directories scanned as system partitions: &quot; + mDirsToScanAsSystem);        </span><br><span class="line">    // CHECKSTYLE:OFF IndentationCheck</span><br><span class="line">    synchronized (mInstallLock) &#123;</span><br><span class="line">    // writer</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        //......</span><br><span class="line">        // Collect vendor/product/system_ext overlay packages. (Do this before scanning</span><br><span class="line">        // any apps.)</span><br><span class="line">        // For security and version matching reason, only consider overlay packages if they</span><br><span class="line">        // reside in the right directory.</span><br><span class="line">        //这里先去扫描有overlay子目录的目录下的包</span><br><span class="line">        for (int i = mDirsToScanAsSystem.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            final ScanPartition partition = mDirsToScanAsSystem.get(i);</span><br><span class="line">            if (partition.getOverlayFolder() == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            scanDirTracedLI(partition.getOverlayFolder(), systemParseFlags,</span><br><span class="line">                    systemScanFlags | partition.scanFlag, 0,</span><br><span class="line">                    packageParser, executorService);</span><br><span class="line">        &#125;</span><br><span class="line">        // 扫描/system/framework下的包</span><br><span class="line">        scanDirTracedLI(frameworkDir, systemParseFlags,</span><br><span class="line">                systemScanFlags | SCAN_NO_DEX | SCAN_AS_PRIVILEGED, 0,</span><br><span class="line">                packageParser, executorService);</span><br><span class="line">        // 没有扫描到 android 这个包就直接抛出异常                    </span><br><span class="line">        if (!mPackages.containsKey(&quot;android&quot;)) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;Failed to load frameworks package; check log for warnings&quot;);</span><br><span class="line">        &#125; </span><br><span class="line">        // 扫描所有ROM预置app的所有目录           </span><br><span class="line">        for (int i = 0, size = mDirsToScanAsSystem.size(); i &lt; size; i++) &#123;</span><br><span class="line">            final ScanPartition partition = mDirsToScanAsSystem.get(i);</span><br><span class="line">            if (partition.getPrivAppFolder() != null) &#123;</span><br><span class="line">                scanDirTracedLI(partition.getPrivAppFolder(), systemParseFlags,</span><br><span class="line">                        systemScanFlags | SCAN_AS_PRIVILEGED | partition.scanFlag, 0,</span><br><span class="line">                        packageParser, executorService);</span><br><span class="line">            &#125;</span><br><span class="line">            scanDirTracedLI(partition.getAppFolder(), systemParseFlags,</span><br><span class="line">                    systemScanFlags | partition.scanFlag, 0,</span><br><span class="line">                    packageParser, executorService);</span><br><span class="line">        &#125;            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; // synchronized (mLock)</span><br><span class="line">    &#125; // synchronized (mInstallLock)</span><br><span class="line">    // CHECKSTYLE:ON IndentationCheck                    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>ParsingPackageImpl.java</p>
<p>在pms启动的时候,会去读用户设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t.traceBegin(&quot;read user settings&quot;);</span><br><span class="line">mFirstBoot = !mSettings.readLPw(mInjector.getUserManagerInternal().getUsers(</span><br><span class="line">        /* excludePartial= */ true,</span><br><span class="line">        /* excludeDying= */ false,</span><br><span class="line">        /* excludePreCreated= */ false));</span><br><span class="line">t.traceEnd();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Settings.java中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//package的settings文件是/data/system/packages.xml</span><br><span class="line">mSettingsFilename = new File(mSystemDir, &quot;packages.xml&quot;);</span><br><span class="line"></span><br><span class="line">boolean readLPw(@NonNull List&lt;UserInfo&gt; users) &#123;</span><br><span class="line">    FileInputStream str = null;</span><br><span class="line">    //......</span><br><span class="line">        str = new FileInputStream(mSettingsFilename);</span><br><span class="line">    //......</span><br><span class="line">            if (tagName.equals(&quot;package&quot;)) &#123;</span><br><span class="line">                readPackageLPw(parser);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="阶段1-boot-progress-pms-start"><a href="#阶段1-boot-progress-pms-start" class="headerlink" title="阶段1-boot_progress_pms_start"></a>阶段1-boot_progress_pms_start</h3><p>对应tag：<code>EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis());</code></p>
<p>在PMS的构造函数中，这个阶段主要初始化一些全局变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The list of all system partitions that may contain packages in ascending order of</span><br><span class="line"> * specificity (the more generic, the earlier in the list a partition appears).</span><br><span class="line"> */</span><br><span class="line">@VisibleForTesting(visibility = Visibility.PRIVATE)</span><br><span class="line">public static final List&lt;ScanPartition&gt; SYSTEM_PARTITIONS = Collections.unmodifiableList(</span><br><span class="line">        PackagePartitions.getOrderedPartitions(ScanPartition::new));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public PackageManagerService(Injector injector, boolean onlyCore, boolean factoryTest) &#123;</span><br><span class="line">    PackageManager.disableApplicationInfoCache();</span><br><span class="line">    PackageManager.disablePackageInfoCache();</span><br><span class="line"></span><br><span class="line">    // Avoid invalidation-thrashing by preventing cache invalidations from causing property</span><br><span class="line">    // writes if the cache isn&#x27;t enabled yet.  We re-enable writes later when we&#x27;re</span><br><span class="line">    // done initializing.</span><br><span class="line">    PackageManager.corkPackageInfoCache();</span><br><span class="line"></span><br><span class="line">    final TimingsTraceAndSlog t = new TimingsTraceAndSlog(TAG + &quot;Timing&quot;,</span><br><span class="line">            Trace.TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    mPendingBroadcasts = new PendingPackageBroadcasts();</span><br><span class="line"></span><br><span class="line">    mInjector = injector;</span><br><span class="line">    mInjector.bootstrap(this);</span><br><span class="line">    mLock = injector.getLock();</span><br><span class="line">    mInstallLock = injector.getInstallLock();</span><br><span class="line">    LockGuard.installLock(mLock, LockGuard.INDEX_PACKAGES);</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    if (mSdkVersion &lt;= 0) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;**** ro.build.version.sdk not set!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mContext = injector.getContext();</span><br><span class="line">    mFactoryTest = factoryTest;</span><br><span class="line">    mOnlyCore = onlyCore;</span><br><span class="line">    //创建DisplayMetrics保存分辨率相关信息</span><br><span class="line">    mMetrics = new DisplayMetrics();</span><br><span class="line">    mInstaller = injector.getInstaller();</span><br><span class="line"></span><br><span class="line">    // Create sub-components that provide services / data. Order here is important.</span><br><span class="line">    t.traceBegin(&quot;createSubComponents&quot;);</span><br><span class="line"></span><br><span class="line">    // Expose private service for system components to use.</span><br><span class="line">    mPmInternal = new PackageManagerInternalImpl();</span><br><span class="line">    LocalServices.addService(PackageManagerInternal.class, mPmInternal);</span><br><span class="line">    mUserManager = injector.getUserManagerService();</span><br><span class="line">    mComponentResolver = injector.getComponentResolver();</span><br><span class="line">    mPermissionManager = injector.getPermissionManagerServiceInternal();</span><br><span class="line">    mSettings = injector.getSettings();</span><br><span class="line">    mPermissionManagerService = (IPermissionManager) ServiceManager.getService(&quot;permissionmgr&quot;);</span><br><span class="line">    mIncrementalManager =</span><br><span class="line">            (IncrementalManager) mContext.getSystemService(Context.INCREMENTAL_SERVICE);</span><br><span class="line">    PlatformCompat platformCompat = mInjector.getCompatibility();</span><br><span class="line">    mPackageParserCallback = new PackageParser2.Callback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean isChangeEnabled(long changeId, @NonNull ApplicationInfo appInfo) &#123;</span><br><span class="line">            return platformCompat.isChangeEnabled(changeId, appInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasFeature(String feature) &#123;</span><br><span class="line">            return PackageManagerService.this.hasSystemFeature(feature, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // CHECKSTYLE:ON IndentationCheck</span><br><span class="line">    t.traceEnd();</span><br><span class="line"></span><br><span class="line">    //初始化几个系统UID</span><br><span class="line">    t.traceBegin(&quot;addSharedUsers&quot;);</span><br><span class="line">    mSettings.addSharedUserLPw(&quot;android.uid.system&quot;, Process.SYSTEM_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(&quot;android.uid.phone&quot;, RADIO_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(&quot;android.uid.log&quot;, LOG_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(&quot;android.uid.nfc&quot;, NFC_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(&quot;android.uid.bluetooth&quot;, BLUETOOTH_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(&quot;android.uid.shell&quot;, SHELL_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(&quot;android.uid.se&quot;, SE_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(&quot;android.uid.networkstack&quot;, NETWORKSTACK_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    t.traceEnd();</span><br><span class="line"></span><br><span class="line">    String separateProcesses = SystemProperties.get(&quot;debug.separate_processes&quot;);</span><br><span class="line">    if (separateProcesses != null &amp;&amp; separateProcesses.length() &gt; 0) &#123;</span><br><span class="line">        if (&quot;*&quot;.equals(separateProcesses)) &#123;</span><br><span class="line">            mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;</span><br><span class="line">            mSeparateProcesses = null;</span><br><span class="line">            Slog.w(TAG, &quot;Running with debug.separate_processes: * (ALL)&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mDefParseFlags = 0;</span><br><span class="line">            mSeparateProcesses = separateProcesses.split(&quot;,&quot;);</span><br><span class="line">            Slog.w(TAG, &quot;Running with debug.separate_processes: &quot;</span><br><span class="line">                    + separateProcesses);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mDefParseFlags = 0;</span><br><span class="line">        mSeparateProcesses = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPackageDexOptimizer = new PackageDexOptimizer(mInstaller, mInstallLock, mContext,</span><br><span class="line">            &quot;*dexopt*&quot;);</span><br><span class="line">    mDexManager =</span><br><span class="line">            new DexManager(mContext, this, mPackageDexOptimizer, mInstaller, mInstallLock);</span><br><span class="line">    mArtManagerService = new ArtManagerService(mContext, this, mInstaller, mInstallLock);</span><br><span class="line">    mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">    mViewCompiler = new ViewCompiler(mInstallLock, mInstaller);</span><br><span class="line"></span><br><span class="line">    //初始化屏幕分辨率信息</span><br><span class="line">    getDefaultDisplayMetrics(mInjector.getDisplayManager(), mMetrics);</span><br><span class="line"></span><br><span class="line">    t.traceBegin(&quot;get system config&quot;);</span><br><span class="line">    SystemConfig systemConfig = SystemConfig.getInstance();</span><br><span class="line">    mAvailableFeatures = systemConfig.getAvailableFeatures();</span><br><span class="line">    ApplicationPackageManager.invalidateHasSystemFeatureCache();</span><br><span class="line">    t.traceEnd();</span><br><span class="line"></span><br><span class="line">    mProtectedPackages = new ProtectedPackages(mContext);</span><br><span class="line"></span><br><span class="line">    mApexManager = ApexManager.getInstance();</span><br><span class="line">    mAppsFilter = mInjector.getAppsFilter();</span><br><span class="line"></span><br><span class="line">    final List&lt;ScanPartition&gt; scanPartitions = new ArrayList&lt;&gt;();</span><br><span class="line">    final List&lt;ApexManager.ActiveApexInfo&gt; activeApexInfos = mApexManager.getActiveApexInfos();</span><br><span class="line">    for (int i = 0; i &lt; activeApexInfos.size(); i++) &#123;</span><br><span class="line">        final ScanPartition scanPartition = resolveApexToScanPartition(activeApexInfos.get(i));</span><br><span class="line">        if (scanPartition != null) &#123;</span><br><span class="line">            scanPartitions.add(scanPartition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化要扫描apk的目录,SYSTEM_PARTITIONS是一个不可编辑的List常量，其中的成员，根据type初始化了各自的scanFlag</span><br><span class="line">    mDirsToScanAsSystem = new ArrayList&lt;&gt;();</span><br><span class="line">    mDirsToScanAsSystem.addAll(SYSTEM_PARTITIONS);</span><br><span class="line">    mDirsToScanAsSystem.addAll(scanPartitions);</span><br><span class="line">    Slog.d(TAG, &quot;Directories scanned as system partitions: &quot; + mDirsToScanAsSystem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="阶段2-boot-progress-pms-system-scan-start"><a href="#阶段2-boot-progress-pms-system-scan-start" class="headerlink" title="阶段2-boot_progress_pms_system_scan_start"></a>阶段2-boot_progress_pms_system_scan_start</h3><p>对应tag:<code>EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, startTime);</code><br>这个阶段是去扫描各个分区下的预置APP目录<br>扫描完成后有对应的log打印：<code>Finished scanning system apps</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,</span><br><span class="line">        startTime);</span><br><span class="line"></span><br><span class="line">//获取环境变量 BOOTCLASSPATH 和 SYSTEMSERVERCLASSPATH</span><br><span class="line">final String bootClassPath = System.getenv(&quot;BOOTCLASSPATH&quot;);</span><br><span class="line">final String systemServerClassPath = System.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</span><br><span class="line"></span><br><span class="line">if (bootClassPath == null) &#123;</span><br><span class="line">    Slog.w(TAG, &quot;No BOOTCLASSPATH found!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (systemServerClassPath == null) &#123;</span><br><span class="line">    Slog.w(TAG, &quot;No SYSTEMSERVERCLASSPATH found!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /system/framework目录</span><br><span class="line">File frameworkDir = new File(Environment.getRootDirectory(), &quot;framework&quot;);  </span><br><span class="line"></span><br><span class="line">//.....</span><br><span class="line"></span><br><span class="line">//设置基础的扫描的flag</span><br><span class="line">// Set flag to monitor and not change apk file paths when</span><br><span class="line">// scanning install directories.</span><br><span class="line">int scanFlags = SCAN_BOOTING | SCAN_INITIAL;</span><br><span class="line"></span><br><span class="line">if (mIsUpgrade || mFirstBoot) &#123;</span><br><span class="line">    scanFlags = scanFlags | SCAN_FIRST_BOOT_OR_UPGRADE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化 系统app解析flag 和 系统app扫描flag</span><br><span class="line">final int systemParseFlags = mDefParseFlags | PackageParser.PARSE_IS_SYSTEM_DIR;</span><br><span class="line">final int systemScanFlags = scanFlags | SCAN_AS_SYSTEM;</span><br><span class="line"></span><br><span class="line">PackageParser2 packageParser = new PackageParser2(mSeparateProcesses, mOnlyCore,</span><br><span class="line">        mMetrics, mCacheDir, mPackageParserCallback);</span><br><span class="line"></span><br><span class="line">ExecutorService executorService = ParallelPackageParser.makeExecutorService();</span><br><span class="line">// Prepare apex package info before scanning APKs, these information are needed when</span><br><span class="line">// scanning apk in apex.</span><br><span class="line">mApexManager.scanApexPackagesTraced(packageParser, executorService);</span><br><span class="line">// Collect vendor/product/system_ext overlay packages. (Do this before scanning</span><br><span class="line">// any apps.)</span><br><span class="line">// For security and version matching reason, only consider overlay packages if they</span><br><span class="line">// reside in the right directory.</span><br><span class="line">//这里先去扫描的各个系统分区下的overlay目录下的包</span><br><span class="line">for (int i = mDirsToScanAsSystem.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    final ScanPartition partition = mDirsToScanAsSystem.get(i);</span><br><span class="line">    if (partition.getOverlayFolder() == null) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    scanDirTracedLI(partition.getOverlayFolder(), systemParseFlags,</span><br><span class="line">            systemScanFlags | partition.scanFlag, 0,</span><br><span class="line">            packageParser, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扫描 /system/framework目录 </span><br><span class="line">scanDirTracedLI(frameworkDir, systemParseFlags,</span><br><span class="line">        systemScanFlags | SCAN_NO_DEX | SCAN_AS_PRIVILEGED, 0,</span><br><span class="line">        packageParser, executorService);</span><br><span class="line">//没找到 android 这个包直接抛异常</span><br><span class="line">if (!mPackages.containsKey(&quot;android&quot;)) &#123;</span><br><span class="line">    throw new IllegalStateException(</span><br><span class="line">            &quot;Failed to load frameworks package; check log for warnings&quot;);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0, size = mDirsToScanAsSystem.size(); i &lt; size; i++) &#123;</span><br><span class="line">    final ScanPartition partition = mDirsToScanAsSystem.get(i);</span><br><span class="line">    if (partition.getPrivAppFolder() != null) &#123;</span><br><span class="line">        //扫描 各个系统分区下的 priv-app 目录</span><br><span class="line">        scanDirTracedLI(partition.getPrivAppFolder(), systemParseFlags,</span><br><span class="line">                systemScanFlags | SCAN_AS_PRIVILEGED | partition.scanFlag, 0,</span><br><span class="line">                packageParser, executorService);</span><br><span class="line">    &#125;</span><br><span class="line">    //扫描各个系统分区下的 app 目录</span><br><span class="line">    scanDirTracedLI(partition.getAppFolder(), systemParseFlags,</span><br><span class="line">            systemScanFlags | partition.scanFlag, 0,</span><br><span class="line">            packageParser, executorService);</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line">// Parse overlay configuration files to set default enable state, mutability, and</span><br><span class="line">// priority of system overlays.</span><br><span class="line">mOverlayConfig = OverlayConfig.initializeSystemInstance(</span><br><span class="line">        consumer -&gt; mPmInternal.forEachPackage(</span><br><span class="line">                pkg -&gt; consumer.accept(pkg, pkg.isSystem())));</span><br><span class="line"></span><br><span class="line">// Prune any system packages that no longer exist.</span><br><span class="line">final List&lt;String&gt; possiblyDeletedUpdatedSystemApps = new ArrayList&lt;&gt;();</span><br><span class="line">// Stub packages must either be replaced with full versions in the /data</span><br><span class="line">// partition or be disabled.</span><br><span class="line">final List&lt;String&gt; stubSystemApps = new ArrayList&lt;&gt;();</span><br><span class="line">if (!mOnlyCore) &#123;</span><br><span class="line">    // do this first before mucking with mPackages for the &quot;expecting better&quot; case</span><br><span class="line">    final Iterator&lt;AndroidPackage&gt; pkgIterator = mPackages.values().iterator();</span><br><span class="line">    while (pkgIterator.hasNext()) &#123;</span><br><span class="line">        final AndroidPackage pkg = pkgIterator.next();</span><br><span class="line">        if (pkg.isStub()) &#123;</span><br><span class="line">            stubSystemApps.add(pkg.getPackageName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</span><br><span class="line">    while (psit.hasNext()) &#123;</span><br><span class="line">        PackageSetting ps = psit.next();</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * If this is not a system app, it can&#x27;t be a</span><br><span class="line">         * disable system app.</span><br><span class="line">         */</span><br><span class="line">        if ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * If the package is scanned, it&#x27;s not erased.</span><br><span class="line">         */</span><br><span class="line">        final AndroidPackage scannedPkg = mPackages.get(ps.name);</span><br><span class="line">        if (scannedPkg != null) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * If the system app is both scanned and in the</span><br><span class="line">             * disabled packages list, then it must have been</span><br><span class="line">             * added via OTA. Remove it from the currently</span><br><span class="line">             * scanned package so the previously user-installed</span><br><span class="line">             * application can be scanned.</span><br><span class="line">             */</span><br><span class="line">            if (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">                logCriticalInfo(Log.WARN,</span><br><span class="line">                        &quot;Expecting better updated system app for &quot; + ps.name</span><br><span class="line">                        + &quot;; removing system app.  Last known&quot;</span><br><span class="line">                        + &quot; codePath=&quot; + ps.codePathString</span><br><span class="line">                        + &quot;, versionCode=&quot; + ps.versionCode</span><br><span class="line">                        + &quot;; scanned versionCode=&quot; + scannedPkg.getLongVersionCode());</span><br><span class="line">                removePackageLI(scannedPkg, true);</span><br><span class="line">                mExpectingBetter.put(ps.name, ps.codePath);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">            psit.remove();</span><br><span class="line">            logCriticalInfo(Log.WARN, &quot;System package &quot; + ps.name</span><br><span class="line">                    + &quot; no longer exists; it&#x27;s data will be wiped&quot;);</span><br><span class="line"></span><br><span class="line">            // Assume package is truly gone and wipe residual permissions.</span><br><span class="line">            mPermissionManager.updatePermissions(ps.name, null);</span><br><span class="line"></span><br><span class="line">            // Actual deletion of code and data will be handled by later</span><br><span class="line">            // reconciliation step</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // we still have a disabled system package, but, it still might have</span><br><span class="line">            // been removed. check the code path still exists and check there&#x27;s</span><br><span class="line">            // still a package. the latter can happen if an OTA keeps the same</span><br><span class="line">            // code path, but, changes the package name.</span><br><span class="line">            final PackageSetting disabledPs =</span><br><span class="line">                    mSettings.getDisabledSystemPkgLPr(ps.name);</span><br><span class="line">            if (disabledPs.codePath == null || !disabledPs.codePath.exists()</span><br><span class="line">                    || disabledPs.pkg == null) &#123;</span><br><span class="line">                possiblyDeletedUpdatedSystemApps.add(ps.name);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // We&#x27;re expecting that the system app should remain disabled, but add</span><br><span class="line">                // it to expecting better to recover in case the data version cannot</span><br><span class="line">                // be scanned.</span><br><span class="line">                mExpectingBetter.put(disabledPs.name, disabledPs.codePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final int cachedSystemApps = PackageCacher.sCachedPackageReadCount.get();</span><br><span class="line"></span><br><span class="line">// Remove any shared userIDs that have no associated packages</span><br><span class="line">mSettings.pruneSharedUsersLPw();</span><br><span class="line">final long systemScanTime = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">final int systemPackagesCount = mPackages.size();</span><br><span class="line">// 扫描完成后会打印 log</span><br><span class="line">Slog.i(TAG, &quot;Finished scanning system apps. Time: &quot; + systemScanTime</span><br><span class="line">        + &quot; ms, packageCount: &quot; + systemPackagesCount</span><br><span class="line">        + &quot; , timePerPackage: &quot;</span><br><span class="line">        + (systemPackagesCount == 0 ? 0 : systemScanTime / systemPackagesCount)</span><br><span class="line">        + &quot; , cached: &quot; + cachedSystemApps);</span><br><span class="line">if (mIsUpgrade &amp;&amp; systemPackagesCount &gt; 0) &#123;</span><br><span class="line">    //CHECKSTYLE:OFF IndentationCheck</span><br><span class="line">    FrameworkStatsLog.write(FrameworkStatsLog.BOOT_TIME_EVENT_DURATION_REPORTED,</span><br><span class="line">        BOOT_TIME_EVENT_DURATION__EVENT__OTA_PACKAGE_MANAGER_SYSTEM_APP_AVG_SCAN_TIME,</span><br><span class="line">        systemScanTime / systemPackagesCount);</span><br><span class="line">    //CHECKSTYLE:ON IndentationCheck</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

<h3 id="阶段3-boot-progress-pms-data-scan-start"><a href="#阶段3-boot-progress-pms-data-scan-start" class="headerlink" title="阶段3-boot_progress_pms_data_scan_start"></a>阶段3-boot_progress_pms_data_scan_start</h3><p>对应tag：<code>EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, SystemClock.uptimeMillis());</code><br>这个阶段会去扫描 &#x2F;data 分区下的apk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!mOnlyCore) &#123;</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line">    // 扫描 /data/app 下的包</span><br><span class="line">    scanDirTracedLI(sAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0,</span><br><span class="line">            packageParser, executorService);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">packageParser.close();</span><br><span class="line"></span><br><span class="line">List&lt;Runnable&gt; unfinishedTasks = executorService.shutdownNow();</span><br><span class="line">if (!unfinishedTasks.isEmpty()) &#123;</span><br><span class="line">    throw new IllegalStateException(&quot;Not all tasks finished before calling close: &quot;</span><br><span class="line">            + unfinishedTasks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!mOnlyCore) &#123;</span><br><span class="line">    // Remove disable package settings for updated system apps that were</span><br><span class="line">    // removed via an OTA. If the update is no longer present, remove the</span><br><span class="line">    // app completely. Otherwise, revoke their system privileges.</span><br><span class="line">    // 这里去遍历所有已经删除的systemapp（有设置，但扫描不到包）</span><br><span class="line">    for (int i = possiblyDeletedUpdatedSystemApps.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        final String packageName = possiblyDeletedUpdatedSystemApps.get(i);</span><br><span class="line">        final AndroidPackage pkg = mPackages.get(packageName);</span><br><span class="line">        final String msg;</span><br><span class="line"></span><br><span class="line">        // remove from the disabled system list; do this first so any future</span><br><span class="line">        // scans of this package are performed without this state</span><br><span class="line">        mSettings.removeDisabledSystemPackageLPw(packageName);</span><br><span class="line"></span><br><span class="line">        if (pkg == null) &#123;</span><br><span class="line">            // should have found an update, but, we didn&#x27;t; remove everything</span><br><span class="line">            msg = &quot;Updated system package &quot; + packageName</span><br><span class="line">                    + &quot; no longer exists; removing its data&quot;;</span><br><span class="line">            // Actual deletion of code and data will be handled by later</span><br><span class="line">            // reconciliation step</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // found an update; revoke system privileges</span><br><span class="line">            msg = &quot;Updated system package &quot; + packageName</span><br><span class="line">                    + &quot; no longer exists; rescanning package on data&quot;;</span><br><span class="line"></span><br><span class="line">            // NOTE: We don&#x27;t do anything special if a stub is removed from the</span><br><span class="line">            // system image. But, if we were [like removing the uncompressed</span><br><span class="line">            // version from the /data partition], this is where it&#x27;d be done.</span><br><span class="line"></span><br><span class="line">            // remove the package from the system and re-scan it without any</span><br><span class="line">            // special privileges</span><br><span class="line">            removePackageLI(pkg, true);</span><br><span class="line">            try &#123;</span><br><span class="line">                final File codePath = new File(pkg.getCodePath());</span><br><span class="line">                scanPackageTracedLI(codePath, 0, scanFlags, 0, null);</span><br><span class="line">            &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">                Slog.e(TAG, &quot;Failed to parse updated, ex-system package: &quot;</span><br><span class="line">                        + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // one final check. if we still have a package setting [ie. it was</span><br><span class="line">        // previously scanned and known to the system], but, we don&#x27;t have</span><br><span class="line">        // a package [ie. there was an error scanning it from the /data</span><br><span class="line">        // partition], completely remove the package data.</span><br><span class="line">        final PackageSetting ps = mSettings.mPackages.get(packageName);</span><br><span class="line">        if (ps != null &amp;&amp; mPackages.get(packageName) == null) &#123;</span><br><span class="line">            removePackageDataLIF(ps, null, null, 0, false);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        logCriticalInfo(Log.WARN, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Make sure all system apps that we expected to appear on</span><br><span class="line">     * the userdata partition actually showed up. If they never</span><br><span class="line">     * appeared, crawl back and revive the system version.</span><br><span class="line">     */</span><br><span class="line">    for (int i = 0; i &lt; mExpectingBetter.size(); i++) &#123;</span><br><span class="line">        final String packageName = mExpectingBetter.keyAt(i);</span><br><span class="line">        if (!mPackages.containsKey(packageName)) &#123;</span><br><span class="line">            final File scanFile = mExpectingBetter.valueAt(i);</span><br><span class="line"></span><br><span class="line">            logCriticalInfo(Log.WARN, &quot;Expected better &quot; + packageName</span><br><span class="line">                    + &quot; but never showed up; reverting to system&quot;);</span><br><span class="line"></span><br><span class="line">            @ParseFlags int reparseFlags = 0;</span><br><span class="line">            @ScanFlags int rescanFlags = 0;</span><br><span class="line">            for (int i1 = mDirsToScanAsSystem.size() - 1; i1 &gt;= 0; i1--) &#123;</span><br><span class="line">                final ScanPartition partition = mDirsToScanAsSystem.get(i1);</span><br><span class="line">                if (partition.containsPrivApp(scanFile)) &#123;</span><br><span class="line">                    reparseFlags = systemParseFlags;</span><br><span class="line">                    rescanFlags = systemScanFlags | SCAN_AS_PRIVILEGED</span><br><span class="line">                            | partition.scanFlag;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (partition.containsApp(scanFile)) &#123;</span><br><span class="line">                    reparseFlags = systemParseFlags;</span><br><span class="line">                    rescanFlags = systemScanFlags | partition.scanFlag;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (rescanFlags == 0) &#123;</span><br><span class="line">                Slog.e(TAG, &quot;Ignoring unexpected fallback path &quot; + scanFile);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            mSettings.enableSystemPackageLPw(packageName);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                scanPackageTracedLI(scanFile, reparseFlags, rescanFlags, 0, null);</span><br><span class="line">            &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">                Slog.e(TAG, &quot;Failed to parse original system package: &quot;</span><br><span class="line">                        + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Uncompress and install any stubbed system applications.</span><br><span class="line">    // This must be done last to ensure all stubs are replaced or disabled.</span><br><span class="line">    installSystemStubPackages(stubSystemApps, scanFlags);</span><br><span class="line"></span><br><span class="line">    final int cachedNonSystemApps = PackageCacher.sCachedPackageReadCount.get()</span><br><span class="line">                    - cachedSystemApps;</span><br><span class="line"></span><br><span class="line">    final long dataScanTime = SystemClock.uptimeMillis() - systemScanTime - startTime;</span><br><span class="line">    final int dataPackagesCount = mPackages.size() - systemPackagesCount;</span><br><span class="line">    Slog.i(TAG, &quot;Finished scanning non-system apps. Time: &quot; + dataScanTime</span><br><span class="line">            + &quot; ms, packageCount: &quot; + dataPackagesCount</span><br><span class="line">            + &quot; , timePerPackage: &quot;</span><br><span class="line">            + (dataPackagesCount == 0 ? 0 : dataScanTime / dataPackagesCount)</span><br><span class="line">            + &quot; , cached: &quot; + cachedNonSystemApps);</span><br><span class="line">    if (mIsUpgrade &amp;&amp; dataPackagesCount &gt; 0) &#123;</span><br><span class="line">        //CHECKSTYLE:OFF IndentationCheck</span><br><span class="line">        FrameworkStatsLog.write(</span><br><span class="line">            FrameworkStatsLog.BOOT_TIME_EVENT_DURATION_REPORTED,</span><br><span class="line">            BOOT_TIME_EVENT_DURATION__EVENT__OTA_PACKAGE_MANAGER_DATA_APP_AVG_SCAN_TIME,</span><br><span class="line">            dataScanTime / dataPackagesCount);</span><br><span class="line">        //CHECKSTYLE:OFF IndentationCheck</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mExpectingBetter.clear();</span><br><span class="line"></span><br><span class="line">// Resolve the storage manager.</span><br><span class="line">mStorageManagerPackage = getStorageManagerPackageName();</span><br><span class="line"></span><br><span class="line">// Resolve protected action filters. Only the setup wizard is allowed to</span><br><span class="line">// have a high priority filter for these actions.</span><br><span class="line">mSetupWizardPackage = getSetupWizardPackageNameImpl();</span><br><span class="line">mComponentResolver.fixProtectedFilterPriorities();</span><br><span class="line"></span><br><span class="line">mDefaultTextClassifierPackage = getDefaultTextClassifierPackageName();</span><br><span class="line">mSystemTextClassifierPackageName = getSystemTextClassifierPackageName();</span><br><span class="line">mWellbeingPackage = getWellbeingPackageName();</span><br><span class="line">mDocumenterPackage = getDocumenterPackageName();</span><br><span class="line">mConfiguratorPackage = getDeviceConfiguratorPackageName();</span><br><span class="line">mAppPredictionServicePackage = getAppPredictionServicePackageName();</span><br><span class="line">mIncidentReportApproverPackage = getIncidentReportApproverPackageName();</span><br><span class="line">mRetailDemoPackage = getRetailDemoPackageName();</span><br><span class="line"></span><br><span class="line">// Now that we know all of the shared libraries, update all clients to have</span><br><span class="line">// the correct library paths.</span><br><span class="line">updateAllSharedLibrariesLocked(null, null, Collections.unmodifiableMap(mPackages));</span><br><span class="line"></span><br><span class="line">for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</span><br><span class="line">    // NOTE: We ignore potential failures here during a system scan (like</span><br><span class="line">    // the rest of the commands above) because there&#x27;s precious little we</span><br><span class="line">    // can do about it. A settings error is reported, though.</span><br><span class="line">    final List&lt;String&gt; changedAbiCodePath =</span><br><span class="line">            applyAdjustedAbiToSharedUser(setting, null /*scannedPackage*/,</span><br><span class="line">            mInjector.getAbiHelper().getAdjustedAbiForSharedUser(</span><br><span class="line">                    setting.packages, null /*scannedPackage*/));</span><br><span class="line">    if (changedAbiCodePath != null &amp;&amp; changedAbiCodePath.size() &gt; 0) &#123;</span><br><span class="line">        for (int i = changedAbiCodePath.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            final String codePathString = changedAbiCodePath.get(i);</span><br><span class="line">            try &#123;</span><br><span class="line">                mInstaller.rmdex(codePathString,</span><br><span class="line">                        getDexCodeInstructionSet(getPreferredInstructionSet()));</span><br><span class="line">            &#125; catch (InstallerException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Adjust seInfo to ensure apps which share a sharedUserId are placed in the same</span><br><span class="line">    // SELinux domain.</span><br><span class="line">    setting.fixSeInfoLocked();</span><br><span class="line">    setting.updateProcesses();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="APK解析"><a href="#APK解析" class="headerlink" title="APK解析"></a>APK解析</h3><p>在PMS进行扫描scanPackageLI和安装app后preparePackageLI的时候会调用PackageParser2的parsePackage去解析apk，<br>实际使用的ParsingPackageUtils来进行apk解析<br>parseBaseApplication中对AndroidManifest.xml进行了解析</p>
]]></content>
  </entry>
  <entry>
    <title>WMS</title>
    <url>//pages/c0d3d8/</url>
    <content><![CDATA[<h2 id="先看看WMS的启动"><a href="#先看看WMS的启动" class="headerlink" title="先看看WMS的启动"></a>先看看WMS的启动</h2><p>SystemServer的startOtherServices中<a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/java/com/android/server/SystemServer.java#1163">启动</a>的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t.traceBegin(&quot;StartWindowManagerService&quot;);</span><br><span class="line">// WMS needs sensor service ready</span><br><span class="line">ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);</span><br><span class="line">mSensorServiceStart = null;</span><br><span class="line">wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,</span><br><span class="line">        new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);</span><br><span class="line">ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= */ false,</span><br><span class="line">        DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);</span><br><span class="line">ServiceManager.addService(Context.INPUT_SERVICE, inputManager,</span><br><span class="line">        /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">t.traceEnd();</span><br></pre></td></tr></table></figure>

<p>主要逻辑：<br>在DisplayThread（android.display）中调用handler的runWithScissors创建了一个WindowManagerService.<br>关于runWithScissors，可以理解为在当前线程中插入一个优先执行的任务。当前的线程会被阻塞，直到runWithScissors中的runnable执行完毕。</p>
<p>WMS的构造方法中初始化&#x2F;保存ATMS、WindowManagerPolicy、InputManagerService等多个系统服务</p>
<p>WMS创建成功后，继续SystemServer的后续流程，会调用<code>wm.onInitReady();</code><br>在该方法中</p>
<ol>
<li>initPolicy：<br> 在UiThread（android.ui）中调用handler的runWithScissors 去执行WindowManagerPolicy的init方法，<br> WindowManagerPolicy在SystemServer初始化WMS时传入，是一个PhoneWindowManager</li>
<li>wms加入watchdog</li>
<li>createWatermark, 创建水印？源码看着是去读的&#x2F;system&#x2F;etc&#x2F;setup.conf</li>
</ol>
<p>继续回到SystemServer，还会依次调用<br><code>wm.displayReady();</code> 更新显示配置<br><code>wm.systemReady();</code> 在UI线程调用了SettingsObserver的loadSettings，更新systemui的设置等</p>
<h2 id="WMS的整体架构"><a href="#WMS的整体架构" class="headerlink" title="WMS的整体架构"></a>WMS的整体架构</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  classDiagram
ConfigurationContainer &lt;|-- WindowProcessController
ConfigurationContainer &lt;|-- WindowContainer
WindowContainer &lt;|-- WindowState
WindowContainer &lt;|-- DisplayArea
WindowContainer &lt;|-- DisplayContent
WindowContainer &lt;|-- RootWindowContainer
WindowContainer &lt;|-- WindowToken
WindowContainer &lt;|-- Task
Task &lt;|-- ActivityStack
WindowToken &lt;|-- ActivityRecord

  </pre></div>

<h2 id="WMS中的一些重要成员"><a href="#WMS中的一些重要成员" class="headerlink" title="WMS中的一些重要成员"></a>WMS中的一些重要成员</h2><p>WMS源码8000多行，成员变量比较多，暂时先列出一些，边看边记录，后续慢慢补充。</p>
<h3 id="WindowManagerPolicy-mPolicy"><a href="#WindowManagerPolicy-mPolicy" class="headerlink" title="WindowManagerPolicy[mPolicy]"></a>WindowManagerPolicy[mPolicy]</h3><p>WindowManagerPolicy是窗口管理策略的接口类，用来定义一个窗口策略所要遵循的通用规范，并提供了WindowManager所有的特定的UI行为。它的具体实现类为PhoneWindowManager，这个实现类在WMS创建时被创建。WMP允许定制窗口层级和特殊窗口类型以及关键的调度和布局。</p>
<h3 id="AppOpsManager-mAppOps"><a href="#AppOpsManager-mAppOps" class="headerlink" title="AppOpsManager[mAppOps]"></a>AppOpsManager[mAppOps]</h3><p>源码中解释 App-ops 用于访问控制和跟踪，WMS中只在构造方法中调用了startWatchingMode，监听了system_dialog和toast，会在收到回调时更新window状态</p>
<h3 id="DisplayWindowSettings-mDisplayWindowSettings"><a href="#DisplayWindowSettings-mDisplayWindowSettings" class="headerlink" title="DisplayWindowSettings[mDisplayWindowSettings]"></a>DisplayWindowSettings[mDisplayWindowSettings]</h3><p>保存window的显示设置的实体类</p>
<h3 id="ArraySet-mSessions"><a href="#ArraySet-mSessions" class="headerlink" title="ArraySet[mSessions]"></a>ArraySet[mSessions]</h3><p>保存的当前活动的客户端的会话。session主要用于记录请求WMS接口的客户端信息，应用程序想要和WMS进行通信就需要经过Session，并且每个应用程序进程都会对应一个Session，WMS保存这些Session用来记录所有向WMS提出窗口管理服务的客户端。</p>
<h3 id="HashMap-mWindowMap"><a href="#HashMap-mWindowMap" class="headerlink" title="HashMap[mWindowMap]"></a>HashMap[mWindowMap]</h3><p>保存windowtoke映射的WindowState的map，这里涉及到WindowState，可以把一个WindowState认为是一个窗口，WindowState内部保存了窗口的各种信息</p>
<h3 id="HashMap-mInputToWindowMap"><a href="#HashMap-mInputToWindowMap" class="headerlink" title="HashMap[mInputToWindowMap]"></a>HashMap[mInputToWindowMap]</h3><p>维护输入事件和窗口的映射关系</p>
<h3 id="WindowManagerGlobalLock-mGlobalLock"><a href="#WindowManagerGlobalLock-mGlobalLock" class="headerlink" title="WindowManagerGlobalLock[mGlobalLock]"></a>WindowManagerGlobalLock[mGlobalLock]</h3><p>wms中的全局锁，wms中很多地方都用了这个锁来保证数据的同步，这个锁在ActivityTaskManagerService创建的.</p>
<h2 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h2><p>window的实现类，持有一个DecorView.</p>
<h2 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h2><p>RootWindowContainer</p>
<h2 id="WindowManager-LaLayoutParams"><a href="#WindowManager-LaLayoutParams" class="headerlink" title="WindowManager.LaLayoutParams"></a>WindowManager.LaLayoutParams</h2><p>定义了一系列的window type，主要关注一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final int FIRST_APPLICATION_WINDOW = 1;</span><br><span class="line">public static final int LAST_APPLICATION_WINDOW = 99;</span><br><span class="line"></span><br><span class="line">public static final int FIRST_SUB_WINDOW = 1000;</span><br><span class="line">public static final int LAST_SUB_WINDOW = 1999;</span><br><span class="line"></span><br><span class="line">public static final int FIRST_SYSTEM_WINDOW     = 2000;</span><br><span class="line">public static final int LAST_SYSTEM_WINDOW      = 2999;</span><br></pre></td></tr></table></figure>

<p>也就是说 普通应用窗口的 type值 范围 1～99；子窗口 1000～1999；系统窗口 2000～2999</p>
<p>另外还定义一系列的window flag,以<code>FLAG_</code>开始，具体用到再去看</p>
<p>还定义了一系列软键盘相关的模式，以<code>SOFT_INPUT_</code>字段开始</p>
<h2 id="一些FLAG的记录"><a href="#一些FLAG的记录" class="headerlink" title="一些FLAG的记录"></a>一些FLAG的记录</h2><h3 id="View-SYSTEM-UI-FLAG-LAYOUT-STABLE"><a href="#View-SYSTEM-UI-FLAG-LAYOUT-STABLE" class="headerlink" title="View.SYSTEM_UI_FLAG_LAYOUT_STABLE"></a>View.SYSTEM_UI_FLAG_LAYOUT_STABLE</h3><p>稳定布局，当StatusBar和NavigationBar的显示和隐藏，系统为View设置的padding都不会变化,意味着会默认加入最大的insets</p>
<h3 id="View-SYSTEM-UI-FLAG-LAYOUT-HIDE-NAVIGATION"><a href="#View-SYSTEM-UI-FLAG-LAYOUT-HIDE-NAVIGATION" class="headerlink" title="View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION"></a>View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</h3><p>布局底部可以到达导航栏底部，但布局被导航栏遮挡<br>在不隐藏导航栏的情况下，将Activity的显示范围扩展到导航栏底部。同时Activity的部分内容也因此被NavigationBar覆盖遮挡</p>
<h3 id="View-SYSTEM-UI-FLAG-LAYOUT-FULLSCREEN"><a href="#View-SYSTEM-UI-FLAG-LAYOUT-FULLSCREEN" class="headerlink" title="View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN"></a>View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</h3><p>布局顶部可以到达状态栏顶部，但布局被状态栏遮挡<br>在不隐藏StatusBar的情况下，将view所在window的显示范围扩展到StatusBar下面。同时Activity的部分内容也因此被StatusBar覆盖遮挡。</p>
<h3 id="View-SYSTEM-UI-FLAG-HIDE-NAVIGATION"><a href="#View-SYSTEM-UI-FLAG-HIDE-NAVIGATION" class="headerlink" title="View.SYSTEM_UI_FLAG_HIDE_NAVIGATION"></a>View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</h3><p>隐藏系统NavigationBar，但是用户的任何交互，都会导致此Flag被系统清除，进而导航栏自动重新显示</p>
<h3 id="View-SYSTEM-UI-FLAG-FULLSCREEN"><a href="#View-SYSTEM-UI-FLAG-FULLSCREEN" class="headerlink" title="View.SYSTEM_UI_FLAG_FULLSCREEN"></a>View.SYSTEM_UI_FLAG_FULLSCREEN</h3><p>作用是隐藏StatusBar，但是用户的下拉状态栏操作，会导致此Flag被系统清除，进而状态栏自动重新显示</p>
<h3 id="View-SYSTEM-UI-FLAG-IMMERSIVE-STICKY"><a href="#View-SYSTEM-UI-FLAG-IMMERSIVE-STICKY" class="headerlink" title="View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY"></a>View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY</h3><p>避免某些用户交互造成系统自动清除全屏状态，配合 SYSTEM_UI_FLAG_FULLSCREEN  SYSTEM_UI_FLAG_HIDE_NAVIGATION 使用<br>默认情况下：<br>如果用户从屏幕顶部滑动，系统将强制清除<code>SYSTEM_UI_FLAG_FULLSCREEN</code><br>任何用户交互都会清除<code>SYSTEM_UI_FLAG_HIDE_NAVIGATION</code><br>所以这个flag配合状态栏|导航栏隐藏的flag使用后，下拉菜单会暂时显示状态栏|导航栏，超时后自动隐藏</p>
<h2 id="影响布局，不影响系统窗口"><a href="#影响布局，不影响系统窗口" class="headerlink" title="影响布局，不影响系统窗口"></a>影响布局，不影响系统窗口</h2><p>这2个flag都是布局范围调整，但对系统状态栏没影响的flag：</p>
<ol>
<li>SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN             布局以状态栏顶部为顶部<br> 配合fitSystemWindow&#x3D;true的view，会被系统自动添加大小为statusBar和ActionBar高度之和相同的paddingTop</li>
<li>SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION        布局以导航栏底部为底部<br> 配合fitSystemWindow&#x3D;true的view，会被系统自动添加大小为NavigationBar高度相同的paddingBottom</li>
</ol>
<h2 id="影响布局和系统窗口"><a href="#影响布局和系统窗口" class="headerlink" title="影响布局和系统窗口"></a>影响布局和系统窗口</h2><p>这两个flag影响布局，同时会隐藏对应的系统窗口，但用户交互会清除这2个flag：</p>
<ol>
<li>SYSTEM_UI_FLAG_FULLSCREEN            布局以状态栏顶部为顶部，隐藏状态栏</li>
<li>SYSTEM_UI_FLAG_HIDE_NAVIGATION       布局以导航栏底部为底部，隐藏导航栏</li>
</ol>
<p>配合 SYSTEM_UI_FLAG_IMMERSIVE_STICKY 使用，避免flag被清除</p>
<p>FITS_SYSTEM_WINDOWS + SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 会加padding</p>
<p>SYSTEM_UI_FLAG_LAYOUT_STABLE + SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 左侧无法</p>
<h2 id="WindowManager-addView"><a href="#WindowManager-addView" class="headerlink" title="WindowManager#addView"></a>WindowManager#addView</h2><p>在Activity第一次resume的时候，会调用WindowManager的addView。</p>
<p>WindowManagerImpl.addView<br>WindowManagerGlobal.addView</p>
<p>在WindowManagerGlobal的addView方法内部创建ViewRootImpl了，ViewRootImpl的构造方法中会去初始化WindowSession，<br>这个WindowSession是个静态全局变量，意味着每个进程只有一个WindowSession，这个WindowSession实际是调用wms的openSession得到的。</p>
<p>然后调用ViewRootImpl的setView，去requestLayout，并调用mWindowSession.addToDisplayAsUser.<br>而addToDisplayAsUser实际调用的就是WMS的addWindow</p>
<p>ActivityThread.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,</span><br><span class="line">            String reason) &#123;</span><br><span class="line">        //...</span><br><span class="line">        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            //......</span><br><span class="line">            if (a.mVisibleFromClient) &#123;</span><br><span class="line">                if (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = true;</span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // The activity will get a callback for this &#123;@link LayoutParams&#125; change</span><br><span class="line">                    // earlier. However, at that time the decor will not be set (this is set</span><br><span class="line">                    // in this method), so no action will be taken. This call ensures the</span><br><span class="line">                    // callback occurs with the decor set.</span><br><span class="line">                    a.onWindowAttributesChanged(l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If the window has already been added, but during resume</span><br><span class="line">            // we started another activity, then don&#x27;t yet make the</span><br><span class="line">            // window visible.</span><br><span class="line">        &#125; else if (!willBeVisible) &#123;</span><br><span class="line">            if (localLOGV || enableLifeCycleLog()) Slog.v(TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);</span><br><span class="line">            r.hideForNow = true;</span><br><span class="line">        &#125;</span><br><span class="line">        //......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>WindowManagerImpl.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,</span><br><span class="line">            mContext.getUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WindowManagerGlobal.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">        Display display, Window parentWindow, int userId) &#123;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = null;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        //......</span><br><span class="line">        root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line">        //......</span><br><span class="line">        // do this last because it fires off messages to start doing things</span><br><span class="line">        try &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView, userId);</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            //......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">public static IWindowSession getWindowSession() &#123;</span><br><span class="line">    synchronized (WindowManagerGlobal.class) &#123;</span><br><span class="line">        if (sWindowSession == null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // Emulate the legacy behavior.  The global instance of InputMethodManager</span><br><span class="line">                // was instantiated here.</span><br><span class="line">                // TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage</span><br><span class="line">                InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary();</span><br><span class="line">                IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        new IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void onAnimatorScaleChanged(float scale) &#123;</span><br><span class="line">                                ValueAnimator.setDurationScale(scale);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">public static IWindowManager getWindowManagerService() &#123;</span><br><span class="line">    synchronized (WindowManagerGlobal.class) &#123;</span><br><span class="line">        if (sWindowManagerService == null) &#123;</span><br><span class="line">            sWindowManagerService = IWindowManager.Stub.asInterface(</span><br><span class="line">                    ServiceManager.getService(&quot;window&quot;));</span><br><span class="line">            try &#123;</span><br><span class="line">                if (sWindowManagerService != null) &#123;</span><br><span class="line">                    ValueAnimator.setDurationScale(</span><br><span class="line">                            sWindowManagerService.getCurrentAnimatorScale());</span><br><span class="line">                    sUseBLASTAdapter = sWindowManagerService.useBLAST();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sWindowManagerService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewRootImpl.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ViewRootImpl(Context context, Display display) &#123;</span><br><span class="line">    //在构造方法中初始化了mWindowSession</span><br><span class="line">    this(context, display, WindowManagerGlobal.getWindowSession(),</span><br><span class="line">            false /* useSfChoreographer */);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,</span><br><span class="line">        int userId) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mView == null) &#123;</span><br><span class="line">            //......</span><br><span class="line">            mAdded = true;</span><br><span class="line">            int res; /* = WindowManagerImpl.ADD_OKAY; */</span><br><span class="line"></span><br><span class="line">            // Schedule the first layout -before- adding to the window</span><br><span class="line">            // manager, to make sure we do the relayout before receiving</span><br><span class="line">            // any other events from the system.</span><br><span class="line">            requestLayout();</span><br><span class="line">            //......</span><br><span class="line">            </span><br><span class="line">            try &#123;</span><br><span class="line">                mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">                mAttachInfo.mRecomputeGlobalAttributes = true;</span><br><span class="line">                collectViewAttributes();</span><br><span class="line">                adjustLayoutParamsForCompatibility(mWindowAttributes);</span><br><span class="line">                //在这里调用windowSession的addToDisplayAsUser</span><br><span class="line">                res = mWindowSession.addToDisplayAsUser(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(), userId, mTmpFrame,</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mDisplayCutout, inputChannel,</span><br><span class="line">                        mTempInsets, mTempControls);</span><br><span class="line">                setFrame(mTmpFrame);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                mAdded = false;</span><br><span class="line">                mView = null;</span><br><span class="line">                mAttachInfo.mRootView = null;</span><br><span class="line">                inputChannel = null;</span><br><span class="line">                mFallbackEventHandler.setView(null);</span><br><span class="line">                unscheduleTraversals();</span><br><span class="line">                setAccessibilityFocus(null, null);</span><br><span class="line">                throw new RuntimeException(&quot;Adding window failed&quot;, e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (restore) &#123;</span><br><span class="line">                    attrs.restore();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Session.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int addToDisplayAsUser(IWindow window, int seq, WindowManager.LayoutParams attrs,</span><br><span class="line">        int viewVisibility, int displayId, int userId, Rect outFrame,</span><br><span class="line">        Rect outContentInsets, Rect outStableInsets,</span><br><span class="line">        DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,</span><br><span class="line">        InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) &#123;</span><br><span class="line">    //windowSession的addToDisplayAsUser实际调用的WMS的addWindow</span><br><span class="line">    return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outFrame,</span><br><span class="line">            outContentInsets, outStableInsets, outDisplayCutout, outInputChannel,</span><br><span class="line">            outInsetsState, outActiveControls, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="WindowManagerService-addWindow"><a href="#WindowManagerService-addWindow" class="headerlink" title="WindowManagerService#addWindow"></a>WindowManagerService#addWindow</h2><p>先列出几个看起来关键的点，后续再细看<br>WindowManagerService.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int addWindow(Session session, IWindow client, int seq,</span><br><span class="line">        LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame,</span><br><span class="line">        Rect outContentInsets, Rect outStableInsets,</span><br><span class="line">        DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,</span><br><span class="line">        InsetsState outInsetsState, InsetsSourceControl[] outActiveControls,</span><br><span class="line">        int requestUserId) &#123;</span><br><span class="line">    // 权限检查</span><br><span class="line">    int res = mPolicy.checkAddPermission(attrs.type, isRoundedCornerOverlay, attrs.packageName,</span><br><span class="line">            appOp);</span><br><span class="line">    if (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WindowState parentWindow = null;</span><br><span class="line">    final int callingUid = Binder.getCallingUid();</span><br><span class="line">    final int callingPid = Binder.getCallingPid();</span><br><span class="line">    final long origId = Binder.clearCallingIdentity();</span><br><span class="line">    // 拿到窗口层级</span><br><span class="line">    final int type = attrs.type;</span><br><span class="line"></span><br><span class="line">    synchronized (mGlobalLock) &#123;</span><br><span class="line">        // ....一些简单校验</span><br><span class="line"></span><br><span class="line">        // 判断是否重复添加</span><br><span class="line">        if (mWindowMap.containsKey(client.asBinder())) &#123;</span><br><span class="line">            ProtoLog.w(WM_ERROR, &quot;Window %s is already added&quot;, client);</span><br><span class="line">            return WindowManagerGlobal.ADD_DUPLICATE_ADD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 根据窗口层级进行一些逻辑校验</span><br><span class="line">        if (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        // 多用户校验</span><br><span class="line">        int userId = UserHandle.getUserId(session.mUid);</span><br><span class="line">        if (requestUserId != userId) &#123;</span><br><span class="line">            //......</span><br><span class="line">            // It&#x27;s fine to use this userId</span><br><span class="line">            userId = requestUserId;</span><br><span class="line">        &#125;</span><br><span class="line">        //......</span><br><span class="line">        ActivityRecord activity = null;</span><br><span class="line">        final boolean hasParent = parentWindow != null;            </span><br><span class="line">        //尝试去缓存的windowToken</span><br><span class="line">        WindowToken token = displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        </span><br><span class="line">        if (token == null) &#123;</span><br><span class="line">            if (!unprivilegedAppCanCreateTokenWith(parentWindow, callingUid, type,</span><br><span class="line">                    rootType, attrs.token, attrs.packageName)) &#123;</span><br><span class="line">                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果有父窗口，windowToken和父窗口一样</span><br><span class="line">            if (hasParent) &#123;</span><br><span class="line">                // Use existing parent window token for child windows.</span><br><span class="line">                token = parentWindow.mToken;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                final IBinder binder = attrs.token != null ? attrs.token : client.asBinder();</span><br><span class="line">                // 创建一个新的token</span><br><span class="line">                token = new WindowToken(this, binder, type, false, displayContent,</span><br><span class="line">                        session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        // ...... 对window的type的判断</span><br><span class="line"></span><br><span class="line">        else if (token.asActivityRecord() != null) &#123;</span><br><span class="line">            ProtoLog.w(WM_ERROR, &quot;Non-null activity for system window of rootType=%d&quot;,</span><br><span class="line">                    rootType);</span><br><span class="line">            // It is not valid to use an app token with other system types; we will</span><br><span class="line">            // instead make a new token for it (as if null had been passed in for the token).</span><br><span class="line">            attrs.token = null;</span><br><span class="line">            token = new WindowToken(this, client.asBinder(), type, false, displayContent,</span><br><span class="line">                    session.mCanAddInternalSystemWindow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 创建WindowState来记录window信息</span><br><span class="line">        final WindowState win = new WindowState(this, session, client, token, parentWindow,</span><br><span class="line">                appOp[0], seq, attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        if (win.mDeathRecipient == null) &#123;</span><br><span class="line">            // Client has apparently died, so there is no reason to</span><br><span class="line">            // continue.</span><br><span class="line">            ProtoLog.w(WM_ERROR, &quot;Adding window client %s&quot;</span><br><span class="line">                    + &quot; that is dead, aborting.&quot;, client.asBinder());</span><br><span class="line">            return WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (win.getDisplayContent() == null) &#123;</span><br><span class="line">            ProtoLog.w(WM_ERROR, &quot;Adding window to Display that has been removed.&quot;);</span><br><span class="line">            return WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final DisplayPolicy displayPolicy = displayContent.getDisplayPolicy();</span><br><span class="line">        // 这里是调整Window的属性，会去根据window的type和attr进行赋值调整</span><br><span class="line">        displayPolicy.adjustWindowParamsLw(win, win.mAttrs, callingPid, callingUid);</span><br><span class="line"></span><br><span class="line">        //判断是否允许添加window</span><br><span class="line">        res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);</span><br><span class="line">        if (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line">        // From now on, no exceptions or errors allowed!</span><br><span class="line"></span><br><span class="line">        res = WindowManagerGlobal.ADD_OKAY;</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        //保存windowState到map中</span><br><span class="line">        win.attach();</span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        win.initAppOpsState();</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        final ActivityRecord tokenActivity = token.asActivityRecord();</span><br><span class="line">        //根据window的type来记录启动窗口</span><br><span class="line">        if (type == TYPE_APPLICATION_STARTING &amp;&amp; tokenActivity != null) &#123;</span><br><span class="line">            tokenActivity.startingWindow = win;</span><br><span class="line">            ProtoLog.v(WM_DEBUG_STARTING_WINDOW, &quot;addWindow: %s startingWindow=%s&quot;,</span><br><span class="line">                    activity, win);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean imMayMove = true;</span><br><span class="line"></span><br><span class="line">        //windowToken将windowState记录下来，方法内部有逻辑如果windowState是子窗口不会被添加</span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        //交给displayPolicy去处理addWindow，主要是根据window type设置InsetProvider</span><br><span class="line">        displayPolicy.addWindowLw(win, attrs);</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        //开始处理窗口动画的状态，WindowState的WindowStateAnimator是在WindowState的构造方法中初始化的</span><br><span class="line">        final WindowStateAnimator winAnimator = win.mWinAnimator;</span><br><span class="line">        //设置window动画相关的flag</span><br><span class="line">        winAnimator.mEnterAnimationPending = true;</span><br><span class="line">        winAnimator.mEnteringAnimation = true;</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        // Don&#x27;t do layout here, the window must call</span><br><span class="line">        // relayout to be displayed, so we&#x27;ll do it there.</span><br><span class="line">        // 这里windowState的parent其实就是WindowToken，</span><br><span class="line">        win.getParent().assignChildLayers();</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        if (win.isVisibleOrAdding() &amp;&amp; displayContent.updateOrientation()) &#123;</span><br><span class="line">            displayContent.sendNewConfiguration();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getInsetsSourceControls(win, outActiveControls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;                  </span><br></pre></td></tr></table></figure>

<h2 id="WindowState"><a href="#WindowState" class="headerlink" title="WindowState"></a>WindowState</h2><p>在WindowState的构造方法中，除了一些变量赋值，也根据WindowManager.LayoutParams.type做了一些逻辑判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">    // The multiplier here is to reserve space for multiple</span><br><span class="line">    // windows in the same type layer.</span><br><span class="line">    //这里是拿到父窗口的层级值做了个运算，注释说这里的乘数是为了给多个同级窗口预留占为值</span><br><span class="line">    mBaseLayer = mPolicy.getWindowLayerLw(parentWindow)</span><br><span class="line">            * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br><span class="line">    //通过type计算子层级值</span><br><span class="line">    mSubLayer = mPolicy.getSubWindowLayerFromTypeLw(a.type);</span><br><span class="line">    mIsChildWindow = true;</span><br><span class="line"></span><br><span class="line">    mLayoutAttached = mAttrs.type !=</span><br><span class="line">            WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG;</span><br><span class="line">    mIsImWindow = parentWindow.mAttrs.type == TYPE_INPUT_METHOD</span><br><span class="line">            || parentWindow.mAttrs.type == TYPE_INPUT_METHOD_DIALOG;</span><br><span class="line">    mIsWallpaper = parentWindow.mAttrs.type == TYPE_WALLPAPER;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // The multiplier here is to reserve space for multiple</span><br><span class="line">    // windows in the same type layer.</span><br><span class="line">    mBaseLayer = mPolicy.getWindowLayerLw(this)</span><br><span class="line">            * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br><span class="line">    mSubLayer = 0;</span><br><span class="line">    mIsChildWindow = false;</span><br><span class="line">    mLayoutAttached = false;</span><br><span class="line">    mIsImWindow = mAttrs.type == TYPE_INPUT_METHOD</span><br><span class="line">            || mAttrs.type == TYPE_INPUT_METHOD_DIALOG;</span><br><span class="line">    mIsWallpaper = mAttrs.type == TYPE_WALLPAPER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DisplayFrames"><a href="#DisplayFrames" class="headerlink" title="DisplayFrames"></a>DisplayFrames</h2><p>DisplayFrames这个类用来保存了各种显示区域</p>
<ul>
<li>mUnrestricted：当前屏幕的可见大小，不考虑状态栏是否可隐藏，但不包括超出显示区域的部分（就是屏幕的非显示，如屏幕边框之类的不会包含）</li>
<li>mRestricted：当前屏幕的大小，如果状态栏不可隐藏，这个大小会减去状态栏的区域。</li>
<li>mSystem：布局过程中考虑当前可见系统 UI 元素的屏幕边界。</li>
<li>mStable：为应用程序请求稳定内容插图（insets）时的边界信息</li>
<li>mStableFullscreen：对于同时设置了全屏窗口标志和稳定内容插图的应用程序，这是没有状态栏的稳定尺寸。</li>
<li>mCurrent：布局过程中考虑所有外部装饰（状态栏、输入法停靠区等）的屏幕边界。</li>
<li>mContent：在布局过程中，用于显示用户内容的框架，考虑到所有屏幕装饰，通常和mCurrent一样，但如果屏幕装饰提供了内容插图，可能会更大。</li>
<li>mVoiceContent：在布局过程中，用于显示语音内容的框架，考虑到所有屏幕装饰。</li>
<li>mDock：布局过程中用于放置输入法窗口的屏幕边界。</li>
</ul>
<p>在performLayoutNoTrace中会先调用mDisplayPolicy.beginLayoutLw()&#x3D;&gt;DisplayFrames.onBeginLayout()<br>在onBeginLayout中将mUnrestricted 设置为 (0, 0, mDisplayWidth, mDisplayHeight),<br>并将mUnrestricted的rect值赋值给其他所有的显示区域，默认都是屏幕所有区域</p>
<h2 id="WindowFrames"><a href="#WindowFrames" class="headerlink" title="WindowFrames"></a>WindowFrames</h2><p>看起来和DisplayFrames很像，也是保存了各种显示区域，但这个是针对当前window用的，保存的是当前要布局的window的各种情况下的显示区域。<br>而DisplayFrames保存的是当前屏幕的各种显示区域，而WindowFrames保存的是当前window的显示区域，<br>一个屏幕上可能有多个window，同时显示时，每个WindowFrames数据不一样</p>
<ul>
<li>mParentFrame：</li>
</ul>
<h2 id="Displaypolicy-layoutWindowLw"><a href="#Displaypolicy-layoutWindowLw" class="headerlink" title="Displaypolicy#layoutWindowLw"></a>Displaypolicy#layoutWindowLw</h2><h2 id="强制显示下拉状态栏"><a href="#强制显示下拉状态栏" class="headerlink" title="强制显示下拉状态栏"></a>强制显示下拉状态栏</h2><p>在InsetsPolicy中的updateBarControlTarget中，会去更新statusbar和navbar的可见性<br>InsetsPolicy.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void updateBarControlTarget(@Nullable WindowState focusedWin) &#123;</span><br><span class="line">    if (focusedWin != null &amp;&amp; (focusedWin.mAttrs.type == TYPE_APPLICATION_STARTING)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mFocusedWin != focusedWin)&#123;</span><br><span class="line">        abortTransient();</span><br><span class="line">    &#125;</span><br><span class="line">    mFocusedWin = focusedWin;</span><br><span class="line">    boolean forceShowsSystemBarsForWindowingMode = forceShowsSystemBarsForWindowingMode();</span><br><span class="line">    InsetsControlTarget statusControlTarget = getStatusControlTarget(focusedWin,</span><br><span class="line">            forceShowsSystemBarsForWindowingMode);</span><br><span class="line">    InsetsControlTarget navControlTarget = getNavControlTarget(focusedWin,</span><br><span class="line">            forceShowsSystemBarsForWindowingMode);</span><br><span class="line">    mStateController.onBarControlTargetChanged(statusControlTarget,</span><br><span class="line">            getFakeControlTarget(focusedWin, statusControlTarget),</span><br><span class="line">            navControlTarget,</span><br><span class="line">            getFakeControlTarget(focusedWin, navControlTarget));</span><br><span class="line">    if (ViewRootImpl.sNewInsetsMode != ViewRootImpl.NEW_INSETS_MODE_FULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //这里如果controlTarget是null，会让其可见</span><br><span class="line">    mStatusBar.updateVisibility(statusControlTarget, ITYPE_STATUS_BAR);</span><br><span class="line">    mNavBar.updateVisibility(navControlTarget, ITYPE_NAVIGATION_BAR);</span><br><span class="line">    mPolicy.updateHideNavInputEventReceiver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class BarWindow &#123;</span><br><span class="line"></span><br><span class="line">    private final int mId;</span><br><span class="line">    private  @StatusBarManager.WindowVisibleState int mState =</span><br><span class="line">            StatusBarManager.WINDOW_STATE_SHOWING;</span><br><span class="line"></span><br><span class="line">    BarWindow(int id) &#123;</span><br><span class="line">        mId = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void updateVisibility(InsetsControlTarget controlTarget,</span><br><span class="line">            @InternalInsetsType int type) &#123;</span><br><span class="line">        final WindowState controllingWin =</span><br><span class="line">                controlTarget instanceof WindowState ? (WindowState) controlTarget : null;</span><br><span class="line">        setVisible(controllingWin == null</span><br><span class="line">                || controllingWin.getRequestedInsetsState().getSourceOrDefaultVisibility(type));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setVisible(boolean visible) &#123;</span><br><span class="line">        final int state = visible ? WINDOW_STATE_SHOWING : WINDOW_STATE_HIDDEN;</span><br><span class="line">        if (mState != state) &#123;</span><br><span class="line">            mState = state;</span><br><span class="line">            mPolicy.getStatusBarManagerInternal().setWindowState(</span><br><span class="line">                    mDisplayContent.getDisplayId(), mId, state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h2 id="窗口层级"><a href="#窗口层级" class="headerlink" title="窗口层级"></a>窗口层级</h2><p>在DisplayContent中,在类加载的时候，默认初始化了4个WindowContainer：</p>
<ul>
<li>mWindowContainers</li>
<li>mOverlayContainers</li>
<li>ImeContainer</li>
<li>DisplayArea.Root<br>相关初始化和DisplayContent的构造方法如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Most surfaces will be a child of this window. There are some special layers and windows</span><br><span class="line"> * which are always on top of others and omitted from Screen-Magnification, for example the</span><br><span class="line"> * strict mode flash or the magnification overlay itself. Those layers will be children of</span><br><span class="line"> * &#123;@link #mOverlayContainers&#125; where mWindowContainers contains everything else.</span><br><span class="line"> */</span><br><span class="line">private final WindowContainers mWindowContainers =</span><br><span class="line">        new WindowContainers(&quot;mWindowContainers&quot;, mWmService);</span><br><span class="line"></span><br><span class="line">// Contains some special windows which are always on top of others and omitted from</span><br><span class="line">// Screen-Magnification, for example the WindowMagnification windows.</span><br><span class="line">private final NonAppWindowContainers mOverlayContainers =</span><br><span class="line">        new NonAppWindowContainers(&quot;mOverlayContainers&quot;, mWmService);</span><br><span class="line"></span><br><span class="line">/** The containers below are the only child containers &#123;@link #mWindowContainers&#125; can have. */</span><br><span class="line"></span><br><span class="line">// Contains all IME window containers. Note that the z-ordering of the IME windows will depend</span><br><span class="line">// on the IME target. We mainly have this container grouping so we can keep track of all the IME</span><br><span class="line">// window containers together and move them in-sync if/when needed. We use a subclass of</span><br><span class="line">// WindowContainer which is omitted from screen magnification, as the IME is never magnified.</span><br><span class="line">// TODO(display-area): is &quot;no magnification&quot; in the comment still true?</span><br><span class="line">private final ImeContainer mImeWindowsContainers = new ImeContainer(mWmService);</span><br><span class="line"></span><br><span class="line">private final DisplayArea.Root mRootDisplayArea = new DisplayArea.Root(mWmService);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DisplayContent(Display display, RootWindowContainer root) &#123;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    //这里是去初始化各个容器layer的开始</span><br><span class="line">    // These are the only direct children we should ever have and they are permanent.</span><br><span class="line">    super.addChild(mWindowContainers, null);</span><br><span class="line">    super.addChild(mOverlayContainers, null);</span><br><span class="line"></span><br><span class="line">    mDisplayAreaPolicy = mWmService.mDisplayAreaPolicyProvider.instantiate(</span><br><span class="line">            mWmService, this, mRootDisplayArea, mImeWindowsContainers);</span><br><span class="line">    mWindowContainers.addChildren();</span><br><span class="line"></span><br><span class="line">    // Sets the display content for the children.</span><br><span class="line">    onDisplayChanged(this);</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>看DisplayContent的父类WindowContainer中的addChild方法，就是将mWindowContainers和mOverlayContainers<br>按顺序加入一个ArrayList中，还需要看在哪里赋值的mLastLayer(即zOrder)<br>在WindowContainer调用addChild的最后一步会调用一次child.setParent(this),这里的this是DisplayContent，<br>child是mWindowContainers和mOverlayContainers，后续会回调child的onParentChanged，然后调用mParent.assignChildLayers()，<br>也就是DisplayContent的assignChildLayers</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Adds the input window container has a child of this container in order based on the input</span><br><span class="line"> * comparator.</span><br><span class="line"> * @param child The window container to add as a child of this window container.</span><br><span class="line"> * @param comparator Comparator to use in determining the position the child should be added to.</span><br><span class="line"> *                   If null, the child will be added to the top.</span><br><span class="line"> */</span><br><span class="line">@CallSuper</span><br><span class="line">protected void addChild(E child, Comparator&lt;E&gt; comparator) &#123;</span><br><span class="line">    if (!child.mReparenting &amp;&amp; child.getParent() != null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;addChild: container=&quot; + child.getName()</span><br><span class="line">                + &quot; is already a child of container=&quot; + child.getParent().getName()</span><br><span class="line">                + &quot; can&#x27;t add to container=&quot; + getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int positionToAdd = -1;</span><br><span class="line">    if (comparator != null) &#123;</span><br><span class="line">        final int count = mChildren.size();</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            if (comparator.compare(child, mChildren.get(i)) &lt; 0) &#123;</span><br><span class="line">                positionToAdd = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (positionToAdd == -1) &#123;</span><br><span class="line">        mChildren.add(child);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mChildren.add(positionToAdd, child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Set the parent after we&#x27;ve actually added a child in case a subclass depends on this.</span><br><span class="line">    child.setParent(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final protected void setParent(WindowContainer&lt;WindowContainer&gt; parent) &#123;</span><br><span class="line">    final WindowContainer oldParent = mParent;</span><br><span class="line">    mParent = parent;</span><br><span class="line"></span><br><span class="line">    if (mParent != null) &#123;</span><br><span class="line">        mParent.onChildAdded(this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!mReparenting) &#123;</span><br><span class="line">        if (mParent != null &amp;&amp; mParent.mDisplayContent != null</span><br><span class="line">                &amp;&amp; mDisplayContent != mParent.mDisplayContent) &#123;</span><br><span class="line">            onDisplayChanged(mParent.mDisplayContent);</span><br><span class="line">        &#125;</span><br><span class="line">        onParentChanged(mParent, oldParent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent) &#123;</span><br><span class="line">    onParentChanged(newParent, oldParent, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent,</span><br><span class="line">        PreAssignChildLayersCallback callback) &#123;</span><br><span class="line">    super.onParentChanged(newParent, oldParent);</span><br><span class="line">    if (mParent == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mSurfaceControl == null) &#123;</span><br><span class="line">        // If we don&#x27;t yet have a surface, but we now have a parent, we should</span><br><span class="line">        // build a surface.</span><br><span class="line">        createSurfaceControl(false /*force*/);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // If we have a surface but a new parent, we just need to perform a reparent. Go through</span><br><span class="line">        // surface animator such that hierarchy is preserved when animating, i.e.</span><br><span class="line">        // mSurfaceControl stays attached to the leash and we just reparent the leash to the</span><br><span class="line">        // new parent.</span><br><span class="line">        reparentSurfaceControl(getSyncTransaction(), mParent.mSurfaceControl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (callback != null) &#123;</span><br><span class="line">        callback.onPreAssignChildLayers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Either way we need to ask the parent to assign us a Z-order.</span><br><span class="line">    mParent.assignChildLayers();</span><br><span class="line">    scheduleAnimation();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><strong>可以看到DisplayContent的assignChildLayers中，将mOverlayContainers的layer设置为1，<br>mWindowContainers的layer设置为0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">void assignChildLayers(SurfaceControl.Transaction t) &#123;</span><br><span class="line">    mWindowContainers.assignLayer(t, 0);</span><br><span class="line">    mOverlayContainers.assignLayer(t, 1);</span><br><span class="line"></span><br><span class="line">    mWindowContainers.assignChildLayers(t);</span><br><span class="line">    mOverlayContainers.assignChildLayers(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看DisplayContent中的mDisplayAreaPolicy初始化，<br>DisplayAreaPolicy中，通过DisplayAreaPolicyBuilder来构造了一个DisplayAreaPolicy,<br>在builder中创建了一个DisplayAreaPolicy的子类Result实例，<br>在子类构造方法中调用了父类DisplayAreaPolicy的构造方法，将DisplayContent对象中的<br>mRootDisplayArea和mImeWindowsContainers传了进去。</p>
<p>DisplayAreaPolicy:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Provider for platform-default display area policy. */</span><br><span class="line">static final class DefaultProvider implements DisplayAreaPolicy.Provider &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public DisplayAreaPolicy instantiate(WindowManagerService wmService,</span><br><span class="line">            DisplayContent content, DisplayArea.Root root,</span><br><span class="line">            DisplayArea&lt;? extends WindowContainer&gt; imeContainer) &#123;</span><br><span class="line">        final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,</span><br><span class="line">                &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);</span><br><span class="line">        final List&lt;TaskDisplayArea&gt; tdaList = new ArrayList&lt;&gt;();</span><br><span class="line">        tdaList.add(defaultTaskDisplayArea);</span><br><span class="line">        return new DisplayAreaPolicyBuilder()</span><br><span class="line">                .build(wmService, content, root, imeContainer, tdaList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Construct a new &#123;@link DisplayAreaPolicy&#125;</span><br><span class="line"> *</span><br><span class="line"> * @param wmService the window manager service instance</span><br><span class="line"> * @param content the display content for which the policy applies</span><br><span class="line"> * @param root the root display area under which the policy operates</span><br><span class="line"> * @param imeContainer the ime container that the policy must attach</span><br><span class="line"> * @param taskDisplayAreas the task display areas that the policy must attach</span><br><span class="line"> *</span><br><span class="line"> * @see #attachDisplayAreas()</span><br><span class="line"> */</span><br><span class="line">protected DisplayAreaPolicy(WindowManagerService wmService,</span><br><span class="line">        DisplayContent content, DisplayArea.Root root,</span><br><span class="line">        DisplayArea&lt;? extends WindowContainer&gt; imeContainer,</span><br><span class="line">        List&lt;TaskDisplayArea&gt; taskDisplayAreas) &#123;</span><br><span class="line">    mWmService = wmService;</span><br><span class="line">    mContent = content;</span><br><span class="line">    mRoot = root;</span><br><span class="line">    mImeContainer = imeContainer;</span><br><span class="line">    mTaskDisplayAreas = taskDisplayAreas;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>DisplayAreaPolicyBuilder:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Result build(WindowManagerService wmService,</span><br><span class="line">        DisplayContent content, DisplayArea.Root root,</span><br><span class="line">        DisplayArea&lt;? extends WindowContainer&gt; imeContainer,</span><br><span class="line">        List&lt;TaskDisplayArea&gt; taskDisplayAreas) &#123;</span><br><span class="line"></span><br><span class="line">    return new Result(wmService, content, root, imeContainer, taskDisplayAreas, new ArrayList&lt;&gt;(</span><br><span class="line">            mFeatures));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Result extends DisplayAreaPolicy &#123;</span><br><span class="line"></span><br><span class="line">    Result(WindowManagerService wmService, DisplayContent content, DisplayArea.Root root,</span><br><span class="line">            DisplayArea&lt;? extends WindowContainer&gt; imeContainer,</span><br><span class="line">            List&lt;TaskDisplayArea&gt; taskDisplayAreas, ArrayList&lt;Feature&gt; features) &#123;</span><br><span class="line">        //主要还是调用了父类DisplayAreaPolicy的构造方法                    </span><br><span class="line">        super(wmService, content, root, imeContainer, taskDisplayAreas);</span><br><span class="line">        //mFeatures一般是个空列表</span><br><span class="line">        mFeatures = features;</span><br><span class="line">        mAreas = new HashMap&lt;&gt;(features.size());</span><br><span class="line">        for (int i = 0; i &lt; mFeatures.size(); i++) &#123;</span><br><span class="line">            mAreas.put(mFeatures.get(i), new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>最后看DisplayContent中的<code>mWindowContainers.addChildren()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">static class DisplayChildWindowContainer&lt;E extends WindowContainer&gt; extends WindowContainer&lt;E&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class WindowContainers extends DisplayChildWindowContainer&lt;WindowContainer&gt; &#123;</span><br><span class="line">    void addChildren() &#123;</span><br><span class="line">        //调用父类WindowContainer的addChild，将mRootDisplayArea放在mWindowContainers中</span><br><span class="line">        addChild(mRootDisplayArea, 0);</span><br><span class="line">        //初始化容器</span><br><span class="line">        mDisplayAreaPolicy.attachDisplayAreas();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>到目前为止，DisplayContent中几个容器的层级关系如下:<br><em>mOverlayContainers和mWindowContainers在同一个Display中，mOverlayContainers高于mWindowContainers，<br>DisplayArea.Root在mWindowContainers中</em></p>
<ul>
<li>#1 mOverlayContainers</li>
<li>#0 mWindowContainers<ul>
<li>#0 DisplayArea.Root</li>
</ul>
</li>
</ul>
<p>继续看DisplayAreaPolicyBuilder中的attachDisplayAreas</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private final int mMaxWindowLayer = mWmService.mPolicy.getMaxWindowLayer();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void attachDisplayAreas() &#123;</span><br><span class="line">    // This method constructs the layer hierarchy with the following properties:</span><br><span class="line">    // (1) Every feature maps to a set of DisplayAreas</span><br><span class="line">    // (2) After adding a window, for every feature the window&#x27;s type belongs to,</span><br><span class="line">    //     it is a descendant of one of the corresponding DisplayAreas of the feature.</span><br><span class="line">    // (3) Z-order is maintained, i.e. if z-range(area) denotes the set of layers of windows</span><br><span class="line">    //     within a DisplayArea:</span><br><span class="line">    //      for every pair of DisplayArea siblings (a,b), where a is below b, it holds that</span><br><span class="line">    //      max(z-range(a)) &lt;= min(z-range(b))</span><br><span class="line">    //</span><br><span class="line">    // The algorithm below iteratively creates such a hierarchy:</span><br><span class="line">    //  - Initially, all windows are attached to the root.</span><br><span class="line">    //  - For each feature we create a set of DisplayAreas, by looping over the layers</span><br><span class="line">    //    - if the feature does apply to the current layer, we need to find a DisplayArea</span><br><span class="line">    //      for it to satisfy (2)</span><br><span class="line">    //      - we can re-use the previous layer&#x27;s area if:</span><br><span class="line">    //         the current feature also applies to the previous layer, (to satisfy (3))</span><br><span class="line">    //         and the last feature that applied to the previous layer is the same as</span><br><span class="line">    //           the last feature that applied to the current layer (to satisfy (2))</span><br><span class="line">    //      - otherwise we create a new DisplayArea below the last feature that applied</span><br><span class="line">    //        to the current layer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //这里创建了一个数组，容量是默认定义好的最大的layer，这里数组的下标对应windowtype所映射的layer</span><br><span class="line">    PendingArea[] areaForLayer = new PendingArea[mMaxWindowLayer];</span><br><span class="line">    final PendingArea root = new PendingArea(null, 0, null);</span><br><span class="line">    //将数组中的每个元素都赋值成 root 对象</span><br><span class="line">    Arrays.fill(areaForLayer, root);</span><br><span class="line"></span><br><span class="line">    final int size = mFeatures.size();</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        PendingArea featureArea = null;</span><br><span class="line">        for (int layer = 0; layer &lt; mMaxWindowLayer; layer++) &#123;</span><br><span class="line">            final Feature feature = mFeatures.get(i);</span><br><span class="line">            if (feature.mWindowLayers[layer]) &#123;</span><br><span class="line">                if (featureArea == null || featureArea.mParent != areaForLayer[layer]) &#123;</span><br><span class="line">                    // No suitable DisplayArea - create a new one under the previous area</span><br><span class="line">                    // for this layer.</span><br><span class="line">                    featureArea = new PendingArea(feature, layer, areaForLayer[layer]);</span><br><span class="line">                    areaForLayer[layer].mChildren.add(featureArea);</span><br><span class="line">                &#125;</span><br><span class="line">                areaForLayer[layer] = featureArea;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                featureArea = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里的逻辑主要是去将root容器分成多个子容器，每个容器在root中的layer不一样</span><br><span class="line">    PendingArea leafArea = null;</span><br><span class="line">    int leafType = LEAF_TYPE_TOKENS;</span><br><span class="line">    //开始遍历areaForLayer这个数组</span><br><span class="line">    for (int layer = 0; layer &lt; mMaxWindowLayer; layer++) &#123;</span><br><span class="line">        //先根据当前的layer判断所属的type</span><br><span class="line">        int type = typeOfLayer(mWmService.mPolicy, layer);</span><br><span class="line">        //判断是否需要创建一个子容器（主要根据type是否变化）</span><br><span class="line">        if (leafArea == null || leafArea.mParent != areaForLayer[layer]</span><br><span class="line">                || type != leafType) &#123;</span><br><span class="line">            //创建一个子容器，mMinLayer为当前的layer值，父容器为当前layer</span><br><span class="line">            leafArea = new PendingArea(null, layer, areaForLayer[layer]);</span><br><span class="line">            //这里取当前layer，由于每个layer都是赋值的root，实际就是root</span><br><span class="line">            //root对象添加一个子容器</span><br><span class="line">            areaForLayer[layer].mChildren.add(leafArea);</span><br><span class="line">            leafType = type;</span><br><span class="line">            if (leafType == LEAF_TYPE_TASK_CONTAINERS) &#123;</span><br><span class="line">                //这里会去将LEAF_TYPE_TASK_CONTAINERS类型，也就是启动的app的窗口，单独放到一个子容器中</span><br><span class="line">                addTaskDisplayAreasToLayer(areaForLayer[layer], layer);</span><br><span class="line">            &#125; else if (leafType == LEAF_TYPE_IME_CONTAINERS) &#123;</span><br><span class="line">                leafArea.mExisting = mImeContainer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //更新子容器的mMaxLayer</span><br><span class="line">        leafArea.mMaxLayer = layer;</span><br><span class="line">    &#125;</span><br><span class="line">    root.computeMaxLayer();</span><br><span class="line">    //对子容器进行初始化排序</span><br><span class="line">    root.instantiateChildren(mRoot, mAreaForLayer, 0, mAreas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int typeOfLayer(WindowManagerPolicy policy, int layer) &#123;</span><br><span class="line">    if (layer == APPLICATION_LAYER) &#123;</span><br><span class="line">        return LEAF_TYPE_TASK_CONTAINERS;</span><br><span class="line">    &#125; else if (layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD)</span><br><span class="line">            || layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD_DIALOG)) &#123;</span><br><span class="line">        return LEAF_TYPE_IME_CONTAINERS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return LEAF_TYPE_TOKENS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** Adds all task display areas to the specified layer */</span><br><span class="line">private void addTaskDisplayAreasToLayer(PendingArea parentPendingArea, int layer) &#123;</span><br><span class="line">    final int count = mTaskDisplayAreas.size();</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        PendingArea leafArea = new PendingArea(null, layer, parentPendingArea);</span><br><span class="line">        leafArea.mExisting = mTaskDisplayAreas.get(i);</span><br><span class="line">        leafArea.mMaxLayer = layer;</span><br><span class="line">        parentPendingArea.mChildren.add(leafArea);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void instantiateChildren(DisplayArea&lt;DisplayArea&gt; parent,</span><br><span class="line">        DisplayArea.Tokens[] areaForLayer, int level, Map&lt;Feature, List&lt;DisplayArea&lt;?</span><br><span class="line">        extends WindowContainer&gt;&gt;&gt; areas) &#123;</span><br><span class="line">    //根据每个子容器的mMinLayer进行排序</span><br><span class="line">    mChildren.sort(Comparator.comparingInt(pendingArea -&gt; pendingArea.mMinLayer));</span><br><span class="line">    for (int i = 0; i &lt; mChildren.size(); i++) &#123;</span><br><span class="line">        final PendingArea child = mChildren.get(i);</span><br><span class="line">        //创建对应的子容器</span><br><span class="line">        final DisplayArea area = child.createArea(parent, areaForLayer);</span><br><span class="line">        //添加到mRootDisplayArea中，同理会触发mParent.assignChildLayers()改变zOrder</span><br><span class="line">        parent.addChild(area, WindowContainer.POSITION_TOP);</span><br><span class="line">        if (mFeature != null) &#123;</span><br><span class="line">            areas.get(mFeature).add(area);</span><br><span class="line">        &#125;</span><br><span class="line">        child.instantiateChildren(area, areaForLayer, level + 1, areas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line">private DisplayArea createArea(DisplayArea&lt;DisplayArea&gt; parent,</span><br><span class="line">        DisplayArea.Tokens[] areaForLayer) &#123;</span><br><span class="line">    if (mExisting != null) &#123;</span><br><span class="line">        return mExisting;</span><br><span class="line">    &#125;</span><br><span class="line">    DisplayArea.Type type;</span><br><span class="line">    if (mMinLayer &gt; APPLICATION_LAYER) &#123;</span><br><span class="line">        type = DisplayArea.Type.ABOVE_TASKS;</span><br><span class="line">    &#125; else if (mMaxLayer &lt; APPLICATION_LAYER) &#123;</span><br><span class="line">        type = DisplayArea.Type.BELOW_TASKS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        type = DisplayArea.Type.ANY;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mFeature == null) &#123;</span><br><span class="line">        final DisplayArea.Tokens leaf = new DisplayArea.Tokens(parent.mWmService, type,</span><br><span class="line">                &quot;Leaf:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer);</span><br><span class="line">        for (int i = mMinLayer; i &lt;= mMaxLayer; i++) &#123;</span><br><span class="line">            areaForLayer[i] = leaf;</span><br><span class="line">        &#125;</span><br><span class="line">        return leaf;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return new DisplayArea(parent.mWmService, type, mFeature.mName + &quot;:&quot;</span><br><span class="line">                + mMinLayer + &quot;:&quot; + mMaxLayer, mFeature.mId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                        </span><br></pre></td></tr></table></figure>

<p>到此可以知道各个容器间的层级关系，低层级容器中的窗口无法显示在高层级容器的窗口之上：</p>
<ul>
<li>#1 mOverlayContainers</li>
<li>#0 mWindowContainers<ul>
<li>#0 DisplayArea.Root<ul>
<li>#5 Leaf:17:34</li>
<li>#4 ImeContainer</li>
<li>#3 Leaf:3:14</li>
<li>#2 DefaultTaskDisplayArea 这是普通app Activity所在的层级</li>
<li>#1 Leaf:2:2</li>
<li>#0 Leaf:0:1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="输入法的层级"><a href="#输入法的层级" class="headerlink" title="输入法的层级"></a>输入法的层级</h2><p> 输入法的层级不是固定不变的，而是动态变化的<br> 在每次切换app的时候，会重新设置FocusedApp，然后调用WMS中的updateFocusedWindowLocked，<br> 去动态计算mInputMethodTarget,并根据mInputMethodTarget来重新设置mImeWindowsContainers的父容器和relativeLayer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean updateFocusedWindowLocked(int mode, boolean updateInputWindows,</span><br><span class="line">        int topFocusedDisplayId) &#123;</span><br><span class="line">    WindowState newFocus = findFocusedWindowIfNeeded(topFocusedDisplayId);</span><br><span class="line">    if (mCurrentFocus == newFocus) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean imWindowChanged = false;</span><br><span class="line">    final WindowState imWindow = mInputMethodWindow;</span><br><span class="line">    if (imWindow != null) &#123;</span><br><span class="line">        final WindowState prevTarget = mInputMethodTarget;</span><br><span class="line">        //计算imeTagrget</span><br><span class="line">        final WindowState newTarget = computeImeTarget(true /* updateImeTarget*/);</span><br><span class="line">        imWindowChanged = prevTarget != newTarget;</span><br><span class="line"></span><br><span class="line">        if (mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS</span><br><span class="line">                &amp;&amp; mode != UPDATE_FOCUS_WILL_PLACE_SURFACES) &#123;</span><br><span class="line">            assignWindowLayers(false /* setLayoutNeeded */);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //......            </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final Predicate&lt;WindowState&gt; mComputeImeTargetPredicate = w -&gt; &#123;</span><br><span class="line">    if (DEBUG_INPUT_METHOD &amp;&amp; mUpdateImeTarget) Slog.i(TAG_WM, &quot;Checking window @&quot; + w</span><br><span class="line">            + &quot; fl=0x&quot; + Integer.toHexString(w.mAttrs.flags));</span><br><span class="line">    //判断是否可以作为imeTarget</span><br><span class="line">    return w.canBeImeTarget();</span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line">WindowState getWindow(Predicate&lt;WindowState&gt; callback) &#123;</span><br><span class="line">    for (int i = mChildren.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        final WindowState w = mChildren.get(i).getWindow(callback);</span><br><span class="line">        if (w != null) &#123;</span><br><span class="line">            return w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Determine and return the window that should be the IME target.</span><br><span class="line"> * @param updateImeTarget If true the system IME target will be updated to match what we found.</span><br><span class="line"> * @return The window that should be used as the IME target or null if there isn&#x27;t any.</span><br><span class="line"> */</span><br><span class="line">WindowState computeImeTarget(boolean updateImeTarget) &#123;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    final WindowState curTarget = mInputMethodTarget;</span><br><span class="line">    if (!canUpdateImeTarget()) &#123;</span><br><span class="line">        if (DEBUG_INPUT_METHOD) Slog.w(TAG_WM, &quot;Defer updating IME target&quot;);</span><br><span class="line">        return curTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // TODO(multidisplay): Needs some serious rethought when the target and IME are not on the</span><br><span class="line">    // same display. Or even when the current IME/target are not on the same screen as the next</span><br><span class="line">    // IME/target. For now only look for input windows on the main screen.</span><br><span class="line">    mUpdateImeTarget = updateImeTarget;</span><br><span class="line">    //关键在这里，计算target，从上到下进行遍历，找到第一个可以作为imeTarget的window</span><br><span class="line">    WindowState target = getWindow(mComputeImeTargetPredicate);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Yet more tricksyness!  If this window is a &quot;starting&quot; window, we do actually want</span><br><span class="line">    // to be on top of it, but it is not -really- where input will go. So look down below</span><br><span class="line">    // for a real window to target...</span><br><span class="line">    if (target != null &amp;&amp; target.mAttrs.type == TYPE_APPLICATION_STARTING) &#123;</span><br><span class="line">        final ActivityRecord activity = target.mActivityRecord;</span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">            final WindowState betterTarget = activity.getImeTargetBelowWindow(target);</span><br><span class="line">            if (betterTarget != null) &#123;</span><br><span class="line">                target = betterTarget;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_INPUT_METHOD &amp;&amp; updateImeTarget) Slog.v(TAG_WM,</span><br><span class="line">            &quot;Proposed new IME target: &quot; + target + &quot; for display: &quot; + getDisplayId());</span><br><span class="line"></span><br><span class="line">    // Now, a special case -- if the last target&#x27;s window is in the process of exiting, but</span><br><span class="line">    // not removed, keep on the last target to avoid IME flicker. The exception is if the</span><br><span class="line">    // current target is home since we want opening apps to become the IME target right away.</span><br><span class="line">    if (curTarget != null &amp;&amp; !curTarget.mRemoved &amp;&amp; curTarget.isDisplayedLw()</span><br><span class="line">            &amp;&amp; curTarget.isClosing() &amp;&amp; !curTarget.isActivityTypeHome()) &#123;</span><br><span class="line">        if (DEBUG_INPUT_METHOD) Slog.v(TAG_WM, &quot;Not changing target till current window is&quot;</span><br><span class="line">                + &quot; closing and not removed&quot;);</span><br><span class="line">        return curTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_INPUT_METHOD) Slog.v(TAG_WM, &quot;Desired input method target=&quot; + target</span><br><span class="line">            + &quot; updateImeTarget=&quot; + updateImeTarget);</span><br><span class="line"></span><br><span class="line">    if (target == null) &#123;</span><br><span class="line">        if (updateImeTarget) &#123;</span><br><span class="line">            if (DEBUG_INPUT_METHOD) Slog.w(TAG_WM, &quot;Moving IM target from &quot; + curTarget</span><br><span class="line">                    + &quot; to null.&quot; + (SHOW_STACK_CRAWLS ? &quot; Callers=&quot;</span><br><span class="line">                    + Debug.getCallers(4) : &quot;&quot;));</span><br><span class="line">            setInputMethodTarget(null, mInputMethodTargetWaitingAnim);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (updateImeTarget) &#123;</span><br><span class="line">        ActivityRecord activity = curTarget == null ? null : curTarget.mActivityRecord;</span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line"></span><br><span class="line">            // Now some fun for dealing with window animations that modify the Z order. We need</span><br><span class="line">            // to look at all windows below the current target that are in this app, finding the</span><br><span class="line">            // highest visible one in layering.</span><br><span class="line">            WindowState highestTarget = null;</span><br><span class="line">            if (activity.isAnimating(PARENTS | TRANSITION)) &#123;</span><br><span class="line">                highestTarget = activity.getHighestAnimLayerWindow(curTarget);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (highestTarget != null) &#123;</span><br><span class="line">                if (DEBUG_INPUT_METHOD) &#123;</span><br><span class="line">                    Slog.v(TAG_WM, mAppTransition + &quot; &quot; + highestTarget + &quot; animating=&quot;</span><br><span class="line">                            + highestTarget.isAnimating(TRANSITION | PARENTS));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mAppTransition.isTransitionSet()) &#123;</span><br><span class="line">                    // If we are currently setting up for an animation, hold everything until we</span><br><span class="line">                    // can find out what will happen.</span><br><span class="line">                    setInputMethodTarget(highestTarget, true);</span><br><span class="line">                    return highestTarget;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_INPUT_METHOD) Slog.w(TAG_WM, &quot;Moving IM target from &quot; + curTarget + &quot; to &quot;</span><br><span class="line">                + target + (SHOW_STACK_CRAWLS ? &quot; Callers=&quot; + Debug.getCallers(4) : &quot;&quot;));</span><br><span class="line">        //这里对mInputMethodTarget进行赋值</span><br><span class="line">        setInputMethodTarget(target, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return target;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>接着主要就是去看WindowState中的canBeImeTarget:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean canBeImeTarget() &#123;</span><br><span class="line">    // If any of the embedded windows can be the IME target, this window will be the final IME</span><br><span class="line">    // target. This is because embedded windows are on a different display in WM so it would</span><br><span class="line">    // cause confusion trying to set the IME to a window on a different display. Instead, just</span><br><span class="line">    // make the host window the IME target.</span><br><span class="line">    if (canWindowInEmbeddedDisplayBeImeTarget()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mIsImWindow) &#123;</span><br><span class="line">        // IME windows can&#x27;t be IME targets. IME targets are required to be below the IME</span><br><span class="line">        // windows and that wouldn&#x27;t be possible if the IME window is its own target...silly.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (inPinnedWindowingMode()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mAttrs.type == TYPE_SCREENSHOT) &#123;</span><br><span class="line">        // Disallow screenshot windows from being IME targets</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final boolean windowsAreFocusable = mActivityRecord == null || mActivityRecord.windowsAreFocusable();</span><br><span class="line">    if (!windowsAreFocusable) &#123;</span><br><span class="line">        // This window can&#x27;t be an IME target if the app&#x27;s windows should not be focusable.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ActivityStack stack = getRootTask();</span><br><span class="line">    if (stack != null &amp;&amp; !stack.isFocusable()) &#123;</span><br><span class="line">        // Ignore when the stack shouldn&#x27;t receive input event.</span><br><span class="line">        // (i.e. the minimized stack in split screen mode.)</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mAttrs.type == TYPE_APPLICATION_STARTING) &#123;</span><br><span class="line">        // Ignore mayUseInputMethod for starting window for now.</span><br><span class="line">        // TODO(b/159911356): Remove this special casing (originally added in commit e75d872).</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // TODO(b/145812508): Clean this up in S, may depend on b/141738570</span><br><span class="line">        //  The current logic lets windows become the &quot;ime target&quot; even though they are</span><br><span class="line">        //  not-focusable and can thus never actually start input.</span><br><span class="line">        //  Ideally, this would reject windows where mayUseInputMethod() == false, but this</span><br><span class="line">        //  also impacts Z-ordering of and delivery of IME insets to child windows, which means</span><br><span class="line">        //  that simply disallowing non-focusable windows would break apps.</span><br><span class="line">        //  See b/159438771, b/144619551.</span><br><span class="line"></span><br><span class="line">        final int fl = mAttrs.flags &amp; (FLAG_NOT_FOCUSABLE | FLAG_ALT_FOCUSABLE_IM);</span><br><span class="line"></span><br><span class="line">        // Can only be an IME target if both FLAG_NOT_FOCUSABLE and FLAG_ALT_FOCUSABLE_IM are</span><br><span class="line">        // set or both are cleared...and not a starting window.</span><br><span class="line">        if (fl != 0 &amp;&amp; fl != (FLAG_NOT_FOCUSABLE | FLAG_ALT_FOCUSABLE_IM)) &#123;</span><br><span class="line">            //只要设置了FLAG_NOT_FOCUSABLE和FLAG_ALT_FOCUSABLE_IM其中一个就直接返回false</span><br><span class="line">            //所以要让window能成为imeTarget的前提就是要么2个flag都不设置，要么2个都设置</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_INPUT_METHOD) &#123;</span><br><span class="line">        Slog.i(TAG_WM, &quot;isVisibleOrAdding &quot; + this + &quot;: &quot; + isVisibleOrAdding());</span><br><span class="line">        if (!isVisibleOrAdding()) &#123;</span><br><span class="line">            Slog.i(TAG_WM, &quot;  mSurfaceController=&quot; + mWinAnimator.mSurfaceController</span><br><span class="line">                    + &quot; relayoutCalled=&quot; + mRelayoutCalled</span><br><span class="line">                    + &quot; viewVis=&quot; + mViewVisibility</span><br><span class="line">                    + &quot; policyVis=&quot; + isVisibleByPolicy()</span><br><span class="line">                    + &quot; policyVisAfterAnim=&quot; + mLegacyPolicyVisibilityAfterAnim</span><br><span class="line">                    + &quot; parentHidden=&quot; + isParentWindowHidden()</span><br><span class="line">                    + &quot; exiting=&quot; + mAnimatingExit + &quot; destroying=&quot; + mDestroying);</span><br><span class="line">            if (mActivityRecord != null) &#123;</span><br><span class="line">                Slog.i(TAG_WM, &quot;  mActivityRecord.visibleRequested=&quot;</span><br><span class="line">                        + mActivityRecord.mVisibleRequested);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //最后去判断window是否可见</span><br><span class="line">    return isVisibleOrAdding();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Same as isVisible(), but we also count it as visible between the</span><br><span class="line"> * call to IWindowSession.add() and the first relayout().</span><br><span class="line"> */</span><br><span class="line">boolean isVisibleOrAdding() &#123;</span><br><span class="line">    final ActivityRecord atoken = mActivityRecord;</span><br><span class="line">    return (mHasSurface || (!mRelayoutCalled &amp;&amp; mViewVisibility == View.VISIBLE))</span><br><span class="line">            &amp;&amp; isVisibleByPolicy() &amp;&amp; !isParentWindowHidden()</span><br><span class="line">            &amp;&amp; (atoken == null || atoken.mVisibleRequested)</span><br><span class="line">            &amp;&amp; !mAnimatingExit &amp;&amp; !mDestroying;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Insets相关</title>
    <url>//pages/614bde/</url>
    <content><![CDATA[<h2 id="简单概念"><a href="#简单概念" class="headerlink" title="简单概念"></a>简单概念</h2><p>在aosp中，顶部的状态栏，底部的导航栏占用的空间被抽象成了一个Insets，<br>Insets用来表示一个矩形的四个边缘的内边距（注意，表示的是上下左右的内变距，不是系统栏的坐标，也不是描述系统栏的对象）<br>例如 Insets.of(0, 100, 0, 0),表示的是上方有100的内边距的矩形，<br>最终会将多个Insets进行计算，生成一个处理了各个系统栏之后的Insets值，这个insets表示当前窗口的4个方向上的内边距<br>Insets是一个序列化的实体类,可以类比Rect:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class Insets implements Parcelable &#123;</span><br><span class="line">    public static final @NonNull Insets NONE = new Insets(0, 0, 0, 0);</span><br><span class="line"></span><br><span class="line">    public final int left;</span><br><span class="line">    public final int top;</span><br><span class="line">    public final int right;</span><br><span class="line">    public final int bottom;</span><br><span class="line"></span><br><span class="line">    private Insets(int left, int top, int right, int bottom) &#123;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.top = top;</span><br><span class="line">        this.right = right;</span><br><span class="line">        this.bottom = bottom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外还有一个InsetsState，更加细化了Insets的状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final int ITYPE_INVALID = -1;</span><br><span class="line"></span><br><span class="line">static final int FIRST_TYPE = 0;</span><br><span class="line"></span><br><span class="line">public static final int ITYPE_STATUS_BAR = FIRST_TYPE;</span><br><span class="line">public static final int ITYPE_NAVIGATION_BAR = 1;</span><br><span class="line">public static final int ITYPE_CAPTION_BAR = 2;</span><br><span class="line"></span><br><span class="line">public static final int ITYPE_TOP_GESTURES = 3;</span><br><span class="line">public static final int ITYPE_BOTTOM_GESTURES = 4;</span><br><span class="line">public static final int ITYPE_LEFT_GESTURES = 5;</span><br><span class="line">public static final int ITYPE_RIGHT_GESTURES = 6;</span><br><span class="line"></span><br><span class="line">/** Additional gesture inset types that map into &#123;@link Type.MANDATORY_SYSTEM_GESTURES&#125;. */</span><br><span class="line">public static final int ITYPE_TOP_MANDATORY_GESTURES = 7;</span><br><span class="line">public static final int ITYPE_BOTTOM_MANDATORY_GESTURES = 8;</span><br><span class="line">public static final int ITYPE_LEFT_MANDATORY_GESTURES = 9;</span><br><span class="line">public static final int ITYPE_RIGHT_MANDATORY_GESTURES = 10;</span><br><span class="line"></span><br><span class="line">public static final int ITYPE_TOP_TAPPABLE_ELEMENT = 11;</span><br><span class="line">public static final int ITYPE_BOTTOM_TAPPABLE_ELEMENT = 12;</span><br><span class="line"></span><br><span class="line">public static final int ITYPE_LEFT_DISPLAY_CUTOUT = 13;</span><br><span class="line">public static final int ITYPE_TOP_DISPLAY_CUTOUT = 14;</span><br><span class="line">public static final int ITYPE_RIGHT_DISPLAY_CUTOUT = 15;</span><br><span class="line">public static final int ITYPE_BOTTOM_DISPLAY_CUTOUT = 16;</span><br><span class="line"></span><br><span class="line">/** Input method window. */</span><br><span class="line">public static final int ITYPE_IME = 17;</span><br><span class="line"></span><br><span class="line">/** Additional system decorations inset type. */</span><br><span class="line">public static final int ITYPE_CLIMATE_BAR = 18;</span><br><span class="line">public static final int ITYPE_EXTRA_NAVIGATION_BAR = 19;</span><br><span class="line"></span><br><span class="line">static final int LAST_TYPE = ITYPE_EXTRA_NAVIGATION_BAR;</span><br><span class="line">public static final int SIZE = LAST_TYPE + 1;</span><br><span class="line"></span><br><span class="line">// Derived types</span><br><span class="line"></span><br><span class="line">/** A shelf is the same as the navigation bar. */</span><br><span class="line">public static final int ITYPE_SHELF = ITYPE_NAVIGATION_BAR;</span><br><span class="line"></span><br><span class="line">//提供静态方法，获取InsetsState对应的公共的Insets的类型</span><br><span class="line">public static @Type.InsetsType int toPublicType(@InternalInsetsType int type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case ITYPE_STATUS_BAR:</span><br><span class="line">            return Type.STATUS_BARS;</span><br><span class="line">        case ITYPE_NAVIGATION_BAR:</span><br><span class="line">        case ITYPE_CLIMATE_BAR:</span><br><span class="line">        case ITYPE_EXTRA_NAVIGATION_BAR:</span><br><span class="line">            return Type.NAVIGATION_BARS;</span><br><span class="line">        case ITYPE_CAPTION_BAR:</span><br><span class="line">            return Type.CAPTION_BAR;</span><br><span class="line">        case ITYPE_IME:</span><br><span class="line">            return Type.IME;</span><br><span class="line">        case ITYPE_TOP_GESTURES:</span><br><span class="line">        case ITYPE_BOTTOM_GESTURES:</span><br><span class="line">        case ITYPE_TOP_MANDATORY_GESTURES:</span><br><span class="line">        case ITYPE_BOTTOM_MANDATORY_GESTURES:</span><br><span class="line">        case ITYPE_LEFT_MANDATORY_GESTURES:</span><br><span class="line">        case ITYPE_RIGHT_MANDATORY_GESTURES:</span><br><span class="line">            return Type.MANDATORY_SYSTEM_GESTURES;</span><br><span class="line">        case ITYPE_LEFT_GESTURES:</span><br><span class="line">        case ITYPE_RIGHT_GESTURES:</span><br><span class="line">            return Type.SYSTEM_GESTURES;</span><br><span class="line">        case ITYPE_TOP_TAPPABLE_ELEMENT:</span><br><span class="line">        case ITYPE_BOTTOM_TAPPABLE_ELEMENT:</span><br><span class="line">            return Type.TAPPABLE_ELEMENT;</span><br><span class="line">        case ITYPE_LEFT_DISPLAY_CUTOUT:</span><br><span class="line">        case ITYPE_TOP_DISPLAY_CUTOUT:</span><br><span class="line">        case ITYPE_RIGHT_DISPLAY_CUTOUT:</span><br><span class="line">        case ITYPE_BOTTOM_DISPLAY_CUTOUT:</span><br><span class="line">            return Type.DISPLAY_CUTOUT;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unknown type: &quot; + type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Insets的类型"><a href="#Insets的类型" class="headerlink" title="Insets的类型"></a>Insets的类型</h2><p>Insets的类型定义在WindowInsets.Type中，并且定义了每个type的索引值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int FIRST = 1 &lt;&lt; 0;</span><br><span class="line">static final int STATUS_BARS = FIRST;           //状态栏</span><br><span class="line">static final int NAVIGATION_BARS = 1 &lt;&lt; 1;      //导航栏</span><br><span class="line">static final int CAPTION_BAR = 1 &lt;&lt; 2;          //标题栏</span><br><span class="line"></span><br><span class="line">static final int IME = 1 &lt;&lt; 3;</span><br><span class="line"></span><br><span class="line">static final int SYSTEM_GESTURES = 1 &lt;&lt; 4;</span><br><span class="line">static final int MANDATORY_SYSTEM_GESTURES = 1 &lt;&lt; 5;</span><br><span class="line">static final int TAPPABLE_ELEMENT = 1 &lt;&lt; 6;</span><br><span class="line"></span><br><span class="line">static final int DISPLAY_CUTOUT = 1 &lt;&lt; 7;</span><br><span class="line"></span><br><span class="line">static final int LAST = 1 &lt;&lt; 8;</span><br><span class="line">static final int SIZE = 9;</span><br><span class="line">static final int WINDOW_DECOR = LAST;</span><br><span class="line"></span><br><span class="line">//提供静态方法获取对应type的索引值</span><br><span class="line">static int indexOf(@InsetsType int type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case STATUS_BARS:</span><br><span class="line">            return 0;</span><br><span class="line">        case NAVIGATION_BARS:</span><br><span class="line">            return 1;</span><br><span class="line">        case CAPTION_BAR:</span><br><span class="line">            return 2;</span><br><span class="line">        case IME:</span><br><span class="line">            return 3;</span><br><span class="line">        case SYSTEM_GESTURES:</span><br><span class="line">            return 4;</span><br><span class="line">        case MANDATORY_SYSTEM_GESTURES:</span><br><span class="line">            return 5;</span><br><span class="line">        case TAPPABLE_ELEMENT:</span><br><span class="line">            return 6;</span><br><span class="line">        case DISPLAY_CUTOUT:</span><br><span class="line">            return 7;</span><br><span class="line">        case WINDOW_DECOR:</span><br><span class="line">            return 8;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalArgumentException(&quot;type needs to be &gt;= FIRST and &lt;= LAST,&quot;</span><br><span class="line">                    + &quot; type=&quot; + type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<h2 id="Insets的方向（侧）"><a href="#Insets的方向（侧）" class="headerlink" title="Insets的方向（侧）"></a>Insets的方向（侧）</h2><p>Insets可以在上、下、左、右，它的定义在WindowInsets.Side中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final int LEFT = 1 &lt;&lt; 0;</span><br><span class="line">public static final int TOP = 1 &lt;&lt; 1;</span><br><span class="line">public static final int RIGHT = 1 &lt;&lt; 2;</span><br><span class="line">public static final int BOTTOM = 1 &lt;&lt; 3;</span><br></pre></td></tr></table></figure>

<h2 id="关于内边距消费"><a href="#关于内边距消费" class="headerlink" title="关于内边距消费"></a>关于内边距消费</h2><p>AOSP中关于insets的处理很多地方用到consume来进行命名，<br>这里的消费内边距是指是否已经处理过，消费过的就不再往下传递，子view就不再需要再进行处理</p>
<h2 id="WindowInsets"><a href="#WindowInsets" class="headerlink" title="WindowInsets"></a>WindowInsets</h2><p>WindowInsets是用来描述窗口insets的集合的类。<br>主要看里面几个成员变量：</p>
<ul>
<li><p>mTypeInsetsMap        用来保存当前各个类型内边距的数组</p>
</li>
<li><p>mTypeMaxInsetsMap     用来保存忽略可见性时（认为一直存在），各个类型内边距的数组</p>
</li>
<li><p>mTypeVisibilityMap    用来保存各个类型的Inset的可见性</p>
</li>
<li><p>mAlwaysConsumeSystemBars</p>
</li>
<li><p>mSystemWindowInsetsConsumed   标记当前是否已经消费了显示出来的系统窗口所产生的内边距</p>
</li>
<li><p>mStableInsetsConsumed         标记是否已经消费了所有系统窗口占位产生的内边距</p>
</li>
<li><p>mDisplayCutoutConsumed        标记是否已经消费了缺口（刘海）区域的内边距</p>
</li>
<li><p>mCompatInsetsTypes            记录关注的insets类型，计算内边距时会根据这个来取数据源进行计算</p>
</li>
<li><p>mCompatIgnoreVisibility       标记是否忽略产生内边距的来源窗口的可见性,忽略可见性时，就会认为所有产生占位的窗口都是可见的</p>
</li>
</ul>
<p>再看看它的构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Construct a new WindowInsets from individual insets.</span><br><span class="line">     *</span><br><span class="line">     * &#123;@code typeInsetsMap&#125; and &#123;@code typeMaxInsetsMap&#125; are a map of indexOf(type) -&gt; insets that</span><br><span class="line">     * contain the information what kind of system bars causes how much insets. The insets in this</span><br><span class="line">     * map are non-additive; i.e. they have the same origin. In other words: If two system bars</span><br><span class="line">     * overlap on one side, the insets of the larger bar will also include the insets of the smaller</span><br><span class="line">     * bar.</span><br><span class="line">     *</span><br><span class="line">     * &#123;@code null&#125; type inset map indicates that the respective inset is fully consumed.</span><br><span class="line">     * @hide</span><br><span class="line">     */</span><br><span class="line">    public WindowInsets(@Nullable Insets[] typeInsetsMap,</span><br><span class="line">            @Nullable Insets[] typeMaxInsetsMap,</span><br><span class="line">            boolean[] typeVisibilityMap,</span><br><span class="line">            boolean isRound,</span><br><span class="line">            boolean alwaysConsumeSystemBars, DisplayCutout displayCutout,</span><br><span class="line">            @InsetsType int compatInsetsTypes, boolean compatIgnoreVisibility) &#123;</span><br><span class="line">        //传入typeInsetsMap为null，认为当前显示出来的系统窗口占位产生的内边距已经被消费了</span><br><span class="line">        mSystemWindowInsetsConsumed = typeInsetsMap == null;</span><br><span class="line">        //被消费过的直接初始化一个数组，元素全为null</span><br><span class="line">        mTypeInsetsMap = mSystemWindowInsetsConsumed</span><br><span class="line">                ? new Insets[SIZE]</span><br><span class="line">                : typeInsetsMap.clone();</span><br><span class="line"></span><br><span class="line">        //传入typeMaxInsetsMap为null，认为所有系统窗口占位产生的内边距已经被消费了</span><br><span class="line">        mStableInsetsConsumed = typeMaxInsetsMap == null;</span><br><span class="line">        mTypeMaxInsetsMap = mStableInsetsConsumed</span><br><span class="line">                ? new Insets[SIZE]</span><br><span class="line">                : typeMaxInsetsMap.clone();</span><br><span class="line"></span><br><span class="line">        mTypeVisibilityMap = typeVisibilityMap;</span><br><span class="line">        mIsRound = isRound;</span><br><span class="line">        mAlwaysConsumeSystemBars = alwaysConsumeSystemBars;</span><br><span class="line">        mCompatInsetsTypes = compatInsetsTypes;</span><br><span class="line">        mCompatIgnoreVisibility = compatIgnoreVisibility;</span><br><span class="line"></span><br><span class="line">        mDisplayCutoutConsumed = displayCutout == null;</span><br><span class="line">        mDisplayCutout = (mDisplayCutoutConsumed || displayCutout.isEmpty())</span><br><span class="line">                ? null : displayCutout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="InsetsState"><a href="#InsetsState" class="headerlink" title="InsetsState"></a>InsetsState</h2><p>InsetsState是用来保存窗口insets状态的集合的类。主要有一个成员变量<code>mSources</code>，<br><code>mSources</code>是一个InsetsSource数组，保存了当前窗口所有的insets。</p>
<h2 id="一个Activity创建时Insets相关逻辑"><a href="#一个Activity创建时Insets相关逻辑" class="headerlink" title="一个Activity创建时Insets相关逻辑"></a>一个Activity创建时Insets相关逻辑</h2><p>在ViewRootImpl的第一次performTraversals中会执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br></pre></td></tr></table></figure>
<p>其实就是调用DecorView的dispatchAttachedToWindow</p>
<p>ViewRootImpl.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    Rect frame = mWinFrame;</span><br><span class="line">    if (mFirst) &#123;</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        // Set the layout direction if it has not been set before (inherit is the default)</span><br><span class="line">        if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) &#123;</span><br><span class="line">            host.setLayoutDirection(config.getLayoutDirection());</span><br><span class="line">        &#125;</span><br><span class="line">        host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);</span><br><span class="line">        dispatchApplyInsets(host);</span><br><span class="line">    &#125; </span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123;</span><br><span class="line">    mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;</span><br><span class="line">    super.dispatchAttachedToWindow(info, visibility);</span><br><span class="line">    mGroupFlags &amp;= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>View.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)</span><br><span class="line">void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123;</span><br><span class="line">    //....</span><br><span class="line">    performCollectViewAttributes(mAttachInfo, visibility);</span><br><span class="line">    //这里调用onAttachedToWindow</span><br><span class="line">    onAttachedToWindow();</span><br><span class="line"></span><br><span class="line">    L//....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要看DecorView中重写的onAttachedToWindow<br>DecorView.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onAttachedToWindow() &#123;</span><br><span class="line">    super.onAttachedToWindow();</span><br><span class="line"></span><br><span class="line">    //方法最后一行</span><br><span class="line">    mWindow.onViewRootImplSet(getViewRootImpl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PhoneWindow.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Notify when decor view is attached to window and &#123;@link ViewRootImpl&#125; is available. */</span><br><span class="line">void onViewRootImplSet(ViewRootImpl viewRoot) &#123;</span><br><span class="line">    viewRoot.setActivityConfigCallback(mActivityConfigCallback);</span><br><span class="line">    //这里让DecorView去Fits SystemWindows</span><br><span class="line">    applyDecorFitsSystemWindows();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void applyDecorFitsSystemWindows() &#123;</span><br><span class="line">    ViewRootImpl impl = getViewRootImplOrNull();</span><br><span class="line">    if (impl != null) &#123;</span><br><span class="line">        //默认mDecorFitsSystemWindows是true</span><br><span class="line">        impl.setOnContentApplyWindowInsetsListener(mDecorFitsSystemWindows</span><br><span class="line">                ? sDefaultContentInsetsApplier</span><br><span class="line">                : null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean mDecorFitsSystemWindows = true;</span><br><span class="line"></span><br><span class="line">private static final OnContentApplyWindowInsetsListener sDefaultContentInsetsApplier =</span><br><span class="line">        (view, insets) -&gt; &#123;</span><br><span class="line">            //这里的SYSTEM_UI_LAYOUT_FLAGS = SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;</span><br><span class="line">            //也就是说只要有这2Flag中的其中一个，就会返回Insets.NONE</span><br><span class="line">            if ((view.getWindowSystemUiVisibility() &amp; SYSTEM_UI_LAYOUT_FLAGS) != 0) &#123;</span><br><span class="line">                return new Pair&lt;&gt;(Insets.NONE, insets);</span><br><span class="line">            &#125;</span><br><span class="line">            Insets insetsToApply = insets.getSystemWindowInsets();</span><br><span class="line">            return new Pair&lt;&gt;(insetsToApply,</span><br><span class="line">                    insets.inset(insetsToApply).consumeSystemWindowInsets());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里返回的insets是最终需要用到的，在View的computeSystemWindowInsets中会取到这个值，然后调用applyInsets<br>内部调用internalSetPadding设置padding</p>
<p><strong>所以非全屏模式下，Activity的DecorView下的直接子view会设置padding</strong>，然后将剩下的没消费的WindowInsets标记为消费，不再继续传递给子View</p>
<h2 id="Activity中的Insets值的计算"><a href="#Activity中的Insets值的计算" class="headerlink" title="Activity中的Insets值的计算"></a>Activity中的Insets值的计算</h2><p>首先，在ViewRootImpl中有一个dispatchApplyInsets方法用来处理Insets变化的业务，<br>在第一次performTraversals的时候，会回调DecorView的onAttachedToWindow<br>ViewRootImpl.java:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    //......</span><br><span class="line">    if (mFirst) &#123;</span><br><span class="line">        //......</span><br><span class="line">        //host就是mView，即DecorView，这里调用View的dispatchAttachedToWindow</span><br><span class="line">        host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);</span><br><span class="line">        dispatchApplyInsets(host);            </span><br><span class="line">    &#125;    </span><br><span class="line">    //......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>View</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123;</span><br><span class="line">    //......</span><br><span class="line">    performCollectViewAttributes(mAttachInfo, visibility);</span><br><span class="line">    //这里调用到子类DecorView的方法</span><br><span class="line">    onAttachedToWindow();</span><br><span class="line">    //......        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecorView</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void onAttachedToWindow() &#123;</span><br><span class="line">    //......</span><br><span class="line">    //在最后调用PhoneWindow的onViewRootImplSet</span><br><span class="line">    mWindow.onViewRootImplSet(getViewRootImpl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PhoneWindow.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void onViewRootImplSet(ViewRootImpl viewRoot) &#123;</span><br><span class="line">    viewRoot.setActivityConfigCallback(mActivityConfigCallback);</span><br><span class="line">    applyDecorFitsSystemWindows();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void applyDecorFitsSystemWindows() &#123;</span><br><span class="line">    ViewRootImpl impl = getViewRootImplOrNull();</span><br><span class="line">    if (impl != null) &#123;</span><br><span class="line">        //给ViewRootImpl设置了一个Insets变化的默认处理器，主要进行最终的insets计算的</span><br><span class="line">        impl.setOnContentApplyWindowInsetsListener(mDecorFitsSystemWindows</span><br><span class="line">                ? sDefaultContentInsetsApplier</span><br><span class="line">                : null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public static final int SYSTEM_UI_LAYOUT_FLAGS =</span><br><span class="line">        SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span><br><span class="line">        | SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;    </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @see Window#setDecorFitsSystemWindows</span><br><span class="line"> */</span><br><span class="line">private static final OnContentApplyWindowInsetsListener sDefaultContentInsetsApplier =</span><br><span class="line">        (view, insets) -&gt; &#123;</span><br><span class="line">            //这里的View其时是DecorView下的子View,即DecorView的mContentRoot</span><br><span class="line">            //判断的是如果有LAYOUT相关的Flag，根布局不消费内边距，继续传递给子视图</span><br><span class="line">            if ((view.getWindowSystemUiVisibility() &amp; SYSTEM_UI_LAYOUT_FLAGS) != 0) &#123;</span><br><span class="line">                return new Pair&lt;&gt;(Insets.NONE, insets);</span><br><span class="line">            &#125;</span><br><span class="line">            //否则就会根据mCompatInsetsTypes去获取系统窗口所占用的位置，mCompatInsetsTypes和flag有关</span><br><span class="line">            Insets insetsToApply = insets.getSystemWindowInsets();</span><br><span class="line">            //最后返回2个对象</span><br><span class="line">            //第一个insetsToApply是需要DecorView下的子View处理的内边距</span><br><span class="line">            //第二个是 原来的insets移除insetsToApply这一部分也标记为消费</span><br><span class="line">            return new Pair&lt;&gt;(insetsToApply,</span><br><span class="line">                    insets.inset(insetsToApply).consumeSystemWindowInsets());</span><br><span class="line">        &#125;;    </span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<p>这里关注一下ViewRootImpl中设置的默认的内边距apply监听，先看看这个接口的描述,<br>onContentApplyWindowInsets接口回调的2个参数是当前要进行处理的view，以及还未处理的内边距<br>最后要返回的是2个对象，<br>第一个是一个insets（交给Decorview下的子view的）<br>第二个是要继续分法给子view的WindowInsets</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface OnContentApplyWindowInsetsListener &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Called when the window needs to apply insets on the container of its content view which</span><br><span class="line">     * are set by calling &#123;@link #setContentView&#125;. The method should determine what insets to</span><br><span class="line">     * apply on the container of the root level content view and what should be dispatched to</span><br><span class="line">     * the content view&#x27;s</span><br><span class="line">     * &#123;@link View#setOnApplyWindowInsetsListener(OnApplyWindowInsetsListener)&#125; through the view</span><br><span class="line">     * hierarchy.</span><br><span class="line">     *</span><br><span class="line">     * @param view The view for which to apply insets. Must not be directly modified.</span><br><span class="line">     * @param insets The root level insets that are about to be dispatched</span><br><span class="line">     * @return A pair, with the first element containing the insets to apply as margin to the</span><br><span class="line">     * root-level content views, and the second element determining what should be</span><br><span class="line">     * dispatched to the content view.</span><br><span class="line">     */</span><br><span class="line">    @NonNull</span><br><span class="line">    Pair&lt;Insets, WindowInsets&gt; onContentApplyWindowInsets(@NonNull View view,</span><br><span class="line">            @NonNull WindowInsets insets);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="Activity中设置Insets的流程"><a href="#Activity中设置Insets的流程" class="headerlink" title="Activity中设置Insets的流程"></a>Activity中设置Insets的流程</h2><p>在ViewRootImpl中在performTraversals的时候，如果Insets发生了变化或者主动请求刷新（requestFitSystemWindows）的时候，<br>会去调用dispatchApplyInsets，内部去调用的View（实例是DecorView）的dispatchApplyWindowInsets</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void dispatchApplyInsets(View host) &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;dispatchApplyInsets&quot;);</span><br><span class="line">    mApplyInsetsRequested = false;</span><br><span class="line">    //先获取所有的Insets</span><br><span class="line">    WindowInsets insets = getWindowInsets(true /* forceConstruct */);</span><br><span class="line">    if (!shouldDispatchCutout()) &#123;</span><br><span class="line">        // Window is either not laid out in cutout or the status bar inset takes care of</span><br><span class="line">        // clearing the cutout, so we don&#x27;t need to dispatch the cutout to the hierarchy.</span><br><span class="line">        insets = insets.consumeDisplayCutout();</span><br><span class="line">    &#125;</span><br><span class="line">    //然后调用Decorview的dispatchApplyWindowInsets</span><br><span class="line">    host.dispatchApplyWindowInsets(insets);</span><br><span class="line">    mAttachInfo.delayNotifyContentCaptureInsetsEvent(insets.getInsets(Type.all()));</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有2个关键点，一个是获取的Insets的逻辑（getWindowInsets），一个是处理Insets的逻辑（dispatchApplyWindowInsets）</p>
<h3 id="ViewRootImpl–getWindowInsets，获取当前窗口的insets（内边距）"><a href="#ViewRootImpl–getWindowInsets，获取当前窗口的insets（内边距）" class="headerlink" title="ViewRootImpl–getWindowInsets，获取当前窗口的insets（内边距）"></a>ViewRootImpl–getWindowInsets，获取当前窗口的insets（内边距）</h3><p>先来看看获取Insets的逻辑，内部传入了mWindowAttributes相关值，交给InsetsController去计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* package */ WindowInsets getWindowInsets(boolean forceConstruct) &#123;</span><br><span class="line">    if (mLastWindowInsets == null || forceConstruct) &#123;</span><br><span class="line">        //传入window的信息，交给mInsetsController成员去处理</span><br><span class="line">        mLastWindowInsets = mInsetsController.calculateInsets(</span><br><span class="line">                mContext.getResources().getConfiguration().isScreenRound(),</span><br><span class="line">                mAttachInfo.mAlwaysConsumeSystemBars, mPendingDisplayCutout.get(),</span><br><span class="line">                mWindowAttributes.softInputMode, mWindowAttributes.flags,</span><br><span class="line">                (mWindowAttributes.systemUiVisibility</span><br><span class="line">                        | mWindowAttributes.subtreeSystemUiVisibility));</span><br><span class="line"></span><br><span class="line">        Rect visibleInsets = mInsetsController.calculateVisibleInsets(</span><br><span class="line">                mWindowAttributes.softInputMode);</span><br><span class="line"></span><br><span class="line">        mAttachInfo.mVisibleInsets.set(visibleInsets);</span><br><span class="line">        mAttachInfo.mContentInsets.set(mLastWindowInsets.getSystemWindowInsets().toRect());</span><br><span class="line">        mAttachInfo.mStableInsets.set(mLastWindowInsets.getStableInsets().toRect());</span><br><span class="line">    &#125;</span><br><span class="line">    return mLastWindowInsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InsetsController.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** The local state */</span><br><span class="line">private final InsetsState mState = new InsetsState();</span><br><span class="line"></span><br><span class="line">public WindowInsets calculateInsets(boolean isScreenRound,</span><br><span class="line">        boolean alwaysConsumeSystemBars, DisplayCutout cutout,</span><br><span class="line">        int legacySoftInputMode, int legacyWindowFlags, int legacySystemUiFlags) &#123;</span><br><span class="line">    //InsetsController会将传入的信息保存为全局变量</span><br><span class="line">    mLastLegacySoftInputMode = legacySoftInputMode;</span><br><span class="line">    mLastLegacyWindowFlags = legacyWindowFlags;</span><br><span class="line">    mLastLegacySystemUiFlags = legacySystemUiFlags;</span><br><span class="line">    mLastDisplayCutout = cutout;</span><br><span class="line"></span><br><span class="line">    //又调用InsetsState的calculateInsets</span><br><span class="line">    mLastInsets = mState.calculateInsets(mFrame, null /* ignoringVisibilityState*/,</span><br><span class="line">            isScreenRound, alwaysConsumeSystemBars, cutout,</span><br><span class="line">            legacySoftInputMode, legacyWindowFlags, legacySystemUiFlags,</span><br><span class="line">            null /* typeSideMap */);</span><br><span class="line">    return mLastInsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InsetsState.java<br>InsetsState的calculateInsets方法会去计算当前界面，所有类型的占位窗口对当前界面产生的内边距信息，封装成一个WindowInsets对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public WindowInsets calculateInsets(Rect frame, @Nullable InsetsState ignoringVisibilityState,</span><br><span class="line">            boolean isScreenRound, boolean alwaysConsumeSystemBars, DisplayCutout cutout,</span><br><span class="line">            int legacySoftInputMode, int legacyWindowFlags, int legacySystemUiFlags,</span><br><span class="line">            @Nullable @InternalInsetsSide SparseIntArray typeSideMap) &#123;</span><br><span class="line">        //初始化局部变量</span><br><span class="line">        //存储每种内边距类型的当前内边距</span><br><span class="line">        Insets[] typeInsetsMap = new Insets[Type.SIZE];</span><br><span class="line">        //存储每种内边距类型的最大内边距(即一直认为其可见时的内边距)</span><br><span class="line">        Insets[] typeMaxInsetsMap = new Insets[Type.SIZE];</span><br><span class="line">        //存储每种内边距类型的可见性状态</span><br><span class="line">        boolean[] typeVisibilityMap = new boolean[SIZE];</span><br><span class="line">        final Rect relativeFrame = new Rect(frame);</span><br><span class="line">        final Rect relativeFrameMax = new Rect(frame);</span><br><span class="line">        //遍历所有的内边距类型</span><br><span class="line">        for (int type = FIRST_TYPE; type &lt;= LAST_TYPE; type++) &#123;</span><br><span class="line">            InsetsSource source = mSources[type];</span><br><span class="line">            //将遍历出来的为空的以 Insets.NONE 保存到typeInsetsMap</span><br><span class="line">            if (source == null) &#123;</span><br><span class="line">                int index = indexOf(toPublicType(type));</span><br><span class="line">                if (typeInsetsMap[index] == null) &#123;</span><br><span class="line">                    typeInsetsMap[index] = Insets.NONE;</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //标记需要跳过的类型</span><br><span class="line">            boolean skipNonImeInImeMode = ViewRootImpl.sNewInsetsMode == NEW_INSETS_MODE_IME</span><br><span class="line">                    &amp;&amp; source.getType() != ITYPE_IME;</span><br><span class="line">            boolean skipSystemBars = ViewRootImpl.sNewInsetsMode != NEW_INSETS_MODE_FULL</span><br><span class="line">                    &amp;&amp; (type == ITYPE_STATUS_BAR || type == ITYPE_NAVIGATION_BAR);</span><br><span class="line">            boolean skipLegacyTypes = ViewRootImpl.sNewInsetsMode == NEW_INSETS_MODE_NONE</span><br><span class="line">                    &amp;&amp; (type == ITYPE_STATUS_BAR || type == ITYPE_NAVIGATION_BAR</span><br><span class="line">                            || type == ITYPE_IME);</span><br><span class="line">            //针对需要跳过计算的，将其可见性保存在typeVisibilityMap，不进行后续内边距计算</span><br><span class="line">            if (skipSystemBars || skipLegacyTypes || skipNonImeInImeMode) &#123;</span><br><span class="line">                typeVisibilityMap[indexOf(toPublicType(type))] = source.isVisible();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //根据原始的InsetsSource，以及当前窗口的边框，不忽略InsetsSource的可见度</span><br><span class="line">            //计算内边距保存在typeInsetsMap，将InsetsSource的可见度保存在typeVisibilityMap中</span><br><span class="line">            processSource(source, relativeFrame, false /* ignoreVisibility */, typeInsetsMap,</span><br><span class="line">                                    typeSideMap, typeVisibilityMap);</span><br><span class="line"></span><br><span class="line">            // IME won&#x27;t be reported in max insets as the size depends on the EditorInfo of the IME</span><br><span class="line">            // target.</span><br><span class="line">            if (source.getType() != ITYPE_IME) &#123;</span><br><span class="line">                InsetsSource ignoringVisibilitySource = ignoringVisibilityState != null</span><br><span class="line">                        ? ignoringVisibilityState.getSource(type)</span><br><span class="line">                        : source;</span><br><span class="line">                if (ignoringVisibilitySource == null) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //针对非输入法类型的占位，会忽略其可见性再计算一次内边距保存在typeMaxInsetsMap中</span><br><span class="line">                processSource(ignoringVisibilitySource, relativeFrameMax,</span><br><span class="line">                        true /* ignoreVisibility */, typeMaxInsetsMap, null /* typeSideMap */,</span><br><span class="line">                        null /* typeVisibilityMap */);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        final int softInputAdjustMode = legacySoftInputMode &amp; SOFT_INPUT_MASK_ADJUST;</span><br><span class="line"></span><br><span class="line">        //处理兼容性，默认感知 所有的系统栏和切口区域（刘海屏）的内边距</span><br><span class="line">        @InsetsType int compatInsetsTypes = systemBars() | displayCutout();</span><br><span class="line">        //如果配置的SOFT_INPUT_ADJUST_RESIZE会加上 输入法区域 的内边距</span><br><span class="line">        if (softInputAdjustMode == SOFT_INPUT_ADJUST_RESIZE) &#123;</span><br><span class="line">            compatInsetsTypes |= ime();</span><br><span class="line">        &#125;</span><br><span class="line">        //如果有WindowAttributes的flag设置了全屏flag FLAG_FULLSCREEN，去掉状态栏区域的内边距</span><br><span class="line">        if ((legacyWindowFlags &amp; FLAG_FULLSCREEN) != 0) &#123;</span><br><span class="line">            compatInsetsTypes &amp;= ~statusBars();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //最后将计算的数据封装成一个WindowInsets对象</span><br><span class="line">        return new WindowInsets(typeInsetsMap, typeMaxInsetsMap, typeVisibilityMap, isScreenRound,</span><br><span class="line">                alwaysConsumeSystemBars, cutout, compatInsetsTypes,</span><br><span class="line">                sNewInsetsMode == NEW_INSETS_MODE_FULL</span><br><span class="line">                        &amp;&amp; (legacySystemUiFlags &amp; SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void processSource(InsetsSource source, Rect relativeFrame, boolean ignoreVisibility,</span><br><span class="line">            Insets[] typeInsetsMap, @Nullable @InternalInsetsSide SparseIntArray typeSideMap,</span><br><span class="line">            @Nullable boolean[] typeVisibilityMap) &#123;</span><br><span class="line">        //调用InsetsSource的calculateInsets来计算内边距</span><br><span class="line">        //计算出InsetsSource占位而导致显示区域所产生的内边距</span><br><span class="line">        Insets insets = source.calculateInsets(relativeFrame, ignoreVisibility);</span><br><span class="line"></span><br><span class="line">        //取到InsetsSource所属的大类型，进行处理，保存到对应的数组中</span><br><span class="line">        int type = toPublicType(source.getType());</span><br><span class="line">        processSourceAsPublicType(source, typeInsetsMap, typeSideMap, typeVisibilityMap,</span><br><span class="line">                insets, type);</span><br><span class="line"></span><br><span class="line">        //针对MANDATORY_SYSTEM_GESTURES这种类型的占位还会额外再处理一次</span><br><span class="line">        if (type == MANDATORY_SYSTEM_GESTURES) &#123;</span><br><span class="line">            // Mandatory system gestures are also system gestures.</span><br><span class="line">            // TODO: find a way to express this more generally. One option would be to define</span><br><span class="line">            //       Type.systemGestureInsets() as NORMAL | MANDATORY, but then we lose the</span><br><span class="line">            //       ability to set systemGestureInsets() independently from</span><br><span class="line">            //       mandatorySystemGestureInsets() in the Builder.</span><br><span class="line">            processSourceAsPublicType(source, typeInsetsMap, typeSideMap, typeVisibilityMap,</span><br><span class="line">                    insets, SYSTEM_GESTURES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    private void processSourceAsPublicType(InsetsSource source, Insets[] typeInsetsMap,</span><br><span class="line">            @InternalInsetsSide @Nullable SparseIntArray typeSideMap,</span><br><span class="line">            @Nullable boolean[] typeVisibilityMap, Insets insets, int type) &#123;</span><br><span class="line">        //根据InsetsSource所属大类型，从数组中取值</span><br><span class="line">        int index = indexOf(type);</span><br><span class="line">        Insets existing = typeInsetsMap[index];</span><br><span class="line">        //然后将计算出来的内边距和原来的内边距进行对比，取最大值保存在typeInsetsMap</span><br><span class="line">        if (existing == null) &#123;</span><br><span class="line">            typeInsetsMap[index] = insets;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            typeInsetsMap[index] = Insets.max(existing, insets);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将InsetsSource的可见性保存在typeVisibilityMap</span><br><span class="line">        if (typeVisibilityMap != null) &#123;</span><br><span class="line">            typeVisibilityMap[index] = source.isVisible();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (typeSideMap != null) &#123;</span><br><span class="line">            //如果传入了typeSideMap，也会将insets所在的方向保存在typeSideMap</span><br><span class="line">            @InternalInsetsSide int insetSide = getInsetSide(insets);</span><br><span class="line">            if (insetSide != ISIDE_UNKNOWN) &#123;</span><br><span class="line">                typeSideMap.put(source.getType(), insetSide);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     </span><br></pre></td></tr></table></figure>
<p>InsetsSource.java<br>InsetsSource中的calculateInsets，主要是计算InsetsSource和显示的边框的交叉区域，然后在判断内边距在上下左右哪个方向上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Insets calculateInsets(Rect relativeFrame, boolean ignoreVisibility) &#123;</span><br><span class="line">    return calculateInsets(relativeFrame, mFrame, ignoreVisibility);</span><br><span class="line">&#125;</span><br><span class="line">private Insets calculateInsets(Rect relativeFrame, Rect frame, boolean ignoreVisibility) &#123;</span><br><span class="line">    //不可见直接返回NONE</span><br><span class="line">    if (!ignoreVisibility &amp;&amp; !mVisible) &#123;</span><br><span class="line">        return Insets.NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    // During drag-move and drag-resizing, the caption insets position may not get updated</span><br><span class="line">    // before the app frame get updated. To layout the app content correctly during drag events,</span><br><span class="line">    // we always return the insets with the corresponding height covering the top.</span><br><span class="line">    if (getType() == ITYPE_CAPTION_BAR) &#123;</span><br><span class="line">        return Insets.of(0, frame.height(), 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    //取2个区域的交集保存在mTmpFrame中,后续根据这个相交的区域来计算内边距</span><br><span class="line">    if (!getIntersection(frame, relativeFrame, mTmpFrame)) &#123;</span><br><span class="line">        return Insets.NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // TODO: Currently, non-floating IME always intersects at bottom due to issues with cutout.</span><br><span class="line">    // However, we should let the policy decide from the server.</span><br><span class="line">    if (getType() == ITYPE_IME) &#123;</span><br><span class="line">        //当前占用空间的是输入法，就直接返回相交矩形的高度作为底部内边距</span><br><span class="line">        return Insets.of(0, 0, 0, mTmpFrame.height());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Intersecting at top/bottom</span><br><span class="line">    // 相交区域的宽度 和 内容所在的边框宽度一致，说明水平方向上没有占位产生，处理上下的内边距</span><br><span class="line">    if (mTmpFrame.width() == relativeFrame.width()) &#123;</span><br><span class="line">        if (mTmpFrame.top == relativeFrame.top) &#123;</span><br><span class="line">            return Insets.of(0, mTmpFrame.height(), 0, 0);</span><br><span class="line">        &#125; else if (mTmpFrame.bottom == relativeFrame.bottom) &#123;</span><br><span class="line">            return Insets.of(0, 0, 0, mTmpFrame.height());</span><br><span class="line">        &#125;</span><br><span class="line">        // TODO: remove when insets are shell-customizable.</span><br><span class="line">        // This is a hack that says &quot;if this is a top-inset (eg statusbar), always apply it</span><br><span class="line">        // to the top&quot;. It is used when adjusting primary split for IME.</span><br><span class="line">        if (mTmpFrame.top == 0) &#123;</span><br><span class="line">            return Insets.of(0, mTmpFrame.height(), 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Intersecting at left/right</span><br><span class="line">    // 相交区域的高度 和 内容所在的边框高度一致，说明在上下方向上没有占位产生，处理左右的内边距</span><br><span class="line">    else if (mTmpFrame.height() == relativeFrame.height()) &#123;</span><br><span class="line">        if (mTmpFrame.left == relativeFrame.left) &#123;</span><br><span class="line">            return Insets.of(mTmpFrame.width(), 0, 0, 0);</span><br><span class="line">        &#125; else if (mTmpFrame.right == relativeFrame.right) &#123;</span><br><span class="line">            return Insets.of(0, 0, mTmpFrame.width(), 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Insets.NONE;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="View–dispatchApplyWindowInsets，处理insets-消费内边距"><a href="#View–dispatchApplyWindowInsets，处理insets-消费内边距" class="headerlink" title="View–dispatchApplyWindowInsets，处理insets(消费内边距)"></a>View–dispatchApplyWindowInsets，处理insets(消费内边距)</h3><p>接着看处理Insets的逻辑，Decorview的dispatchApplyWindowInsets<br>DecorView父类是FrameLayout,实现在ViewGroup中<br>ViewGroup.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public WindowInsets dispatchApplyWindowInsets(WindowInsets insets) &#123;</span><br><span class="line">    //调用父类View的dispatchApplyWindowInsets，返回处理完成的WindowInsets</span><br><span class="line">    insets = super.dispatchApplyWindowInsets(insets);</span><br><span class="line">    //WindowInsets被消费了就返回</span><br><span class="line">    if (insets.isConsumed()) &#123;</span><br><span class="line">        return insets;</span><br><span class="line">    &#125;</span><br><span class="line">    if (View.sBrokenInsetsDispatch) &#123;</span><br><span class="line">        return brokenDispatchApplyWindowInsets(insets);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //没有被消费的WindowInsets会分法给子View</span><br><span class="line">        return newDispatchApplyWindowInsets(insets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private WindowInsets newDispatchApplyWindowInsets(WindowInsets insets) &#123;</span><br><span class="line">    final int count = getChildCount();</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        getChildAt(i).dispatchApplyWindowInsets(insets);</span><br><span class="line">    &#125;</span><br><span class="line">    return insets;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>View.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public WindowInsets dispatchApplyWindowInsets(WindowInsets insets) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //添加一个内部私有flag</span><br><span class="line">        mPrivateFlags3 |= PFLAG3_APPLYING_INSETS;</span><br><span class="line">        //如果设置了监听就回调</span><br><span class="line">        if (mListenerInfo != null &amp;&amp; mListenerInfo.mOnApplyWindowInsetsListener != null) &#123;</span><br><span class="line">            return mListenerInfo.mOnApplyWindowInsetsListener.onApplyWindowInsets(this, insets);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //没有设置insets监听就走默认方法，在DecorView中重写过onApplyWindowInsets，去看DecorView的实现</span><br><span class="line">            return onApplyWindowInsets(insets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //最后会清理私有flag</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_APPLYING_INSETS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在DecorView中重写过onApplyWindowInsets，所以DecorView会先特殊处理一次内边距</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public WindowInsets onApplyWindowInsets(WindowInsets insets) &#123;</span><br><span class="line">    final WindowManager.LayoutParams attrs = mWindow.getAttributes();</span><br><span class="line">    //......</span><br><span class="line">    mFrameOffsets.set(insets.getSystemWindowInsetsAsRect());</span><br><span class="line">    //传入获取到的insets，去更新ColorViews</span><br><span class="line">    insets = updateColorViews(insets, true /* animate */);</span><br><span class="line">    insets = updateStatusGuard(insets);</span><br><span class="line">    if (getForeground() != null) &#123;</span><br><span class="line">        drawableChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    return insets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WindowInsets updateColorViews(WindowInsets insets, boolean animate) &#123;</span><br><span class="line">    WindowManager.LayoutParams attrs = mWindow.getAttributes();</span><br><span class="line">    int sysUiVisibility = attrs.systemUiVisibility | getWindowSystemUiVisibility();</span><br><span class="line"></span><br><span class="line">    final WindowInsetsController controller = getWindowInsetsController();</span><br><span class="line"></span><br><span class="line">    // IME is an exceptional floating window that requires color view.</span><br><span class="line">    final boolean isImeWindow =</span><br><span class="line">            mWindow.getAttributes().type == WindowManager.LayoutParams.TYPE_INPUT_METHOD;</span><br><span class="line">    if (!mWindow.mIsFloating || isImeWindow) &#123;</span><br><span class="line">        boolean disallowAnimate = !isLaidOut();</span><br><span class="line">        disallowAnimate |= ((mLastWindowFlags ^ attrs.flags)</span><br><span class="line">                &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0;</span><br><span class="line">        mLastWindowFlags = attrs.flags;</span><br><span class="line"></span><br><span class="line">        if (insets != null) &#123;</span><br><span class="line">            //这里去获取系统栏占位的产生的内边距，忽略其可见度（即获取所有系统栏可见状态下所产生的内边距）</span><br><span class="line">            final Insets stableBarInsets = insets.getInsetsIgnoringVisibility(</span><br><span class="line">                    WindowInsets.Type.systemBars());</span><br><span class="line">            //获取当前显示的状态栏和切口区域产生内边距，和前面获取的对比取最小值</span><br><span class="line">            final Insets systemInsets = Insets.min(</span><br><span class="line">                    insets.getInsets(WindowInsets.Type.systemBars()</span><br><span class="line">                            | WindowInsets.Type.displayCutout()), stableBarInsets);</span><br><span class="line">            //将上下左右的内边距保存到DecorView的全局变量</span><br><span class="line">            mLastTopInset = systemInsets.top;</span><br><span class="line">            mLastBottomInset = systemInsets.bottom;</span><br><span class="line">            mLastRightInset = systemInsets.right;</span><br><span class="line">            mLastLeftInset = systemInsets.left;</span><br><span class="line"></span><br><span class="line">            // Don&#x27;t animate if the presence of stable insets has changed, because that</span><br><span class="line">            // indicates that the window was either just added and received them for the</span><br><span class="line">            // first time, or the window size or position has changed.</span><br><span class="line">            //记录占位窗口在可见状态下时的当前窗口上下左右的内边距是否存在</span><br><span class="line">            boolean hasTopStableInset = stableBarInsets.top != 0;</span><br><span class="line">            disallowAnimate |= (hasTopStableInset != mLastHasTopStableInset);</span><br><span class="line">            mLastHasTopStableInset = hasTopStableInset;</span><br><span class="line"></span><br><span class="line">            boolean hasBottomStableInset = stableBarInsets.bottom != 0;</span><br><span class="line">            disallowAnimate |= (hasBottomStableInset != mLastHasBottomStableInset);</span><br><span class="line">            mLastHasBottomStableInset = hasBottomStableInset;</span><br><span class="line"></span><br><span class="line">            boolean hasRightStableInset = stableBarInsets.right != 0;</span><br><span class="line">            disallowAnimate |= (hasRightStableInset != mLastHasRightStableInset);</span><br><span class="line">            mLastHasRightStableInset = hasRightStableInset;</span><br><span class="line"></span><br><span class="line">            boolean hasLeftStableInset = stableBarInsets.left != 0;</span><br><span class="line">            disallowAnimate |= (hasLeftStableInset != mLastHasLeftStableInset);</span><br><span class="line">            mLastHasLeftStableInset = hasLeftStableInset;</span><br><span class="line"></span><br><span class="line">            mLastShouldAlwaysConsumeSystemBars = insets.shouldAlwaysConsumeSystemBars();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //计算导航栏的位置和大小，并调用 updateColorViewInt 方法更新导航栏</span><br><span class="line">        boolean navBarToRightEdge = isNavBarToRightEdge(mLastBottomInset, mLastRightInset);</span><br><span class="line">        boolean navBarToLeftEdge = isNavBarToLeftEdge(mLastBottomInset, mLastLeftInset);</span><br><span class="line">        int navBarSize = getNavBarSize(mLastBottomInset, mLastRightInset, mLastLeftInset);</span><br><span class="line">        updateColorViewInt(mNavigationColorViewState, sysUiVisibility,</span><br><span class="line">                calculateNavigationBarColor(), mWindow.mNavigationBarDividerColor, navBarSize,</span><br><span class="line">                navBarToRightEdge || navBarToLeftEdge, navBarToLeftEdge,</span><br><span class="line">                0 /* sideInset */, animate &amp;&amp; !disallowAnimate,</span><br><span class="line">                mForceWindowDrawsBarBackgrounds, controller);</span><br><span class="line"></span><br><span class="line">        //处理导航栏背景        </span><br><span class="line">        boolean oldDrawLegacy = mDrawLegacyNavigationBarBackground;</span><br><span class="line">        mDrawLegacyNavigationBarBackground = mNavigationColorViewState.visible</span><br><span class="line">                &amp;&amp; (mWindow.getAttributes().flags &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0;</span><br><span class="line">        if (oldDrawLegacy != mDrawLegacyNavigationBarBackground) &#123;</span><br><span class="line">            ViewRootImpl vri = getViewRootImpl();</span><br><span class="line">            if (vri != null) &#123;</span><br><span class="line">                vri.requestInvalidateRootRenderNode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //计算状态栏是否需要右侧或左侧的内边距，并更新状态栏</span><br><span class="line">        boolean statusBarNeedsRightInset = navBarToRightEdge</span><br><span class="line">                &amp;&amp; mNavigationColorViewState.present;</span><br><span class="line">        boolean statusBarNeedsLeftInset = navBarToLeftEdge</span><br><span class="line">                &amp;&amp; mNavigationColorViewState.present;</span><br><span class="line">        int statusBarSideInset = statusBarNeedsRightInset ? mLastRightInset</span><br><span class="line">                : statusBarNeedsLeftInset ? mLastLeftInset : 0;</span><br><span class="line">        updateColorViewInt(mStatusColorViewState, sysUiVisibility,</span><br><span class="line">                calculateStatusBarColor(), 0, mLastTopInset,</span><br><span class="line">                false /* matchVertical */, statusBarNeedsLeftInset, statusBarSideInset,</span><br><span class="line">                animate &amp;&amp; !disallowAnimate,</span><br><span class="line">                mForceWindowDrawsBarBackgrounds, controller);</span><br><span class="line"></span><br><span class="line">        //处理标题栏</span><br><span class="line">        if (mHasCaption) &#123;</span><br><span class="line">            final int captionColor = calculateStatusBarColor();</span><br><span class="line">            mDecorCaptionView.getCaption().setBackgroundColor(captionColor);</span><br><span class="line">            updateDecorCaptionShade();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // When we expand the window with FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS or</span><br><span class="line">    // mForceWindowDrawsBarBackgrounds, we still need to ensure that the rest of the view</span><br><span class="line">    // hierarchy doesn&#x27;t notice it, unless they&#x27;ve explicitly asked for it.</span><br><span class="line">    //</span><br><span class="line">    // Note: We don&#x27;t need to check for IN_SCREEN or INSET_DECOR because unlike the status bar,</span><br><span class="line">    // these flags wouldn&#x27;t make the window draw behind the navigation bar, unless</span><br><span class="line">    // LAYOUT_HIDE_NAVIGATION was set.</span><br><span class="line">    //</span><br><span class="line">    // Note: Once the app uses the R+ Window.setDecorFitsSystemWindows(false) API we no longer</span><br><span class="line">    // consume insets because they might no longer set SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION.</span><br><span class="line">    //隐藏导航栏的标记 （有SYSTEM_UI_FLAG_HIDE_NAVIGATION这个flag，或者WindowInsetsController没有请求导航栏可见）</span><br><span class="line">    boolean hideNavigation = (sysUiVisibility &amp; SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0</span><br><span class="line">            || !(controller == null || controller.isRequestedVisible(ITYPE_NAVIGATION_BAR));</span><br><span class="line">    //默认DecorView是去适应系统窗口的</span><br><span class="line">    boolean decorFitsSystemWindows = mWindow.mDecorFitsSystemWindows;</span><br><span class="line">    //强制消费导航栏的标记</span><br><span class="line">    boolean forceConsumingNavBar = (mForceWindowDrawsBarBackgrounds</span><br><span class="line">                    &amp;&amp; (attrs.flags &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0</span><br><span class="line">                    &amp;&amp; (sysUiVisibility &amp; SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0</span><br><span class="line">                    &amp;&amp; decorFitsSystemWindows</span><br><span class="line">                    &amp;&amp; !hideNavigation)</span><br><span class="line">            || (mLastShouldAlwaysConsumeSystemBars &amp;&amp; hideNavigation);</span><br><span class="line">    </span><br><span class="line">    //消费导航栏的标记</span><br><span class="line">    boolean consumingNavBar =</span><br><span class="line">            ((attrs.flags &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0</span><br><span class="line">                    &amp;&amp; (sysUiVisibility &amp; SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0</span><br><span class="line">                    &amp;&amp; decorFitsSystemWindows</span><br><span class="line">                    &amp;&amp; !hideNavigation)</span><br><span class="line">            || forceConsumingNavBar;</span><br><span class="line"></span><br><span class="line">    // If we didn&#x27;t request fullscreen layout, but we still got it because of the</span><br><span class="line">    // mForceWindowDrawsBarBackgrounds flag, also consume top inset.</span><br><span class="line">    // If we should always consume system bars, only consume that if the app wanted to go to</span><br><span class="line">    // fullscreen, as othrewise we can expect the app to handle it.</span><br><span class="line">    //全屏标记 （有SYSTEM_UI_FLAG_FULLSCREEN标记 或者 有FLAG_FULLSCREEN标记 或者 WindowInsetsController没有请求状态栏可见）</span><br><span class="line">    boolean fullscreen = (sysUiVisibility &amp; SYSTEM_UI_FLAG_FULLSCREEN) != 0</span><br><span class="line">            || (attrs.flags &amp; FLAG_FULLSCREEN) != 0</span><br><span class="line">            || !(controller == null || controller.isRequestedVisible(ITYPE_STATUS_BAR));</span><br><span class="line">    //消费状态栏的标记</span><br><span class="line">    boolean consumingStatusBar = (sysUiVisibility &amp; SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN) == 0</span><br><span class="line">            &amp;&amp; decorFitsSystemWindows</span><br><span class="line">            &amp;&amp; (attrs.flags &amp; FLAG_LAYOUT_IN_SCREEN) == 0</span><br><span class="line">            &amp;&amp; (attrs.flags &amp; FLAG_LAYOUT_INSET_DECOR) == 0</span><br><span class="line">            &amp;&amp; mForceWindowDrawsBarBackgrounds</span><br><span class="line">            &amp;&amp; mLastTopInset != 0</span><br><span class="line">            || (mLastShouldAlwaysConsumeSystemBars &amp;&amp; fullscreen);</span><br><span class="line"></span><br><span class="line">    //消费状态栏和导航栏就会将之前记录的 上下左右的 内边距保存在临时变量中</span><br><span class="line">    int consumedTop = consumingStatusBar ? mLastTopInset : 0;</span><br><span class="line">    int consumedRight = consumingNavBar ? mLastRightInset : 0;</span><br><span class="line">    int consumedBottom = consumingNavBar ? mLastBottomInset : 0;</span><br><span class="line">    int consumedLeft = consumingNavBar ? mLastLeftInset : 0;</span><br><span class="line"></span><br><span class="line">    if (mContentRoot != null</span><br><span class="line">            &amp;&amp; mContentRoot.getLayoutParams() instanceof MarginLayoutParams) &#123;</span><br><span class="line">        MarginLayoutParams lp = (MarginLayoutParams) mContentRoot.getLayoutParams();</span><br><span class="line">        if (lp.topMargin != consumedTop || lp.rightMargin != consumedRight</span><br><span class="line">                || lp.bottomMargin != consumedBottom || lp.leftMargin != consumedLeft) &#123;</span><br><span class="line">            lp.topMargin = consumedTop;</span><br><span class="line">            lp.rightMargin = consumedRight;</span><br><span class="line">            lp.bottomMargin = consumedBottom;</span><br><span class="line">            lp.leftMargin = consumedLeft;</span><br><span class="line">            //这里将上下左右要消费的内边距赋值给MarginLayoutParams，让DecorView的子View去消费</span><br><span class="line">            mContentRoot.setLayoutParams(lp);</span><br><span class="line"></span><br><span class="line">            if (insets == null) &#123;</span><br><span class="line">                // The insets have changed, but we&#x27;re not currently in the process</span><br><span class="line">                // of dispatching them.</span><br><span class="line">                requestApplyInsets();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (insets != null) &#123;</span><br><span class="line">            //消费了的insets会在原来的insets基础上进行一次缩进，剩下的交给子view的onApplyWindowInsets去处理</span><br><span class="line">            insets = insets.inset(consumedLeft, consumedTop, consumedRight, consumedBottom);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (forceConsumingNavBar) &#123;</span><br><span class="line">        mBackgroundInsets = Insets.of(mLastLeftInset, 0, mLastRightInset, mLastBottomInset);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mBackgroundInsets = Insets.NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    updateBackgroundDrawable();</span><br><span class="line"></span><br><span class="line">    return insets;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>到DecorView处理完WindowInsets返回时，WindowInsets并没有消费完成，<br>会继续走ViewGroup中的newDispatchApplyWindowInsets将剩余的WindowInsets分发给子View，<br>也就是DecorView的mContentRoot，然后继续回调到onApplyWindowInsets，走默认的View中的实现<br>View.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public WindowInsets onApplyWindowInsets(WindowInsets insets) &#123;</span><br><span class="line">        //这里判断了flag来决定后续的处理</span><br><span class="line">        //PFLAG4_FRAMEWORK_OPTIONAL_FITS_SYSTEM_WINDOWS在PhoneWidnow中设置了--mDecor.makeFrameworkOptionalFitsSystemWindows()</span><br><span class="line">        //而FITS_SYSTEM_WINDOWS这个默认是读取View的fitsSystemWindows这个属性值，目前DecorView的mContentRoot在xml中默认是fitsSystemWindows</span><br><span class="line">        //所以一定会走onApplyFrameworkOptionalFitSystemWindows</span><br><span class="line">        if ((mPrivateFlags4 &amp; PFLAG4_FRAMEWORK_OPTIONAL_FITS_SYSTEM_WINDOWS) != 0</span><br><span class="line">                &amp;&amp; (mViewFlags &amp; FITS_SYSTEM_WINDOWS) != 0) &#123;</span><br><span class="line">            return onApplyFrameworkOptionalFitSystemWindows(insets);</span><br><span class="line">        &#125;</span><br><span class="line">        if ((mPrivateFlags3 &amp; PFLAG3_FITTING_SYSTEM_WINDOWS) == 0) &#123;</span><br><span class="line">            // We weren&#x27;t called from within a direct call to fitSystemWindows,</span><br><span class="line">            // call into it as a fallback in case we&#x27;re in a class that overrides it</span><br><span class="line">            // and has logic to perform.</span><br><span class="line">            if (fitSystemWindows(insets.getSystemWindowInsetsAsRect())) &#123;</span><br><span class="line">                return insets.consumeSystemWindowInsets();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // We were called from within a direct call to fitSystemWindows.</span><br><span class="line">            if (fitSystemWindowsInt(insets.getSystemWindowInsetsAsRect())) &#123;</span><br><span class="line">                return insets.consumeSystemWindowInsets();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return insets;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    private WindowInsets onApplyFrameworkOptionalFitSystemWindows(WindowInsets insets) &#123;</span><br><span class="line">        Rect localInsets = sThreadLocal.get();</span><br><span class="line">        //去计算要消费的insets保存到localInsets中，然后返回消费完剩余的WindowInsets</span><br><span class="line">        WindowInsets result = computeSystemWindowInsets(insets, localInsets);</span><br><span class="line">        //这里就是将要消费的insets设置为padding</span><br><span class="line">        applyInsets(localInsets);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public WindowInsets computeSystemWindowInsets(WindowInsets in, Rect outLocalInsets) &#123;</span><br><span class="line">        boolean isOptionalFitSystemWindows = (mViewFlags &amp; OPTIONAL_FITS_SYSTEM_WINDOWS) != 0</span><br><span class="line">                || (mPrivateFlags4 &amp; PFLAG4_FRAMEWORK_OPTIONAL_FITS_SYSTEM_WINDOWS) != 0;</span><br><span class="line">        if (isOptionalFitSystemWindows &amp;&amp; mAttachInfo != null) &#123;</span><br><span class="line">            OnContentApplyWindowInsetsListener listener =</span><br><span class="line">                    mAttachInfo.mContentOnApplyWindowInsetsListener;</span><br><span class="line">            if (listener == null) &#123;</span><br><span class="line">                // The application wants to take care of fitting system window for</span><br><span class="line">                // the content.</span><br><span class="line">                outLocalInsets.setEmpty();</span><br><span class="line">                return in;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里就是去调用在onAttachedToWindow时设置的默认的WindowInsets处理</span><br><span class="line">            Pair&lt;Insets, WindowInsets&gt; result = listener.onContentApplyWindowInsets(this, in);</span><br><span class="line">            outLocalInsets.set(result.first.toRect());</span><br><span class="line">            return result.second;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            outLocalInsets.set(in.getSystemWindowInsetsAsRect());</span><br><span class="line">            return in.consumeSystemWindowInsets().inset(outLocalInsets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    private void applyInsets(Rect insets) &#123;</span><br><span class="line">        mUserPaddingStart = UNDEFINED_PADDING;</span><br><span class="line">        mUserPaddingEnd = UNDEFINED_PADDING;</span><br><span class="line">        mUserPaddingLeftInitial = insets.left;</span><br><span class="line">        mUserPaddingRightInitial = insets.right;</span><br><span class="line">        internalSetPadding(insets.left, insets.top, insets.right, insets.bottom);</span><br><span class="line">    &#125;        </span><br></pre></td></tr></table></figure>
<p>默认的insets计算逻辑在onAttachedToWindow时进行了设置，默认的逻辑在PhoneWindow中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final OnContentApplyWindowInsetsListener sDefaultContentInsetsApplier =</span><br><span class="line">        (view, insets) -&gt; &#123;</span><br><span class="line">            //这里的View其时是DecorView下的子View,即DecorView的mContentRoot</span><br><span class="line">            //判断的是如果有SYSTEM_UI_FLAG_LAYOUT_xxx相关的Flag，根布局不消费内边距，继续传递给子视图</span><br><span class="line">            if ((view.getWindowSystemUiVisibility() &amp; SYSTEM_UI_LAYOUT_FLAGS) != 0) &#123;</span><br><span class="line">                return new Pair&lt;&gt;(Insets.NONE, insets);</span><br><span class="line">            &#125;</span><br><span class="line">            //否则就会根据mCompatInsetsTypes去获取系统窗口所占用的位置，mCompatInsetsTypes和flag有关</span><br><span class="line">            Insets insetsToApply = insets.getSystemWindowInsets();</span><br><span class="line">            //最后返回2个对象</span><br><span class="line">            //第一个insetsToApply是需要DecorView下的子View处理的内边距</span><br><span class="line">            //第二个是 原来的insets移除insetsToApply这一部分也标记为消费</span><br><span class="line">            return new Pair&lt;&gt;(insetsToApply,</span><br><span class="line">                    insets.inset(insetsToApply).consumeSystemWindowInsets());</span><br><span class="line">        &#125;; </span><br></pre></td></tr></table></figure>

<p>所以针对WindowInsets，首先会在DecorView中的updateColorViews中计算消费一次，<br>再把剩下未消费的分发给DecorView的子View mContentRoot 去计算消费一次，<br>需要理清在updateColorViews消费的逻辑和在mContentRoot中消费的逻辑</p>
<h3 id="在DecorView的updateColorViews中对WindowInsets的消费"><a href="#在DecorView的updateColorViews中对WindowInsets的消费" class="headerlink" title="在DecorView的updateColorViews中对WindowInsets的消费"></a>在DecorView的updateColorViews中对WindowInsets的消费</h3><p>在updataColorViews中主要判断的consumingStatusBar和consumingNavBar<br>这里主要来看这2段逻辑，在这里有一些是默认配置的，一般值是固定的<br>如：</p>
<ul>
<li>mForceWindowDrawsBarBackgrounds 读取的config_forceWindowDrawsStatusBarBackground的值，默认为true</li>
<li>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 在PhoneWindow中设置的，一般为true，读的windowDrawsSystemBarBackgrounds属性</li>
<li>mDecorFitsSystemWindows 默认为true</li>
<li>mLastShouldAlwaysConsumeSystemBars 在Android11中为true，在WMS中addWindow时加了ADD_FLAG_USE_TRIPLE_BUFFERING，和ADD_FLAG_ALWAYS_CONSUME_SYSTEM_BARS值一样导致在ViewRootImpl中mAlwaysConsumeSystemBars初始化为true</li>
<li>FLAG_LAYOUT_IN_SCREEN 在PhoneWindow中设置的，windowIsFloating为flase的情况下会设置</li>
<li>FLAG_LAYOUT_INSET_DECOR 在PhoneWindow中设置的，windowIsFloating为flase的情况下会设置<br>这里Decorview消费Insets是对mContentRoot设置margin。<br>根据逻辑来看，<br>DecorView是否消费导航栏主要和APP行为有关，app没有主动隐藏导航栏并且没有指定从最底部开始布局，就会给mContentRoot设置margin<br>一旦app请求了隐藏导航栏，或者指定了从最底部开始布局，就不会处理insets，交给mContentRoot去处理设置padding</li>
</ul>
<p>DecorView一般不消费状态栏</p>
<p>所以一般正常情况下，Decorview会去消费导航栏，但不消费状态栏，即给mContentRoot底部设置margin，顶部交给mContentRoot去处理padding</p>
<p>Decorview会消费导航栏，除非app指定隐藏导航栏，此时就会丢给mContentRoot去处理设置padding<br>Decorview一般不会消费状态栏，app请求隐藏状态栏时，Decorview也不消费，分发给mContentRoot去处理设置padding</p>
<p>代码的逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WindowInsets updateColorViews(WindowInsets insets, boolean animate) &#123;</span><br><span class="line">    //......</span><br><span class="line">    //设置了SYSTEM_UI_FLAG_HIDE_NAVIGATION flag 或者WindowInsetsController主动请求隐藏导航栏</span><br><span class="line">    boolean hideNavigation = (sysUiVisibility &amp; SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0</span><br><span class="line">            || !(controller == null || controller.isRequestedVisible(ITYPE_NAVIGATION_BAR));</span><br><span class="line">    //decorFitsSystemWindows默认为true</span><br><span class="line">    boolean decorFitsSystemWindows = mWindow.mDecorFitsSystemWindows;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    //由于 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 默认一般是true</span><br><span class="line">    //要满足没有FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 并且 app正常非全屏（没有指定根布局从最底部开始，没有主动请求隐藏导航栏） 在第一个条件就false了</span><br><span class="line">    // 另一种情况是 主动请求隐藏导航栏 但是 WindowInsets中指定了要始终消费系统栏 （这种场景很难想像，app主动隐藏状态栏就是想全屏，Decorview此时强制消费留白界面会很奇怪）</span><br><span class="line">    //所以一般情况下DecorView不会强制消费导航栏（不会强制给mContentRoot设置margin）</span><br><span class="line">    boolean forceConsumingNavBar = (mForceWindowDrawsBarBackgrounds</span><br><span class="line">                    &amp;&amp; (attrs.flags &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0</span><br><span class="line">                    &amp;&amp; (sysUiVisibility &amp; SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0</span><br><span class="line">                    &amp;&amp; decorFitsSystemWindows</span><br><span class="line">                    &amp;&amp; !hideNavigation)</span><br><span class="line">            || (mLastShouldAlwaysConsumeSystemBars &amp;&amp; hideNavigation);</span><br><span class="line"></span><br><span class="line">    //消费导航栏的情况</span><br><span class="line">    //1. 强制消费导航栏 （一般不满足）</span><br><span class="line">    //2. 没有主动隐藏导航栏 并且 没有指定根布局从最底部开始</span><br><span class="line">    boolean consumingNavBar =</span><br><span class="line">            ((attrs.flags &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0</span><br><span class="line">                    &amp;&amp; (sysUiVisibility &amp; SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0</span><br><span class="line">                    &amp;&amp; decorFitsSystemWindows</span><br><span class="line">                    &amp;&amp; !hideNavigation)</span><br><span class="line">            || forceConsumingNavBar;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //app请求全屏</span><br><span class="line">    boolean fullscreen = (sysUiVisibility &amp; SYSTEM_UI_FLAG_FULLSCREEN) != 0</span><br><span class="line">            || (attrs.flags &amp; FLAG_FULLSCREEN) != 0</span><br><span class="line">            || !(controller == null || controller.isRequestedVisible(ITYPE_STATUS_BAR));</span><br><span class="line">    //消费状态栏的情况</span><br><span class="line">    //1.没有请求从顶部开始布局，并且还有没有FLAG_LAYOUT_IN_SCREEN，FLAG_LAYOUT_INSET_DECOR，flag条件一般不满足，针对floatingwindow会消费状态栏</span><br><span class="line">    //2.mLastShouldAlwaysConsumeSystemBars并且app请求了全屏，mLastShouldAlwaysConsumeSystemBars一般不满足</span><br><span class="line">    boolean consumingStatusBar = (sysUiVisibility &amp; SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN) == 0</span><br><span class="line">            &amp;&amp; decorFitsSystemWindows</span><br><span class="line">            &amp;&amp; (attrs.flags &amp; FLAG_LAYOUT_IN_SCREEN) == 0</span><br><span class="line">            &amp;&amp; (attrs.flags &amp; FLAG_LAYOUT_INSET_DECOR) == 0</span><br><span class="line">            &amp;&amp; mForceWindowDrawsBarBackgrounds</span><br><span class="line">            &amp;&amp; mLastTopInset != 0</span><br><span class="line">            || (mLastShouldAlwaysConsumeSystemBars &amp;&amp; fullscreen);                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在DecorView的mContentRoot中消费WindowInsets的逻辑"><a href="#在DecorView的mContentRoot中消费WindowInsets的逻辑" class="headerlink" title="在DecorView的mContentRoot中消费WindowInsets的逻辑"></a>在DecorView的mContentRoot中消费WindowInsets的逻辑</h3><p>由于在DecorView中基本上不会处理状态栏产生的Insets,所以状态栏相关的Insets基本上都在mContentRoot中处理的，<br>只要app加了SYSTEM_UI_FLAG_LAYOUT_xxx相关的Flag，mContentRoot就不会处理Insets，会继续传递给子View，<br>触发子View的onApplyWindowInsets继续走OnContentApplyWindowInsetsListener的onContentApplyWindowInsets。<br>只要有SYSTEM_UI_FLAG_LAYOUT_xxx相关的Flag，默认的处理逻辑是所有分发到的View都不处理。<br>没有的话，父容器一旦处理了，后续就不会继续分发了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final OnContentApplyWindowInsetsListener sDefaultContentInsetsApplier =</span><br><span class="line">        (view, insets) -&gt; &#123;</span><br><span class="line">            //这里的View其时是DecorView下的子View,即DecorView的mContentRoot</span><br><span class="line">            //判断的是如果有SYSTEM_UI_FLAG_LAYOUT_xxx相关的Flag，根布局不消费内边距，继续传递给子视图</span><br><span class="line">            if ((view.getWindowSystemUiVisibility() &amp; SYSTEM_UI_LAYOUT_FLAGS) != 0) &#123;</span><br><span class="line">                return new Pair&lt;&gt;(Insets.NONE, insets);</span><br><span class="line">            &#125;</span><br><span class="line">            //否则就会根据mCompatInsetsTypes去获取系统窗口所占用的位置，mCompatInsetsTypes和flag有关</span><br><span class="line">            Insets insetsToApply = insets.getSystemWindowInsets();</span><br><span class="line">            //最后返回2个对象</span><br><span class="line">            //第一个insetsToApply是需要DecorView下的子View处理的内边距</span><br><span class="line">            //第二个是 原来的insets移除insetsToApply这一部分也标记为消费</span><br><span class="line">            return new Pair&lt;&gt;(insetsToApply,</span><br><span class="line">                    insets.inset(insetsToApply).consumeSystemWindowInsets());</span><br><span class="line">        &#125;; </span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>问题记录</title>
    <url>//pages/4211e5/</url>
    <content><![CDATA[<h2 id="单编Selinux，push后无法Android启动"><a href="#单编Selinux，push后无法Android启动" class="headerlink" title="单编Selinux，push后无法Android启动"></a>单编Selinux，push后无法Android启动</h2><ol>
<li>push进去的文件路径不对，可以先对比一下push进去的是整个selinux文件夹还是selinux文件夹下的子文件</li>
<li><strong>本地的lunch的build type和编译的build type不一致, 需要都是userdebug的</strong></li>
</ol>
<h2 id="Binder-getCallingPid为0"><a href="#Binder-getCallingPid为0" class="headerlink" title="Binder.getCallingPid为0"></a>Binder.getCallingPid为0</h2><p>获取调用者的pid时，一直是0，这是因为在client端是异步调用的，在aidl中去掉client端使用的接口的oneway关键字即可。<br>如果想避免Binder调用耗时阻塞线程，可以在回调的接口上加上oneway关键字</p>
<p>如2个AIDL文件：</p>
<p>ITestService.aidl   客户端调用的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.test.localtest;</span><br><span class="line"></span><br><span class="line">import com.test.localtest.IInfoCallback;</span><br><span class="line"></span><br><span class="line">interface ITestService &#123;</span><br><span class="line">    void setInfoListener(IInfoCallback callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IInfoCallback.aidl  回调给客户端的接口，加上oneway关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.test.localtest;</span><br><span class="line"></span><br><span class="line">oneway interface IInfoCallback &#123;</span><br><span class="line">    void onMsg(String msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AOSP下AIDL编译报错couldn’t-find-import-for-class"><a href="#AOSP下AIDL编译报错couldn’t-find-import-for-class" class="headerlink" title="AOSP下AIDL编译报错couldn’t find import for class"></a>AOSP下AIDL编译报错couldn’t find import for class</h2><p>代码如下</p>
<p><strong>IVolumeDataCallback.aidl</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.test.volumecollect;</span><br><span class="line"></span><br><span class="line">interface IVolumeDataCallback &#123;</span><br><span class="line">    void onDataCallback(String data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IVolumeDataInteraction</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.test.volumecollect;</span><br><span class="line"></span><br><span class="line">import com.test.volumecollect.IVolumeDataCallback;</span><br><span class="line"></span><br><span class="line">oneway interface IVolumeDataInteraction &#123;</span><br><span class="line">    void queryData(IVolumeDataCallback callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在IVolumeDataInteraction中是通过import引入了com.test.volumecollect.IVolumeDataCallback这个类</p>
<p>但还是报couldn’t find import for class com.test.volumecollect.IVolumeDataCallback</p>
<p>顾名思义，就是找不到com.test.volumecollect.IVolumeDataCallback，</p>
<p>后面排查后发现，由于是将aidl文件单独封装成文件组，在Android.bp文件中，filegroup标签需要指定一下path，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filegroup &#123;</span><br><span class="line">    name: &quot;volume-collect-aidl&quot;,</span><br><span class="line">    srcs: [&quot;aidl/**/*.aidl&quot;],</span><br><span class="line">    path: &quot;aidl&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，编译的时候，就会以aidl目录为起始目录，去aidl目录下去找对应的文件，这样才能找到com.test.volumecollect这个包路径</p>
<h2 id="多个动态jar包加载同一个so引起崩溃"><a href="#多个动态jar包加载同一个so引起崩溃" class="headerlink" title="多个动态jar包加载同一个so引起崩溃"></a>多个动态jar包加载同一个so引起崩溃</h2><p>同一个.so不能加载到不同的类中，所以抛出了异常，导致崩溃。<br>解决方法，将任意一个jar包静态引用，静态引用的jar包打包在APK中，2个jar包使用的是同一个class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    --------- beginning of crash</span><br><span class="line">2023-01-18 16:49:59.636 7083-7083/com.omosoft.hudinterface E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.omosoft.hudinterface, PID: 7083</span><br><span class="line">    java.lang.UnsatisfiedLinkError: Shared library &quot;/system/lib64/libjni_tiscservice.so&quot; already opened by ClassLoader 0x293(dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/system/framework/com.chinatsp.iscmanager.jar&quot;],nativeLibraryDirectories=[/data/app/~~Mm3DrXA3I_5atpde1Ky6KA==/com.omosoft.hudinterface-cdAVK1ZxEUxpzOvehmvbyg==/lib/arm64, /system/lib64, /system_ext/lib64]]]); can&#x27;t open in ClassLoader 0x7fff98d5ac(dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/system/framework/com.omosoft.hudmanager.jar&quot;],nativeLibraryDirectories=[/data/app/~~Mm3DrXA3I_5atpde1Ky6KA==/com.omosoft.hudinterface-cdAVK1ZxEUxpzOvehmvbyg==/lib/arm64, /system/lib64, /system_ext/lib64]]])</span><br><span class="line">        at java.lang.Runtime.loadLibrary0(Runtime.java:1087)</span><br><span class="line">        at java.lang.Runtime.loadLibrary0(Runtime.java:1008)</span><br><span class="line">        at java.lang.System.loadLibrary(System.java:1664)</span><br><span class="line">        at com.chinatsp.iscmanager.ISCManager.&lt;clinit&gt;(ISCManager.java:62)</span><br><span class="line">        at com.omosoft.hudmanager.HUDMsgDispatcher.&lt;init&gt;(HUDMsgDispatcher.java:26)</span><br><span class="line">        at com.omosoft.hudmanager.HUDMsgDispatcher.getInstance(HUDMsgDispatcher.java:35)</span><br><span class="line">        at com.omosoft.hudmanager.HUDManager.sendMsg(HUDManager.java:22)</span><br><span class="line">        at com.omosoft.hudmanager.HUDManager.setHUDMode(HUDManager.java:114)</span><br><span class="line">        at com.omosoft.hudinterface.MainActivity.onCreate(MainActivity.java:28)</span><br><span class="line">        at android.app.Activity.performCreate(Activity.java:7994)</span><br><span class="line">        at android.app.Activity.performCreate(Activity.java:7978)</span><br><span class="line">        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1309)</span><br><span class="line">        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3404)</span><br><span class="line">        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3595)</span><br><span class="line">        at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:85)</span><br><span class="line">        at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)</span><br><span class="line">        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2066)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:223)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:7664)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:592)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:947)</span><br><span class="line">2023-01-18 16:49:59.757 7083-7083/com.omosoft.hudinterface I/Process: Sending signal. PID: 7083 SIG: 9</span><br></pre></td></tr></table></figure>

<h2 id="注册native方法失败，so加载失败"><a href="#注册native方法失败，so加载失败" class="headerlink" title="注册native方法失败，so加载失败"></a>注册native方法失败，so加载失败</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2023-01-18 02:02:54.831 E/ft.hudinterfac: ----- class &#x27;Lcom/chinatsp/iscmanager/ISCManager;&#x27; cl=0x1334aca8 -----</span><br><span class="line">      objectSize=248 (224 from super)</span><br><span class="line">      access=0x8008.0001</span><br><span class="line">      super=&#x27;java.lang.Class&lt;java.lang.Object&gt;&#x27; (cl=0x0)</span><br><span class="line">      vtable (4 entries, 11 in super):</span><br><span class="line">         0: void com.chinatsp.iscmanager.ISCManager.finalize()</span><br><span class="line">         1: int com.chinatsp.iscmanager.ISCManager.openChannel(int)</span><br><span class="line">         2: void com.chinatsp.iscmanager.ISCManager.registerCallback(com.chinatsp.iscmanager.IRecvMsgListener)</span><br><span class="line">         3: int com.chinatsp.iscmanager.ISCManager.sendMessage(int, byte[], int)</span><br><span class="line">      direct methods (9 entries):</span><br><span class="line">         0: void com.chinatsp.iscmanager.ISCManager.&lt;clinit&gt;()</span><br><span class="line">         1: void com.chinatsp.iscmanager.ISCManager.&lt;init&gt;()</span><br><span class="line">         2: void com.chinatsp.iscmanager.ISCManager.HandleReceMsg()</span><br><span class="line">         3: void com.chinatsp.iscmanager.ISCManager.nativeClassInit()</span><br><span class="line">         4: void com.chinatsp.iscmanager.ISCManager.nativeInit()</span><br><span class="line">         5: int com.chinatsp.iscmanager.ISCManager.nativeOpenChannel(int)</span><br><span class="line">         6: void com.chinatsp.iscmanager.ISCManager.nativeRegisterCallback()</span><br><span class="line">         7: void com.chinatsp.iscmanager.ISCManager.nativeRelease()</span><br><span class="line">         8: int com.chinatsp.iscmanager.ISCManager.nativeSendMessage(int, byte[], int)</span><br><span class="line">      instance fields (3 entries):</span><br><span class="line">         0: java.util.concurrent.Semaphore com.chinatsp.iscmanager.ISCManager.mMsgSign</span><br><span class="line">         1: com.chinatsp.iscmanager.IRecvMsgListener com.chinatsp.iscmanager.ISCManager.mRecvListener</span><br><span class="line">         2: java.util.List com.chinatsp.iscmanager.ISCManager.m_messageList</span><br><span class="line">2023-01-18 02:02:54.831 E/ft.hudinterfac: Failed to register native method com.chinatsp.iscmanager.ISCManager.nativeCloseChannel(I)I in /system/app/HUDManagerTest/HUDManagerTest.apk</span><br><span class="line">2023-01-18 02:02:55.057 A/ft.hudinterfac: runtime.cc:655] Runtime aborting...</span><br></pre></td></tr></table></figure>

<p>从log看就是在jni注册方法时，找不到对应方法，但这个类种是有这个方法，并且方法名、参数、返回值都是匹配的。<br>后面反编译对应的apk发现，反编译出来的apk中的class确实没有对应的方法。<br>因为Android.bp进行编译时，APP默认是会优化代码，没有调用的方法都会被移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optimize.enabled bool, If false, disable all optimization. Defaults to true for android_app and android_test modules, false for java_library and java_test modules.</span><br></pre></td></tr></table></figure>

<p>解决方法，在jar包中显示调用未使用的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void avoidOptimize() &#123;</span><br><span class="line">    if (mISCManager == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //显示调用一些unused的方法，避免三方APP编译时优化移除字段和方法，导致jni注册失败</span><br><span class="line">    try &#123;</span><br><span class="line">        //避免三方app编译优化时，移除mNativeContext，导致jni初始化失败</span><br><span class="line">        Field mNativeContextField = ISCManager.class.getDeclaredField(&quot;mNativeContext&quot;);</span><br><span class="line">        mNativeContextField.setAccessible(true);</span><br><span class="line">        Object nativeContext = mNativeContextField.get(mISCManager);</span><br><span class="line">        Log.d(TAG, &quot;nativeContext: &quot; + nativeContext);</span><br><span class="line">    &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    mISCManager.unregisterCallback();</span><br><span class="line">    mISCManager.transmitMsgFromNative(0, null, false);</span><br><span class="line">    mISCManager.closeChannel(CHANNEL_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者APP端禁止代码优化（三方APP无法保证）</p>
<p>另外还可以使用动态jar，避免编译优化代码</p>
<h2 id="Android-Studio-混淆后，类中的私有方法变成了public"><a href="#Android-Studio-混淆后，类中的私有方法变成了public" class="headerlink" title="Android Studio 混淆后，类中的私有方法变成了public"></a>Android Studio 混淆后，类中的私有方法变成了public</h2><p>AS混淆的配置中有一项proguardFiles getDefaultProguardFile(‘proguard-android-optimize.txt’), ‘proguard-rules.pro’，在这里我们会使用android sdk中默认proguard-android-optimize.txt文件。我们可以在Sdk&#x2F;tools&#x2F;proguard路径下找到这个文件。<br>打开该文件可以发现，其中有一项配置“-allowaccessmodification“，这项配置的作用是“是否允许改变作用域“。这也是问题的原因。</p>
<p>方法一：我们可以将proguard-android-optimize.txt文件替换为proguard-android.txt文件，因为在proguard-android.txt中没有-allowaccessmodification配置。</p>
<p>方法二：我们可以去掉getDefaultProguardFile(‘proguard-android-optimize.txt’)，只使用后面自定义的proguard-rules.pro文件。同时，需要在proguard-rules.pro文件中添加自己需要的配置。</p>
<h2 id="记录一次屏保无法退出的现象"><a href="#记录一次屏保无法退出的现象" class="headerlink" title="记录一次屏保无法退出的现象"></a>记录一次屏保无法退出的现象</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>进入屏保页后，点击屏保无响应，无法退出，无法回到桌面，通过adb直接下发指令启动Activity也无法成功（stack 不在栈顶，在栈顶下面一层）</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>后面发现DreamActivity的ActivityType是ACTIVITY_TYPE_DREAM，普通APP的ActivityType是ACTIVITY_TYPE_STANDARD，<br>由于要启动的Activity的栈和顶层栈的类型不同，所以无法打开。</p>
<p>但是DreamService中实现了Window.Callback，并将DreamActivity的Window.Callback设置成了DreamService，<br>而DreamService实现的Window.Callback,对dispatchTouchEvent做了处理，会去调用wakeUp()退出屏保，所以正常情况下，触摸屏幕就会退出屏保。</p>
<p>最后发现有其他进程在打开屏保时，刚好去唤醒屏幕，将DreamService中的mFinished标志置为了true，<br>后续屏保页成功显示后，由于mFinished已经置为true，执行解锁时无法进入解锁逻辑。屏保一直无法退出。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>DreamService中添加字段mActivityCreated记录屏保页是否成功启动，未启动前不执行解锁操作</p>
<p>具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//flag add by LiFeifei to check DreamActivity is created</span><br><span class="line">private boolean mActivityCreated = false;</span><br><span class="line"></span><br><span class="line">public final void finish() &#123;</span><br><span class="line">    if (mDebug) Slog.v(TAG, &quot;finish(): mFinished=&quot; + mFinished);</span><br><span class="line"></span><br><span class="line">    // add by LiFeifei START (if DreamActivity haven&#x27;t created,ignore finish)</span><br><span class="line">    Slog.d(TAG,&quot;finish activity=&quot; + mActivity);</span><br><span class="line">    if (!mActivityCreated) &#123;</span><br><span class="line">        Slog.d(TAG,&quot;activity not created yet, abort finish.&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // add by Lifeifei END</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /** @hide */</span><br><span class="line">    void onActivityCreated(DreamActivity a) &#123;</span><br><span class="line">        mActivity = a;</span><br><span class="line">        onWindowCreated(a.getWindow());</span><br><span class="line"></span><br><span class="line">        //add by Lifeifei START, mark DreamActivity create success</span><br><span class="line">        Slog.d(TAG,&quot;onActivityCreated&quot;);</span><br><span class="line">        mActivityCreated = true;</span><br><span class="line">        //add by Lifeifei END</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="FileObserver"><a href="#FileObserver" class="headerlink" title="FileObserver"></a>FileObserver</h2><p>问题现象：<br>使用FileObserver观察系统中DCIM目录下的一个文件夹中的文件，调用FileObserver.startWatching进行观察后，在目标文件夹中文件被增删后没有回调事件，是个偶现问题，测试在重启车机后恢复，但是升级后首次开机FileObserver没有回调</p>
<p>原因：<br>刷机后观察的目录不存在了，但是相册使用FileObserver前没有判断文件夹是否存在.导致出现了文件更新不回调的问题</p>
<h2 id="Ubuntu下adb报权限问题"><a href="#Ubuntu下adb报权限问题" class="headerlink" title="Ubuntu下adb报权限问题"></a>Ubuntu下adb报权限问题</h2><p>adb devices<br>no permissions (missing udev rules? user is in the plugdev group); see [<a href="http://developer.android.com/tools/device.html]">http://developer.android.com/tools/device.html]</a></p>
<p>意思是用户在plugdev用户组，但没有设备权限，需要针对这个usb设备配置一下<br>1.查看usb设备的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure>
<p>Bus 001 Device 008: ID 05c6:901d Qualcomm, Inc. SA8155 V2- _SN:<br>其中ID后面是dVendor和idProduct，分别代表厂商号和产品号<br>2.在目录&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;下添加文件70-android.rules，并在文件中添加如下内容：</p>
<p>SUBSYSTEM&#x3D;&#x3D;”usb”, ATTRS{idVendor}&#x3D;&#x3D;”05c6”, ATTRS{idProduct}&#x3D;&#x3D;”901d”,MODE&#x3D;”0666”</p>
<h2 id="记录一下u0-u10进程"><a href="#记录一下u0-u10进程" class="headerlink" title="记录一下u0 u10进程"></a>记录一下u0 u10进程</h2><p>persist 属性 的APP 会被systemserver 拉起来，但是uid是0。</p>
<p>启动u10下的进程，</p>
<ol>
<li>APP可以在u0进程中去指定以u10启动service</li>
<li>APP自己处理，监听开机广播，启动u10下APP进程的service</li>
<li>也可以等其他u10下的进程来启动它的service，这样也可以拉起来</li>
</ol>
<p>只想在u10下自启，需要监听开机广播，收到广播后启动service; 或者等其它u10进程来启动它的service</p>
<h2 id="APP的uid发生变化"><a href="#APP的uid发生变化" class="headerlink" title="APP的uid发生变化"></a>APP的uid发生变化</h2><p>现象：app无法访问sd卡下私有目录的文件</p>
<p>直接原因是，app的uid和对应sd卡私有目录下的文件用户不一致，app的uid发生了变化</p>
<p>移除了原预置APP，重新手动安装，导致APP 的UID发生了变化,</p>
<p>关键log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System package xxx no longer exists; it&#x27;s data will be wiped</span><br></pre></td></tr></table></figure>

<p>移除system app后重启，开机时PMS会去清除无效的package，删除原来的私有目录，但sd卡还未挂载成功，没有清除。<br>重新手动安装会生成新的uid，<br>但如果覆盖安装就不会。</p>
<h2 id="记录一次Binder通信异常"><a href="#记录一次Binder通信异常" class="headerlink" title="记录一次Binder通信异常"></a>记录一次Binder通信异常</h2><p>log中看到System Server向APP发送广播失败了，然后将APP强杀了.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">03-25 14:20:30.976 23014 23044 E JavaBinder: !!! FAILED BINDER TRANSACTION !!!  (parcel size = 612)</span><br><span class="line">03-25 14:20:30.977 23014 23044 W BroadcastQueue: Can&#x27;t deliver broadcast to com.tinnove.aiassistant (pid 27204). Crashing it.</span><br><span class="line">03-25 14:20:30.977 23014 23044 E JavaBinder: !!! FAILED BINDER TRANSACTION !!!  (parcel size = 132)</span><br><span class="line">03-25 14:20:30.977 26121 26134 D VehicleNetworkService.Utils: isNetworkAvailable result:true</span><br><span class="line">03-25 14:20:30.977 23014 23044 I ActivityManagerService: Killing 27204:com.tinnove.aiassistant/u10s1000 (adj 100): scheduleCrash for &#x27;can&#x27;t deliver broadcast&#x27; failed</span><br><span class="line">03-25 14:20:30.977 23014 23044 I ProcessList: note: ProcessRecord&#123;3c83f48 27204:com.tinnove.aiassistant/u10s1000&#125; is being killed, reason: 4, sub-reason: 0, message: scheduleCrash for &#x27;can&#x27;t deliver broadcast&#x27; failed</span><br><span class="line">03-25 14:20:30.978 23014 23044 I am_kill : [10,27204,com.tinnove.aiassistant,100,scheduleCrash for &#x27;can&#x27;t deliver broadcast&#x27; failed]</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: Failure sending broadcast Intent &#123; act=android.net.conn.CONNECTIVITY_CHANGE flg=0x4200010 (has extras) &#125;</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: android.os.DeadObjectException: Transaction failed on small parcel; remote process probably died</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at android.os.BinderProxy.transactNative(Native Method)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at android.os.BinderProxy.transact(BinderProxy.java:550)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at android.app.IApplicationThread$Stub$Proxy.scheduleRegisteredReceiver(IApplicationThread.java:1723)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at com.android.server.am.BroadcastQueue.performReceiveLocked(BroadcastQueue.java:580)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at com.android.server.am.BroadcastQueue.deliverToRegisteredReceiverLocked(BroadcastQueue.java:810)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at com.android.server.am.BroadcastQueue.processNextBroadcastLocked(BroadcastQueue.java:991)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at com.android.server.am.BroadcastQueue.processNextBroadcast(BroadcastQueue.java:950)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at com.android.server.am.BroadcastQueue$BroadcastHandler.handleMessage(BroadcastQueue.java:190)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at android.os.Looper.loop(Looper.java:223)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at android.os.HandlerThread.run(HandlerThread.java:67)</span><br><span class="line">03-25 14:20:30.979 23014 23044 W BroadcastQueue: 	at com.android.server.ServiceThread.run(ServiceThread.java:44)</span><br></pre></td></tr></table></figure>

<p>从log来看就是Binder通信失败了，导致广播无法分发到指定的APP，AMS将APP直接kill掉了。</p>
<p>搜索关键字<code>binder  :</code>或者<code>transaction failed</code>,查看内核打印的binder信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">行 8675 : 03-25 14:20:30.188 0 0 I binder : 23014:23038 transaction failed 29201/-28, size 80-0 line 2879</span><br><span class="line">行 8593 : 03-25 14:20:30.134 0 0 I binder : 23014:23038 transaction failed 29201/-28, size 656-16 line 2879</span><br><span class="line">行 8545 : 03-25 14:20:30.096 0 0 I binder : 23014:23038 transaction failed 29201/-28, size 2284-8 line 2879</span><br><span class="line">行 8542 : 03-25 14:20:30.093 0 0 I binder : 23014:23038 transaction failed 29201/-28, size 2272-8 line 2879</span><br><span class="line">行 8541 : 03-25 14:20:30.083 0 0 I binder : 23014:23038 transaction failed 29201/-28, size 88-0 line 2879</span><br><span class="line">行 8536 : 03-25 14:20:30.081 0 0 I binder : 23014:23038 transaction failed 29201/-28, size 88-0 line 2879</span><br><span class="line">行 8322 : 03-25 14:20:29.774 0 0 I binder : 23014:32027 transaction failed 29201/-28, size 264-8 line 2879</span><br><span class="line"></span><br><span class="line">#log对应源码</span><br><span class="line">binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,</span><br><span class="line">		     &quot;%d:%d transaction failed %d/%d, size %lld-%lld line %d\n&quot;,</span><br><span class="line">		     proc-&gt;pid, thread-&gt;pid, return_error, return_error_param,</span><br><span class="line">		     (u64)tr-&gt;data_size, (u64)tr-&gt;offsets_size,</span><br><span class="line">		     return_error_line);</span><br></pre></td></tr></table></figure>
<p>即 进程pid:线程id 交互失败 错误码，数据大小-数据偏移，报错行。</p>
<p>发现返回的错误码都是29201&#x2F;-28，错误行2879，查看对应binder.c源码的对应行,查看上下逻辑，发现是binder_alloc_new_buf异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t-&gt;buffer = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size,</span><br><span class="line">	tr-&gt;offsets_size, extra_buffers_size,</span><br><span class="line">	!reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY), current-&gt;tgid);</span><br><span class="line">if (IS_ERR(t-&gt;buffer)) &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * -ESRCH indicates VMA cleared. The target is dying.</span><br><span class="line">	 */</span><br><span class="line">	return_error_param = PTR_ERR(t-&gt;buffer);</span><br><span class="line">	return_error = return_error_param == -ESRCH ?</span><br><span class="line">		BR_DEAD_REPLY : BR_FAILED_REPLY;</span><br><span class="line">	return_error_line = __LINE__;</span><br><span class="line">	t-&gt;buffer = NULL;</span><br><span class="line">	goto err_binder_alloc_buf_failed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续查看binder_alloc_new_buf，调用的binder_alloc.c中的<code>binder_alloc_new_buf_locked</code>,<br>尝试搜索<code>binder_alloc</code>关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">行 36078 : 03-25 14:20:08.307 0 0 I binder_alloc: 27204: pid 22973 spamming oneway? 41 buffers allocated for a total size of 293560</span><br><span class="line">行 36153 : 03-25 14:20:08.425 0 0 I binder_alloc: 27204: pid 22973 spamming oneway? 42 buffers allocated for a total size of 300720</span><br><span class="line">行 36269 : 03-25 14:20:08.627 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 224 buffers allocated for a total size of 122056</span><br><span class="line">行 36276 : 03-25 14:20:08.631 0 0 I binder_alloc: 27204: pid 22973 spamming oneway? 43 buffers allocated for a total size of 307880</span><br><span class="line">行 36316 : 03-25 14:20:08.684 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 225 buffers allocated for a total size of 122240</span><br><span class="line">行 36321 : 03-25 14:20:08.692 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 226 buffers allocated for a total size of 122616</span><br><span class="line">行 36358 : 03-25 14:20:08.791 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 227 buffers allocated for a total size of 123344</span><br><span class="line">行 36359 : 03-25 14:20:08.792 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 228 buffers allocated for a total size of 124072</span><br><span class="line">行 36360 : 03-25 14:20:08.792 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 229 buffers allocated for a total size of 124800</span><br><span class="line">行 36709 : 03-25 14:20:09.694 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 230 buffers allocated for a total size of 125176</span><br><span class="line">行 38795 : 03-25 14:20:13.707 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 234 buffers allocated for a total size of 126680</span><br><span class="line">行 38965 : 03-25 14:20:14.280 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 235 buffers allocated for a total size of 126864</span><br><span class="line">行 38999 : 03-25 14:20:14.294 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 236 buffers allocated for a total size of 127592</span><br><span class="line">行 39000 : 03-25 14:20:14.295 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 237 buffers allocated for a total size of 128320</span><br><span class="line">行 39001 : 03-25 14:20:14.296 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 238 buffers allocated for a total size of 129048</span><br><span class="line">行 39412 : 03-25 14:20:14.710 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 239 buffers allocated for a total size of 129424</span><br><span class="line">行 40175 : 03-25 14:20:15.714 0 0 I binder_alloc: 27204: pid 23014 spamming oneway? 240 buffers allocated for a total size of 129800</span><br></pre></td></tr></table></figure>
<p>发现打印了如上的log，找到对应打印log的源码,发现当进程持有的事务超过50或分配的异步空间超过了50%（总空间的25%，大概250K），就会打印这个log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Warn if this pid has more than 50 transactions, or more than 50% of</span><br><span class="line"> * async space (which is 25% of total buffer size).</span><br><span class="line"> */</span><br><span class="line">if (num_buffers &gt; 50 || total_alloc_size &gt; alloc-&gt;buffer_size / 4) &#123;</span><br><span class="line">	binder_alloc_debug(BINDER_DEBUG_USER_ERROR,</span><br><span class="line">		     &quot;%d: pid %d spamming oneway? %zd buffers allocated for a total size of %zd\n&quot;,</span><br><span class="line">		      alloc-&gt;pid, pid, num_buffers, total_alloc_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从log上看<br>22973进程发给27204的事务有43个，占了307880字节<br>23014进程发给27204的事务有240个，占了129800字节</p>
<p>在这里衍生一个知识点，oneway binder在server端只有一个线程在执行，具体的可以看驱动代码</p>
<p>异步事务最大的空间是总buffer的一半，大概500k,</p>
<p>但是从log中看异步事务一直在增长，也就是binder的server端（27204进程）一直没处理完事务，可能是在某个事务中阻塞了.<br>本地复现:<br>重复注册oneway的callback，在oneway回调的接口做耗时操作。</p>
<p>所以问题原因可能是三方APP同一个接口多个地方注册了多个回调，导致每次binder回调多次分配buffer，<br>并且app在回调中作了耗时操作，buffer没能及时释放，迅速占满缓冲区。</p>
<p>参考：<br><a href="https://blog.csdn.net/over_qqqq/article/details/114108877">https://blog.csdn.net/over_qqqq/article/details/114108877</a><br><a href="https://blog.csdn.net/liaosongmao1/article/details/124842622">https://blog.csdn.net/liaosongmao1/article/details/124842622</a><br><a href="https://blog.csdn.net/weiqifa0/article/details/100570446">https://blog.csdn.net/weiqifa0/article/details/100570446</a></p>
<h2 id="SQL-error-code-10-disk-I-O-error-extendcode-6410"><a href="#SQL-error-code-10-disk-I-O-error-extendcode-6410" class="headerlink" title="SQL error,code[10]: disk I&#x2F;O error,extendcode[6410]"></a>SQL error,code[10]: disk I&#x2F;O error,extendcode[6410]</h2><p>三方APP错误信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMP AutoSDK: 2023/04/04 19:14:20 [21724] [SL_Database.cpp:329] SQL error,code[10]: disk I/O error,extendcode[6410], sql=CREATE TABLE IF NOT EXISTS NisBaseLinkGeo(Id INTEGER,Version INTEGER,Crc32c INTEGER NULL,BaseLinkGeoTile BLOB,primary key (id))</span><br><span class="line">IMP AutoSDK: 2023/04/04 19:14:20 [21724] [SL_TableWrtBase.cpp:20] 创建表失败 CREATE TABLE IF NOT EXISTS NisBaseLinkGeo(Id INTEGER,Version INTEGER,Crc32c INTEGER NULL,BaseLinkGeoTile BLOB,primary key (id))</span><br></pre></td></tr></table></figure>

<p>数据库错误，错误信息是disk I&#x2F;O error，对应错误码是10，对应的扩展错误码是6410</p>
<p>错误码定义在&#96;&#96;&#96;sqlite3.h&#96;&#96;中，可以参考：<a href="http://sqlite.org/c3ref/c_abort_rollback.html">http://sqlite.org/c3ref/c_abort_rollback.html</a></p>
<p>IO错误找对应的SQLITE_IOERR，宏定义为10，扩展码是 (错误码|num &lt;&lt; 8), 6410-10 再 右移 8 位就知道对应的num了，也就是6400&#x2F;256&#x3D;25，</p>
<p>对应<code>#define SQLITE_IOERR_GETTEMPPATH       (SQLITE_IOERR | (25&lt;&lt;8))</code></p>
<p>所以返回的SQLITE_IOERR_GETTEMPPATH错误，查看对应源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zDir = unixTempFileDir();</span><br><span class="line">if( zDir==0 ) return SQLITE_IOERR_GETTEMPPATH;</span><br></pre></td></tr></table></figure>

<p>可以看一下 unixTempFileDir 这个函数的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const char *unixTempFileDir(void)&#123;</span><br><span class="line">  static const char *azDirs[] = &#123;</span><br><span class="line">     0,</span><br><span class="line">     0,</span><br><span class="line">     &quot;/var/tmp&quot;,</span><br><span class="line">     &quot;/usr/tmp&quot;,</span><br><span class="line">     &quot;/tmp&quot;,</span><br><span class="line">     &quot;.&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">  unsigned int i = 0;</span><br><span class="line">  struct stat buf;</span><br><span class="line">  const char *zDir = sqlite3_temp_directory;</span><br><span class="line"></span><br><span class="line">  if( !azDirs[0] ) azDirs[0] = getenv(&quot;SQLITE_TMPDIR&quot;);</span><br><span class="line">  if( !azDirs[1] ) azDirs[1] = getenv(&quot;TMPDIR&quot;);</span><br><span class="line">  while(1)&#123;</span><br><span class="line">    if( zDir!=0</span><br><span class="line">     &amp;&amp; osStat(zDir, &amp;buf)==0</span><br><span class="line">     &amp;&amp; S_ISDIR(buf.st_mode)</span><br><span class="line">     &amp;&amp; osAccess(zDir, 03)==0</span><br><span class="line">    )&#123;</span><br><span class="line">      return zDir;</span><br><span class="line">    &#125;</span><br><span class="line">    if( i&gt;=sizeof(azDirs)/sizeof(azDirs[0]) ) break;</span><br><span class="line">    zDir = azDirs[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就是用数组存放了一系列可以作为临时目录的路径，依次是：</p>
<ul>
<li><code>$SQLITE_TMPDIR</code></li>
<li><code>$TMPDIR</code></li>
<li><code>/var/tmp</code></li>
<li><code>/usr/tmp</code></li>
<li><code>/tmp</code></li>
<li><code>.</code></li>
</ul>
<p>然后依次校验：<br>文件存在 &amp;&amp; 可以获取到文件的元数据 &amp;&amp; 是一个目录 &amp;&amp; 目录有访问权限</p>
<p>如果环境变量没有设置临时路径，Android中会走到当前目录，这个报错的原因应该就是当前目录没有权限。<br>后续写了个测试程序，在app中执行shell指令获取当前路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execShell(&quot;echo $SQLITE_TMPDIR&quot;);</span><br><span class="line">execShell(&quot;echo $TMPDIR&quot;);</span><br><span class="line">execShell(&quot;pwd&quot;);</span><br><span class="line">execShell(&quot;whoami&quot;);</span><br><span class="line"></span><br><span class="line">private void execShell(String cmd) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Process process = Runtime.getRuntime().exec(new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, cmd&#125;);</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        char[] buff = new char[1024];</span><br><span class="line">        int ch = 0;</span><br><span class="line">        while ((ch = bufferedReader.read(buff)) != -1) &#123;</span><br><span class="line">            stringBuilder.append(buff, 0, ch);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        Log.d(TAG, &quot;cmd [&quot;+cmd+&quot;] execute result: &quot;+stringBuilder.toString());</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd [echo $SQLITE_TMPDIR] execute result: </span><br><span class="line">cmd [echo $TMPDIR] execute result: </span><br><span class="line">cmd [pwd] execute result: /</span><br><span class="line">cmd [whoami] execute result: u10_a33</span><br></pre></td></tr></table></figure>

<p>根目录确实没有写的权限,</p>
<p>所以只需要设置一下环境变量就好,<code>SQLITE_TMPDIR</code>和<code>TMPDIR</code>任意设置一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Os.setenv(&quot;SQLITE_TMPDIR&quot;, &quot;/data/data/custom&quot;, false);</span><br><span class="line">    Os.setenv(&quot;TMPDIR&quot;, &quot;/data/data/tmp&quot;, false);</span><br><span class="line">&#125; catch (ErrnoException e) &#123;</span><br><span class="line">    throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="startActivity抛异常"><a href="#startActivity抛异常" class="headerlink" title="startActivity抛异常"></a>startActivity抛异常</h2><p>startActivity会调用 mMainThread.getInstrumentation().execStartActivity<br>方法内部会去checkStartActivityResult，根据错误码抛异常<br>而startActivityAsUser直接调用ActivityTaskManager.getService().startActivityAsUser，不会针对错误码抛异常</p>
<h2 id="startService-U10-not-found"><a href="#startService-U10-not-found" class="headerlink" title="startService U10 not found"></a>startService U10 not found</h2><p>现象：persist进程开机无法启动自己u10下的服务。<br>解决方案： 给组件加上 <code>android:directBootAware=&quot;true&quot;</code>  或者 直接在 application标签中加上&#96;&#96;&#96;android:directBootAware&#x3D;”true”&#96;&#96;</p>
<p>ActiveServices:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ResolveInfo rInfo = mAm.getPackageManagerInternalLocked().resolveService(service,</span><br><span class="line">                        resolvedType, flags, userId, callingUid);</span><br><span class="line">ServiceInfo sInfo = rInfo != null ? rInfo.serviceInfo : null;</span><br><span class="line">if (sInfo == null) &#123;</span><br><span class="line">    Slog.w(TAG_SERVICE, &quot;Unable to start service &quot; + service + &quot; U=&quot; + userId +</span><br><span class="line">          &quot;: not found&quot;);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PackageManagerService:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ResolveInfo resolveServiceInternal(Intent intent, String resolvedType, int flags,</span><br><span class="line">            int userId, int callingUid) &#123;</span><br><span class="line">    //...</span><br><span class="line">    List&lt;ResolveInfo&gt; query = queryIntentServicesInternal(</span><br><span class="line">            intent, resolvedType, flags, userId, callingUid, false /*includeInstantApps*/);</span><br><span class="line">    Slog.e(&quot;custom_debug&quot;, &quot;List&lt;ResolveInfo&gt; = &quot;+query);</span><br><span class="line">    if (query != null) &#123;</span><br><span class="line">        Slog.e(&quot;custom_debug&quot;, &quot;List&lt;ResolveInfo&gt; size = &quot;+query.size());</span><br><span class="line">        if (query.size() &gt;= 1) &#123;</span><br><span class="line">            // If there is more than one service with the same priority,</span><br><span class="line">            // just arbitrarily pick the first one.</span><br><span class="line">            return query.get(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private @NonNull List&lt;ResolveInfo&gt; queryIntentServicesInternal(Intent intent,</span><br><span class="line">      String resolvedType, int flags, int userId, int callingUid,</span><br><span class="line">      boolean includeInstantApps) &#123;</span><br><span class="line"></span><br><span class="line">      //...</span><br><span class="line">      final ServiceInfo si = getServiceInfo(comp, flags, userId);</span><br><span class="line">      //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ServiceInfo getServiceInfo(ComponentName component, int flags, int userId) &#123;</span><br><span class="line">  //...</span><br><span class="line">          if (mSettings.isEnabledAndMatchLPr(pkg, s, flags, userId)) &#123;</span><br><span class="line">              //...</span><br><span class="line">          &#125;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Settings:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean isEnabledAndMatchLPr(ComponentInfo componentInfo, int flags, int userId) &#123;</span><br><span class="line">    final PackageSetting ps = mPackages.get(componentInfo.packageName);</span><br><span class="line">    if (ps == null) return false;</span><br><span class="line"></span><br><span class="line">    final PackageUserState userState = ps.readUserState(userId);</span><br><span class="line">    return userState.isMatch(componentInfo, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PackageUserState:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isMatch(boolean isSystem, boolean isPackageEnabled, boolean isComponentEnabled,</span><br><span class="line">            boolean isComponentDirectBootAware, String componentName, int flags) &#123;</span><br><span class="line">    final boolean matchUninstalled = (flags &amp; PackageManager.MATCH_KNOWN_PACKAGES) != 0;</span><br><span class="line">    if (!isAvailable(flags) &amp;&amp; !(isSystem &amp;&amp; matchUninstalled)) &#123;</span><br><span class="line">        return reportIfDebug(false, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!isEnabled(isPackageEnabled, isComponentEnabled, componentName, flags)) &#123;</span><br><span class="line">        return reportIfDebug(false, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((flags &amp; MATCH_SYSTEM_ONLY) != 0) &#123;</span><br><span class="line">        if (!isSystem) &#123;</span><br><span class="line">            return reportIfDebug(false, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //关键看这里</span><br><span class="line">    final boolean matchesUnaware = ((flags &amp; MATCH_DIRECT_BOOT_UNAWARE) != 0)</span><br><span class="line">            &amp;&amp; !isComponentDirectBootAware;</span><br><span class="line">    final boolean matchesAware = ((flags &amp; MATCH_DIRECT_BOOT_AWARE) != 0)</span><br><span class="line">            &amp;&amp; isComponentDirectBootAware;</span><br><span class="line">    Slog.e(&quot;custom_debug&quot;,&quot;isComponentDirectBootAware = &quot;+isComponentDirectBootAware+&quot;,&quot; +</span><br><span class="line">            &quot;matchesUnaware = &quot;+matchesUnaware+&quot;, matchesAware = &quot;+ matchesAware);</span><br><span class="line">    //matchesUnaware 或 matchesAware 任意一个满足就返回match</span><br><span class="line">    //而flags肯定包含MATCH_DIRECT_BOOT_AWARE，所以只要isComponentDirectBootAware为true就满足matchesAware</span><br><span class="line">    return reportIfDebug(matchesUnaware || matchesAware, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flags可以看 pms中的 updateFlags() updateFlagsForComponent()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Update given flags based on encryption status of current user.</span><br><span class="line"> */</span><br><span class="line">private int updateFlags(int flags, int userId) &#123;</span><br><span class="line">    if ((flags &amp; (PackageManager.MATCH_DIRECT_BOOT_UNAWARE</span><br><span class="line">            | PackageManager.MATCH_DIRECT_BOOT_AWARE)) != 0) &#123;</span><br><span class="line">        // Caller expressed an explicit opinion about what encryption</span><br><span class="line">        // aware/unaware components they want to see, so fall through and</span><br><span class="line">        // give them what they want</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Caller expressed no opinion, so match based on user state</span><br><span class="line">        if (mUserManager.isUserUnlockingOrUnlocked(userId)) &#123;</span><br><span class="line">            flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="编译AndroidSDK报错"><a href="#编译AndroidSDK报错" class="headerlink" title="编译AndroidSDK报错"></a>编译AndroidSDK报错</h2><p>由于framework中引入了新的字体，编译sdk时，一直报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/bash -c &quot;PYTHONPATH=\$PYTHONPATH:external/fonttools/Lib frameworks/layoutlib/rename_font/build_font_single.py out/target/product/msmnile_gvmq/system/fonts/Alibaba-PuHuiTi-Bold.ttf out/host/common/obj/PACKAGING/sdk-fonts_intermediates/Alibaba-PuHuiTi-Bold.ttf&quot;</span><br><span class="line">Converting font: Alibaba-PuHuiTi-Bold.ttf</span><br><span class="line">ERROR: Unhandled exception has occurred</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttx.py&quot;, line 401, in main</span><br><span class="line">    process(jobs, options)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttx.py&quot;, line 375, in process</span><br><span class="line">    action(input, output, options)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/misc/loggingTools.py&quot;, line 375, in wrapper</span><br><span class="line">    return func(*args, **kwds)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttx.py&quot;, line 272, in ttDump</span><br><span class="line">    newlinestr=options.newlinestr)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 228, in saveXML</span><br><span class="line">    self._saveXML(writer, **kwargs)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 283, in _saveXML</span><br><span class="line">    self._tableToXML(tableWriter, tag, splitGlyphs=splitGlyphs)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 314, in _tableToXML</span><br><span class="line">    table.toXML(writer, self)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/tables/S_V_G_.py&quot;, line 275, in toXML</span><br><span class="line">    for doc, startGID, endGID in self.docList:</span><br><span class="line">TypeError: &#x27;NoneType&#x27; object is not iterable</span><br></pre></td></tr></table></figure>

<p>看着是S_V_G_.py中报错了，self.docList是空的,加<code>if self.docList is not None:</code>进行判断，但还是报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/bash -c &quot;PYTHONPATH=\$PYTHONPATH:external/fonttools/Lib frameworks/layoutlib/rename_font/build_font_single.py out/target/product/msmnile_gvmq/system/fonts/Alibaba-PuHuiTi-Regular.ttf out/host/common/</span><br><span class="line">obj/PACKAGING/sdk-fonts_intermediates/Alibaba-PuHuiTi-Regular.ttf&quot;</span><br><span class="line">ERROR: Unhandled exception has occurred</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttx.py&quot;, line 401, in main</span><br><span class="line">    process(jobs, options)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttx.py&quot;, line 375, in process</span><br><span class="line">    action(input, output, options)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/misc/loggingTools.py&quot;, line 375, in wrapper</span><br><span class="line">    return func(*args, **kwds)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttx.py&quot;, line 293, in ttCompile</span><br><span class="line">    ttf.save(output)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 173, in save</span><br><span class="line">    writer_reordersTables = self._save(tmp)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 212, in _save</span><br><span class="line">    self._writeTable(tag, writer, done, tableCache)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 633, in _writeTable</span><br><span class="line">    tabledata = self.getTableData(tag)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/ttFont.py&quot;, line 651, in getTableData</span><br><span class="line">    return self.tables[tag].compile(self)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/tables/S_V_G_.py&quot;, line 192, in compile</span><br><span class="line">    data = self.compileFormat0(ttFont)</span><br><span class="line">  File &quot;/home/lifeifei/workspace/changan75a322/lagvm/lagvm/LINUX/android/external/fonttools/Lib/fontTools/ttLib/tables/S_V_G_.py&quot;, line 201, in compileFormat0</span><br><span class="line">    numEntries = len(self.docList)</span><br><span class="line">AttributeError: &#x27;table_S_V_G_&#x27; object has no attribute &#x27;docList&#x27;</span><br></pre></td></tr></table></figure>
<p>继续加异常判断：<code>if hasattr(self, &quot;docList&quot;):</code></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>View带有FITS_SYSTEM_WINDOWS flag 会applyInsets</p>
<h2 id="后台启动Activity"><a href="#后台启动Activity" class="headerlink" title="后台启动Activity"></a>后台启动Activity</h2><p>被前台app bind的service可以在后台启动activity</p>
<h2 id="Home回到主页后，后台启动Activity延迟"><a href="#Home回到主页后，后台启动Activity延迟" class="headerlink" title="Home回到主页后，后台启动Activity延迟"></a>Home回到主页后，后台启动Activity延迟</h2><p>原生机制，回到主页后5s内没有STOP_APP_SWITCHES权限的app，不会立即响应startActivity</p>
<p>在ActivityStarter的executeRequest中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// If we are starting an activity that is not from the same uid as the currently resumed</span><br><span class="line">// one, check whether app switches are allowed.</span><br><span class="line">if (voiceSession == null &amp;&amp; stack != null &amp;&amp; (stack.getResumedActivity() == null</span><br><span class="line">        || stack.getResumedActivity().info.applicationInfo.uid != realCallingUid)) &#123;</span><br><span class="line">    //这里会去检查是否有appswitch的权限</span><br><span class="line">    if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,</span><br><span class="line">            realCallingPid, realCallingUid, &quot;Activity start&quot;)) &#123;</span><br><span class="line">        if (!(restrictedBgActivity &amp;&amp; handleBackgroundActivityAbort(r))) &#123;</span><br><span class="line">            mController.addPendingActivityLaunch(new PendingActivityLaunch(r,</span><br><span class="line">                    sourceRecord, startFlags, stack, callerApp, intentGrants));</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityOptions.abort(checkedOptions);</span><br><span class="line">        return ActivityManager.START_SWITCHES_CANCELED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ATMS中checkAppSwitchAllowedLocked：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean checkAppSwitchAllowedLocked(int sourcePid, int sourceUid,</span><br><span class="line">        int callingPid, int callingUid, String name) &#123;</span><br><span class="line">    //判断当前时间是否已经到达允许普通app进行app切换的时间</span><br><span class="line">    if (mAppSwitchesAllowedTime &lt; SystemClock.uptimeMillis()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (getRecentTasks().isCallerRecents(sourceUid)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里检查STOP_APP_SWITCHES权限</span><br><span class="line">    int perm = checkComponentPermission(STOP_APP_SWITCHES, sourcePid, sourceUid, -1, true);</span><br><span class="line">    if (perm == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (checkAllowAppSwitchUid(sourceUid)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the actual IPC caller is different from the logical source, then</span><br><span class="line">    // also see if they are allowed to control app switches.</span><br><span class="line">    if (callingUid != -1 &amp;&amp; callingUid != sourceUid) &#123;</span><br><span class="line">        perm = checkComponentPermission(STOP_APP_SWITCHES, callingPid, callingUid, -1, true);</span><br><span class="line">        if (perm == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (checkAllowAppSwitchUid(callingUid)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Slog.w(TAG, name + &quot; request from &quot; + sourceUid + &quot; stopped&quot;);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void stopAppSwitches() &#123;</span><br><span class="line">    enforceCallerIsRecentsOrHasPermission(STOP_APP_SWITCHES, &quot;stopAppSwitches&quot;);</span><br><span class="line">    synchronized (mGlobalLock) &#123;</span><br><span class="line">        //每次调用stopAppSwitches时，都会将允许普通app切换的时间延长5s，而源码搜索发现在回到桌面时会调用次方法</span><br><span class="line">        mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + APP_SWITCH_DELAY_TIME;</span><br><span class="line">        mLastStopAppSwitchesTime = SystemClock.uptimeMillis();</span><br><span class="line">        mDidAppSwitch = false;</span><br><span class="line">        getActivityStartController().schedulePendingActivityLaunches(APP_SWITCH_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="onStop在onPause-10s后才回调"><a href="#onStop在onPause-10s后才回调" class="headerlink" title="onStop在onPause 10s后才回调"></a>onStop在onPause 10s后才回调</h2><p>onStop触发的时机，App在onResume之后，会向主线程的MessageQueue中添加一个IdleHandler，在MessageQueue空闲时触发IdleHandler的queueIdle(),<br>在queueIdle()中执行stop事件</p>
<p>在handleResumeActivity中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,</span><br><span class="line">            String reason) &#123;</span><br><span class="line">        //......</span><br><span class="line">        final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">        //......</span><br><span class="line">        //将当前resume的Activity的nextIdle指向之前最新的那个activity</span><br><span class="line">        r.nextIdle = mNewActivities;</span><br><span class="line">        //将最新resume的activity赋值给mNewActivities（链表）</span><br><span class="line">        mNewActivities = r;</span><br><span class="line">        if (localLOGV || enableLifeCycleLog()) Slog.v(TAG, &quot;Scheduling idle handler for &quot; + r);</span><br><span class="line">        Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看queueIdle()做了啥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private class Idler implements MessageQueue.IdleHandler &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public final boolean queueIdle() &#123;</span><br><span class="line">            //取到最新resume的activity</span><br><span class="line">            ActivityClientRecord a = mNewActivities;</span><br><span class="line">            boolean stopProfiling = false;</span><br><span class="line">            if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null</span><br><span class="line">                    &amp;&amp; mProfiler.autoStopProfiler) &#123;</span><br><span class="line">                stopProfiling = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (a != null) &#123;</span><br><span class="line">                mNewActivities = null;</span><br><span class="line">                IActivityTaskManager am = ActivityTaskManager.getService();</span><br><span class="line">                ActivityClientRecord prev;</span><br><span class="line">                //开始遍历resume的activity链表</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (localLOGV || enableLifeCycleLog()) Slog.v(</span><br><span class="line">                        TAG, &quot;Reporting idle of &quot; + a +</span><br><span class="line">                        &quot; finished=&quot; +</span><br><span class="line">                        (a.activity != null &amp;&amp; a.activity.mFinished));</span><br><span class="line">                    //如果resume的activity没有finished，就调用ActivityManagerTaskService的activityIdle</span><br><span class="line">                    if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                            a.createdConfig = null;</span><br><span class="line">                        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                            throw ex.rethrowFromSystemServer();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = a;</span><br><span class="line">                    a = a.nextIdle;</span><br><span class="line">                    prev.nextIdle = null;</span><br><span class="line">                &#125; while (a != null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (stopProfiling) &#123;</span><br><span class="line">                mProfiler.stopProfiling();</span><br><span class="line">            &#125;</span><br><span class="line">            applyPendingProcessState();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接着就到了SystemServer，ATMS的activityIdle中调用的ActivityStackSupervisor的activityIdleInternal，内部又调用了processStoppingAndFinishingActivities，<br>看看processStoppingAndFinishingActivities：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void processStoppingAndFinishingActivities(ActivityRecord launchedActivity,</span><br><span class="line">        boolean processPausingActivities, String reason) &#123;</span><br><span class="line">    //......</span><br><span class="line">    for (int i = 0; i &lt; numReadyStops; i++) &#123;</span><br><span class="line">        final ActivityRecord r = readyToStopActivities.get(i);</span><br><span class="line">        if (r.isInHistory()) &#123;</span><br><span class="line">            //这里判断如果是调用了finish，就会走到destory的逻辑</span><br><span class="line">            if (r.finishing) &#123;</span><br><span class="line">                // TODO(b/137329632): Wait for idle of the right activity, not just any.</span><br><span class="line">                r.destroyIfPossible(reason);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //没有调用finish，就走stop的逻辑</span><br><span class="line">                r.stopIfPossible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //.......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有调用ActivityStackSupervisor.scheduleIdle(),会向handler发送一个空的IDLE_NOW_MSG消息<br>ActivityRecord.addToStopping<br>ActivityRecord.onAnimationFinished</p>
<h2 id="AppWiget刷新UI没变"><a href="#AppWiget刷新UI没变" class="headerlink" title="AppWiget刷新UI没变"></a>AppWiget刷新UI没变</h2><p>刷新appwidget是通过调用AppWidgetManager.updateAppWidget()将RemoteViews传递给AppWidgetHost,在AppWidgetHostView中显示<br>所以数据源是来自于APP传的RemoteViews，UI没变化，就需要APP端排查。<br>出现刷新UI没变化这个问题：<br>app进程crash了，在crash前后重启后传入的RemoteViews的layoutId是一样的，AppWidgetHostView会直接复用之前的layout，所有的子控件状态都是crash前的状态。<br>但是app重启后没有对RemoteViews中的子控件进行初始化操作，部分控件是不可见的，所以刷新后UI没变化。</p>
<h2 id="记录一下关于WindowInsetsController的用法"><a href="#记录一下关于WindowInsetsController的用法" class="headerlink" title="记录一下关于WindowInsetsController的用法"></a>记录一下关于WindowInsetsController的用法</h2><p>WindowInsetsController可以显示隐藏指定的系统窗口,可以通过它实现全屏显示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//隐藏导航栏和状态栏</span><br><span class="line">getWindow().getDecorView().getWindowInsetsController().hide(WindowInsets.Type.navigationBars() | WindowInsets.Type.statusBars());</span><br></pre></td></tr></table></figure>
<p>但默认只要用户有任何交互都会导致隐藏的系统窗口再次显示<br>可以添加加behavior来实现沉浸式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getWindow().getDecorView().getWindowInsetsController().setSystemBarsBehavior(WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE);</span><br></pre></td></tr></table></figure>
<p>此外还有其他方式,但最终都是设置的behavior.<br>在ViewRootImpl中的adjustLayoutParamsForCompatibility有如下逻辑:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void adjustLayoutParamsForCompatibility(WindowManager.LayoutParams inOutParams) &#123;</span><br><span class="line">    //......</span><br><span class="line">    //判断是否有调用过setSystemBarsBehavior</span><br><span class="line">    if ((inOutParams.privateFlags &amp; PRIVATE_FLAG_BEHAVIOR_CONTROLLED) == 0) &#123;</span><br><span class="line">        //没有调用过setSystemBarsBehavior,</span><br><span class="line">        //如果有SYSTEM_UI_FLAG_IMMERSIVE_STICKY</span><br><span class="line">        //或者window的glag中有FLAG_FULLSCREEN都会自动设置BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE</span><br><span class="line">        if ((sysUiVis &amp; SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0</span><br><span class="line">                || (flags &amp; FLAG_FULLSCREEN) != 0) &#123;</span><br><span class="line">            inOutParams.insetsFlags.behavior = BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE;</span><br><span class="line">        &#125; else if ((sysUiVis &amp; SYSTEM_UI_FLAG_IMMERSIVE) != 0) &#123;</span><br><span class="line">            inOutParams.insetsFlags.behavior = BEHAVIOR_SHOW_BARS_BY_SWIPE;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //默认behavior就是点击就显示系统窗口</span><br><span class="line">            inOutParams.insetsFlags.behavior = BEHAVIOR_SHOW_BARS_BY_TOUCH;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以可以有另外的方式来实现沉浸式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置SystemUiVisibility来实现沉浸式</span><br><span class="line">getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);</span><br><span class="line">//window添加全屏flag来实现沉浸式 和 在主题中配置 &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; 是一样的</span><br><span class="line">getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);</span><br></pre></td></tr></table></figure>

<h2 id="app切换时，闪其它app页面"><a href="#app切换时，闪其它app页面" class="headerlink" title="app切换时，闪其它app页面"></a>app切换时，闪其它app页面</h2><p>现象：从activity A 启动到 B ，再启动C，finish C后，有时会闪一下A再显示B</p>
<p>排查wm的tag后发现，从A 到 B的过程，A已经不可见了，但是并没有触发A的onStop生命周期，一直处于onPause状态，<br>启动C后，触发了B和A的onStop，finish C时，B和A重走了一次onRestart生命周期。</p>
<p>所以问题点就在A到B的过程，B已经将A遮挡但A还没有走onStop，那说明B有什么配置导致A对用户来说还是可见的，排查后发现B有一个windowIsTranslucent为true的配置</p>
<p>查看ActivityRecord的源码可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityRecord(...)&#123;</span><br><span class="line">    //......</span><br><span class="line">    final AttributeCache.Entry ent = AttributeCache.instance().get(packageName,</span><br><span class="line">            realTheme, com.android.internal.R.styleable.Window, mUserId);</span><br><span class="line"></span><br><span class="line">    if (ent != null) &#123;</span><br><span class="line">        //这里判断了Activity是否是全遮盖的</span><br><span class="line">        mOccludesParent = !ActivityInfo.isTranslucentOrFloating(ent.array);</span><br><span class="line">        hasWallpaper = ent.array.getBoolean(R.styleable.Window_windowShowWallpaper, false);</span><br><span class="line">        noDisplay = ent.array.getBoolean(R.styleable.Window_windowNoDisplay, false);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        hasWallpaper = false;</span><br><span class="line">        noDisplay = false;</span><br><span class="line">    &#125;</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Activity不是全遮盖，下面的Activity就是可见的<br>在ActivityStack的ensureActivitiesVisible中会去调用EnsureActivitiesVisibleHelper的process</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ensureActivitiesVisible(@Nullable ActivityRecord starting, int configChanges,</span><br><span class="line">        boolean preserveWindows, boolean notifyClients) &#123;</span><br><span class="line">    mTopActivityOccludesKeyguard = false;</span><br><span class="line">    mTopDismissingKeyguardActivity = null;</span><br><span class="line">    mStackSupervisor.beginActivityVisibilityUpdate();</span><br><span class="line">    try &#123;</span><br><span class="line">        mEnsureActivitiesVisibleHelper.process(</span><br><span class="line">                starting, configChanges, preserveWindows, notifyClients);</span><br><span class="line"></span><br><span class="line">        if (mTranslucentActivityWaiting != null &amp;&amp;</span><br><span class="line">                mUndrawnActivitiesBelowTopTranslucent.isEmpty()) &#123;</span><br><span class="line">            // Nothing is getting drawn or everything was already visible, don&#x27;t wait for timeout.</span><br><span class="line">            notifyActivityDrawnLocked(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mStackSupervisor.endActivityVisibilityUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void process(@Nullable ActivityRecord starting, int configChanges, boolean preserveWindows,</span><br><span class="line">        boolean notifyClients) &#123;</span><br><span class="line">    reset(starting, configChanges, preserveWindows, notifyClients);</span><br><span class="line"></span><br><span class="line">    if (DEBUG_VISIBILITY) Slog.v(TAG_VISIBILITY, &quot;ensureActivitiesVisible behind &quot; + mTop</span><br><span class="line">            + &quot; configChanges=0x&quot; + Integer.toHexString(configChanges));</span><br><span class="line">    if (mTop != null) &#123;</span><br><span class="line">        mContiner.checkTranslucentActivityWaiting(mTop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We should not resume activities that being launched behind because these</span><br><span class="line">    // activities are actually behind other fullscreen activities, but still required</span><br><span class="line">    // to be visible (such as performing Recents animation).</span><br><span class="line">    final boolean resumeTopActivity = mTop != null &amp;&amp; !mTop.mLaunchTaskBehind</span><br><span class="line">            &amp;&amp; mContiner.isTopActivityFocusable()</span><br><span class="line">            &amp;&amp; (starting == null || !starting.isDescendantOf(mContiner));</span><br><span class="line"></span><br><span class="line">    final PooledConsumer f = PooledLambda.obtainConsumer(</span><br><span class="line">            EnsureActivitiesVisibleHelper::setActivityVisibilityState, this,</span><br><span class="line">            PooledLambda.__(ActivityRecord.class), starting, resumeTopActivity);</span><br><span class="line">    mContiner.forAllActivities(f);</span><br><span class="line">    f.recycle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reset(ActivityRecord starting, int configChanges, boolean preserveWindows,</span><br><span class="line">        boolean notifyClients) &#123;</span><br><span class="line">    mStarting = starting;</span><br><span class="line">    mTop = mContiner.topRunningActivity();</span><br><span class="line">    // If the top activity is not fullscreen, then we need to make sure any activities under it</span><br><span class="line">    // are now visible.</span><br><span class="line">    mAboveTop = mTop != null;</span><br><span class="line">    mContainerShouldBeVisible = mContiner.shouldBeVisible(mStarting);</span><br><span class="line">    mBehindFullscreenActivity = !mContainerShouldBeVisible;</span><br><span class="line">    mConfigChanges = configChanges;</span><br><span class="line">    mPreserveWindows = preserveWindows;</span><br><span class="line">    mNotifyClients = notifyClients;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>reset中重新判断了task的可见性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int getVisibility(ActivityRecord starting) &#123;</span><br><span class="line">    if (!isAttached() || isForceHidden()) &#123;</span><br><span class="line">        return STACK_VISIBILITY_INVISIBLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isTopActivityLaunchedBehind()) &#123;</span><br><span class="line">        return STACK_VISIBILITY_VISIBLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean gotSplitScreenStack = false;</span><br><span class="line">    boolean gotOpaqueSplitScreenPrimary = false;</span><br><span class="line">    boolean gotOpaqueSplitScreenSecondary = false;</span><br><span class="line">    boolean gotTranslucentFullscreen = false;</span><br><span class="line">    boolean gotTranslucentSplitScreenPrimary = false;</span><br><span class="line">    boolean gotTranslucentSplitScreenSecondary = false;</span><br><span class="line">    boolean shouldBeVisible = true;</span><br><span class="line"></span><br><span class="line">    // This stack is only considered visible if all its parent stacks are considered visible,</span><br><span class="line">    // so check the visibility of all ancestor stacks first.</span><br><span class="line">    final WindowContainer parent = getParent();</span><br><span class="line">    if (parent.asTask() != null) &#123;</span><br><span class="line">        final int parentVisibility = parent.asTask().getVisibility(starting);</span><br><span class="line">        if (parentVisibility == STACK_VISIBILITY_INVISIBLE) &#123;</span><br><span class="line">            // Can&#x27;t be visible if parent isn&#x27;t visible</span><br><span class="line">            return STACK_VISIBILITY_INVISIBLE;</span><br><span class="line">        &#125; else if (parentVisibility == STACK_VISIBILITY_VISIBLE_BEHIND_TRANSLUCENT) &#123;</span><br><span class="line">            // Parent is behind a translucent container so the highest visibility this container</span><br><span class="line">            // can get is that.</span><br><span class="line">            gotTranslucentFullscreen = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int windowingMode = getWindowingMode();</span><br><span class="line">    final boolean isAssistantType = isActivityTypeAssistant();</span><br><span class="line">    //这里会去遍历所有的task</span><br><span class="line">    for (int i = parent.getChildCount() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        final WindowContainer wc = parent.getChildAt(i);</span><br><span class="line">        final Task other = wc.asTask();</span><br><span class="line">        if (other == null) continue;</span><br><span class="line"></span><br><span class="line">        final boolean hasRunningActivities = other.topRunningActivity() != null;</span><br><span class="line">        if (other == this) &#123;</span><br><span class="line">            // Should be visible if there is no other stack occluding it, unless it doesn&#x27;t</span><br><span class="line">            // have any running activities, not starting one and not home stack.</span><br><span class="line">            shouldBeVisible = hasRunningActivities || isInTask(starting) != null</span><br><span class="line">                    || isActivityTypeHome();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!hasRunningActivities) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int otherWindowingMode = other.getWindowingMode();</span><br><span class="line"></span><br><span class="line">        //主要逻辑在这里，一般Task的windowMode都是WINDOWING_MODE_FULLSCREEN，</span><br><span class="line">        //正常情况下，只要上层的Task不是translucent就会直接返回STACK_VISIBILITY_INVISIBLE</span><br><span class="line">        if (otherWindowingMode == WINDOWING_MODE_FULLSCREEN) &#123;</span><br><span class="line">            if (other.isTranslucent(starting)) &#123;</span><br><span class="line">                // Can be visible behind a translucent fullscreen stack.</span><br><span class="line">                gotTranslucentFullscreen = true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            return STACK_VISIBILITY_INVISIBLE;</span><br><span class="line">        &#125; //......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!shouldBeVisible) &#123;</span><br><span class="line">        return STACK_VISIBILITY_INVISIBLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Handle cases when there can be a translucent split-screen stack on top.</span><br><span class="line">    switch (windowingMode) &#123;</span><br><span class="line">        case WINDOWING_MODE_FULLSCREEN:</span><br><span class="line">            if (gotTranslucentSplitScreenPrimary || gotTranslucentSplitScreenSecondary) &#123;</span><br><span class="line">                // At least one of the split-screen stacks that covers this one is translucent.</span><br><span class="line">                return STACK_VISIBILITY_VISIBLE_BEHIND_TRANSLUCENT;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case WINDOWING_MODE_SPLIT_SCREEN_PRIMARY:</span><br><span class="line">            if (gotTranslucentSplitScreenPrimary) &#123;</span><br><span class="line">                // Covered by translucent primary split-screen on top.</span><br><span class="line">                return STACK_VISIBILITY_VISIBLE_BEHIND_TRANSLUCENT;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case WINDOWING_MODE_SPLIT_SCREEN_SECONDARY:</span><br><span class="line">            if (gotTranslucentSplitScreenSecondary) &#123;</span><br><span class="line">                // Covered by translucent secondary split-screen on top.</span><br><span class="line">                return STACK_VISIBILITY_VISIBLE_BEHIND_TRANSLUCENT;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Lastly - check if there is a translucent fullscreen stack on top.</span><br><span class="line">    return gotTranslucentFullscreen ? STACK_VISIBILITY_VISIBLE_BEHIND_TRANSLUCENT</span><br><span class="line">            : STACK_VISIBILITY_VISIBLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以只要最上层的task是translucent，下面一个task就是visible的，不会走onStop生命周期，<br>此时如果打开一个新的Activity，下层2个可见的task都会走onStop，<br>接着再finish最上层的，下层2个可见的就会重新restart，当下层app在透明task获取到焦点（onResume）前完成了onStart就会出现闪烁现象</p>
<p>注：onStart——对用户可见  onResume——对用户可见并获取到焦点，位于栈顶<br>生命周期的可见性可在[官方文档(<a href="https://developer.android.google.cn/guide/components/activities/intro-activities?hl=zh-cn#mtal)]%E4%B8%AD%E6%9F%A5%E7%9C%8B">https://developer.android.google.cn/guide/components/activities/intro-activities?hl=zh-cn#mtal)]中查看</a></p>
<h2 id="Activity在onPause后无法收到onConfigurationChanged"><a href="#Activity在onPause后无法收到onConfigurationChanged" class="headerlink" title="Activity在onPause后无法收到onConfigurationChanged"></a>Activity在onPause后无法收到onConfigurationChanged</h2><p>Activity在onPause后无法收到onConfigurationChanged，<br>原因就是原生逻辑就是：Activity没有调用finish并且Activity没有pause，才会将其加到有效的回调队列</p>
<p>在AOSP的ActivityThread中有如下源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void handleConfigurationChanged(Configuration config) &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;configChanged&quot;);</span><br><span class="line">    mCurDefaultDisplayDpi = config.densityDpi;</span><br><span class="line">    handleConfigurationChanged(config, null /* compat */);</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleConfigurationChanged(Configuration config, CompatibilityInfo compat) &#123;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    //先收集所有的有效的callback</span><br><span class="line">    ArrayList&lt;ComponentCallbacks2&gt; callbacks = collectComponentCallbacks(false, config);</span><br><span class="line"></span><br><span class="line">    freeTextLayoutCachesIfNeeded(configDiff);</span><br><span class="line"></span><br><span class="line">    //这里会去遍历所有的callback，然后根据callback的类型进行回调</span><br><span class="line">    if (callbacks != null) &#123;</span><br><span class="line">        final int N = callbacks.size();</span><br><span class="line">        for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">            ComponentCallbacks2 cb = callbacks.get(i);</span><br><span class="line">            if (cb instanceof Activity) &#123;</span><br><span class="line">                // If callback is an Activity - call corresponding method to consider override</span><br><span class="line">                // config and avoid onConfigurationChanged if it hasn&#x27;t changed.</span><br><span class="line">                Activity a = (Activity) cb;</span><br><span class="line">                performConfigurationChangedForActivity(mActivities.get(a.getActivityToken()),</span><br><span class="line">                        config);</span><br><span class="line">            &#125; else if (!equivalent) &#123;</span><br><span class="line">                performConfigurationChanged(cb, config);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // TODO (b/135719017): Temporary log for debugging IME service.</span><br><span class="line">                if (Build.IS_DEBUGGABLE &amp;&amp; cb instanceof InputMethodService) &#123;</span><br><span class="line">                    Log.w(TAG, &quot;performConfigurationChanged didn&#x27;t callback to IME &quot;</span><br><span class="line">                            + &quot;, configDiff=&quot; + configDiff</span><br><span class="line">                            + &quot;, mConfiguration=&quot; + mConfiguration);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">ArrayList&lt;ComponentCallbacks2&gt; collectComponentCallbacks(</span><br><span class="line">        boolean allActivities, Configuration newConfig) &#123;</span><br><span class="line">    ArrayList&lt;ComponentCallbacks2&gt; callbacks</span><br><span class="line">            = new ArrayList&lt;ComponentCallbacks2&gt;();</span><br><span class="line"></span><br><span class="line">    synchronized (mResourcesManager) &#123;</span><br><span class="line">        //Application组件的callback</span><br><span class="line">        final int NAPP = mAllApplications.size();</span><br><span class="line">        for (int i=0; i&lt;NAPP; i++) &#123;</span><br><span class="line">            callbacks.add(mAllApplications.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        //Activity组件的callback</span><br><span class="line">        final int NACT = mActivities.size();</span><br><span class="line">        for (int i=0; i&lt;NACT; i++) &#123;</span><br><span class="line">            ActivityClientRecord ar = mActivities.valueAt(i);</span><br><span class="line">            Activity a = ar.activity;</span><br><span class="line">            if (a != null) &#123;</span><br><span class="line">                Configuration thisConfig = applyConfigCompatMainThread(</span><br><span class="line">                        mCurDefaultDisplayDpi, newConfig,</span><br><span class="line">                        ar.packageInfo.getCompatibilityInfo());</span><br><span class="line">                //这里有逻辑：Activity没有调用finish并且Activity没有pause，才会将其加到有效的回调队列</span><br><span class="line">                if (!ar.activity.mFinished &amp;&amp; (allActivities || !ar.paused)) &#123;</span><br><span class="line">                    // If the activity is currently resumed, its configuration</span><br><span class="line">                    // needs to change right now.</span><br><span class="line">                    callbacks.add(a);</span><br><span class="line">                &#125; else if (thisConfig != null) &#123;</span><br><span class="line">                    // Otherwise, we will tell it about the change</span><br><span class="line">                    // the next time it is resumed or shown.  Note that</span><br><span class="line">                    // the activity manager may, before then, decide the</span><br><span class="line">                    // activity needs to be destroyed to handle its new</span><br><span class="line">                    // configuration.</span><br><span class="line">                    if (DEBUG_CONFIGURATION || enableLifeCycleLog()) &#123;</span><br><span class="line">                        Slog.v(TAG, &quot;Setting activity &quot;</span><br><span class="line">                                + ar.activityInfo.name + &quot; newConfig=&quot; + thisConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ar.newConfig = thisConfig;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //Service组件的callback</span><br><span class="line">        final int NSVC = mServices.size();</span><br><span class="line">        for (int i=0; i&lt;NSVC; i++) &#123;</span><br><span class="line">            final ComponentCallbacks2 serviceComp = mServices.valueAt(i);</span><br><span class="line">            if (serviceComp instanceof InputMethodService) &#123;</span><br><span class="line">                mHasImeComponent = true;</span><br><span class="line">            &#125;</span><br><span class="line">            callbacks.add(serviceComp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //ContentProvider组件的callback</span><br><span class="line">    synchronized (mProviderMap) &#123;</span><br><span class="line">        final int NPRV = mLocalProviders.size();</span><br><span class="line">        for (int i=0; i&lt;NPRV; i++) &#123;</span><br><span class="line">            callbacks.add(mLocalProviders.valueAt(i).mLocalProvider);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return callbacks;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h2 id="记录一起开机卡LOGO的问题"><a href="#记录一起开机卡LOGO的问题" class="headerlink" title="记录一起开机卡LOGO的问题"></a>记录一起开机卡LOGO的问题</h2><p>可以搜索关键字<code>wm_</code>,<code>uc_</code>,<code>BootAnimation</code>,<code>FinishBooting</code></p>
<p>也可以搜索<code>SystemServiceManager</code>,<code>SystemServerTiming</code>查看服务启动过程</p>
<p>这里记录的问题是发现在 <code>SystemServerTiming</code>的log中<code>setBinderProxies</code>之后就没有了,后续应该是<code>WaitInitThreadPoolShutdown</code>，<br>查看对应源码，发现是在PHASE_BOOT_COMPLETED阶段调用，也就是没有触发PHASE_BOOT_COMPLETED，<br>查看<code>Starting phase</code>相关的log，发现没有<code>Starting phase 1000</code>,也就是没有<code>PHASE_BOOT_COMPLETED</code><br>继续查看源码，发现 <code>PHASE_BOOT_COMPLETED</code>是在AMS的 <code>finishBooting</code>中调用的</p>
<p>后面继续往前排查，找到在<code>activityIdleInternal</code>中会去调用方法，最后调用到<code>finishBooting</code></p>
<p>由于idle是在ActivityThread中触发，没触发idle说明没有进程起来，最后排查发现确实有人修改了AMS的逻辑，<br>特殊条件下拦截了Activity的启动，导致无法触发idle，所以一直卡在LOGO界面</p>
<p>在wms中的performEnableScreen<br>调用ams的bootAnimationComplete 在此时会将mBootAnimationComplete置为true，如果mCallFinishBooting是true就会执行finishBooting<br>在finishBooting中又将mCallFinishBooting置为false，然后进行userunlock的操作<br>所以关键点就是<strong>只有mCallFinishBooting为true的时候才会执行userunlock</strong>（即在mBootAnimationComplete&#x3D;false的情况下调用一次finishBooting）</p>
<p>正常情况下，在Activity resume的时候就会触发一次idle，然后调用checkFinishBootingLocked去调用atms中的postFinishBooting，最终调用到ams的finishBooting</p>
<p>加log排查后发现，在idle中mService.isBooting()是false，所以没走checkFinishBootingLocked的逻辑，也就没有将mCallFinishBooting置为true<br>排查isBooting所有的赋值点，在systemReady之前isBooting为false，以及只有在AMS中的ensureBootCompleted()会将其置为false，<br>而在app crash 和 ANR时都会触发ensureBootCompleted(),<br>最后排查，确实在userunlock之前，carservice crash了，booting被异常终止，导致开机流程没有完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">            case SHOW_ERROR_UI_MSG: &#123;</span><br><span class="line">                mAppErrors.handleShowAppErrorUi(msg);</span><br><span class="line">                ensureBootCompleted();</span><br><span class="line">            &#125; break;</span><br><span class="line">            case SHOW_NOT_RESPONDING_UI_MSG: &#123;</span><br><span class="line">                mAppErrors.handleShowAnrUi(msg);</span><br><span class="line">                ensureBootCompleted();</span><br><span class="line">            &#125; break;</span><br><span class="line"></span><br><span class="line">final void ensureBootCompleted() &#123;</span><br><span class="line">    boolean booting;</span><br><span class="line">    boolean enableScreen;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        booting = mBooting;</span><br><span class="line">        mBooting = false;</span><br><span class="line">        enableScreen = !mBooted;</span><br><span class="line">        mBooted = true;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果在ensureBootCompleted时，mBooting是true就会执行finishBooting</span><br><span class="line">    if (booting) &#123;</span><br><span class="line">        finishBooting();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (enableScreen) &#123;</span><br><span class="line">        mAtmInternal.enableScreenAfterBoot(mBooted);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                </span><br></pre></td></tr></table></figure>

<p>根据以上信息，<br>在ensureBootCompleted时，mBooting是true就会执行finishBooting，即在systemReady之后第一次触发ensureBootCompleted时会调用finishBooting<br>在idle时，mBooting是true就会执行checkFinishBootingLocked，即即在systemReady之后第一次触发idle时会调用finishBooting</p>
<p>systemReady的关键log：<code>System now ready</code>, 在<code>startPersistentApps</code>后会去将mBooting置为true</p>
<p>所以正常的log<br><code>grep -rniE &quot; wm_| uc_|FinishBooting|startPersistentApps|System now ready&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityManager: System now ready           </span><br><span class="line">SystemServerTiming: startPersistentApps     mBooting=true</span><br><span class="line">wm_on_top_resumed_gained_called:            FallbackHome onResume</span><br><span class="line">ActivityManagerTiming: FinishBooting        idle或ensureBootCompleted 触发FinishBooting，会将mCallFinishBooting置为true</span><br><span class="line">wm_boot_animation_done:                     wms的performEnableScreen()触发AMS的bootAnimationComplete(),会将mBootAnimationComplete置为true，并且mCallFinishBooting为true会再次调用FinishBooting</span><br><span class="line"></span><br><span class="line">ActivityManagerTiming: FinishBooting        第二次FinishBooting，mBootAnimationComplete为true，走userunlock流程</span><br><span class="line">uc_finish_user_boot:</span><br><span class="line">uc_finish_user_unlocking: </span><br><span class="line">uc_finish_user_unlocked:</span><br></pre></td></tr></table></figure>

<p>userunlock是在FinishBooting中，需要mBootAnimationComplete为true才触发逻辑，所以正常log中 wm_boot_animation_done之后触发FinishBooting</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wm_boot_animation_done</span><br><span class="line">ActivityManagerTiming: FinishBooting</span><br></pre></td></tr></table></figure>





<p>wms performEnableScreen()<br>wms enableScreenAfterBoot()  performBootTimeout()</p>
<p>ATMS                    startHomeActivity(int userId, String reason)<br>RootWindowContainer     startHomeOnDisplay startHomeOnTaskDisplayArea<br>ActivityStartController startHomeActivity(Intent intent, ActivityInfo aInfo, String reason,TaskDisplayArea taskDisplayArea)</p>
<p>在ATMS中获取到的HomeIntent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String mTopAction = Intent.ACTION_MAIN;</span><br><span class="line">Intent getHomeIntent() &#123;</span><br><span class="line">    Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);</span><br><span class="line">    intent.setComponent(mTopComponent);</span><br><span class="line">    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);</span><br><span class="line">    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">    &#125;</span><br><span class="line">    return intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在RootWindowContainer中去找对应的组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    if (taskDisplayArea == getDefaultTaskDisplayArea()) &#123;</span><br><span class="line">        homeIntent = mService.getHomeIntent();</span><br><span class="line">        aInfo = resolveHomeActivity(userId, homeIntent);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@VisibleForTesting</span><br><span class="line">ActivityInfo resolveHomeActivity(int userId, Intent homeIntent) &#123;</span><br><span class="line">    final int flags = ActivityManagerService.STOCK_PM_FLAGS;</span><br><span class="line">    final ComponentName comp = homeIntent.getComponent();</span><br><span class="line">    ActivityInfo aInfo = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (comp != null) &#123;</span><br><span class="line">            // Factory test.</span><br><span class="line">            aInfo = AppGlobals.getPackageManager().getActivityInfo(comp, flags, userId);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final String resolvedType =</span><br><span class="line">                    homeIntent.resolveTypeIfNeeded(mService.mContext.getContentResolver());</span><br><span class="line">            final ResolveInfo info = AppGlobals.getPackageManager()</span><br><span class="line">                    .resolveIntent(homeIntent, resolvedType, flags, userId);</span><br><span class="line">            if (info != null) &#123;</span><br><span class="line">                aInfo = info.activityInfo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        // ignore</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (aInfo == null) &#123;</span><br><span class="line">        Slog.wtf(TAG, &quot;No home screen found for &quot; + homeIntent, new Throwable());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aInfo = new ActivityInfo(aInfo);</span><br><span class="line">    aInfo.applicationInfo = mService.getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line">    return aInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ams systemReady中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mAtmInternal.startHomeOnAllDisplays(currentUserId, &quot;systemReady&quot;);</span><br></pre></td></tr></table></figure>
<p>在 ActivityStack的resumeNextFocusableActivityWhenStackIsEmpty中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean resumeNextFocusableActivityWhenStackIsEmpty(ActivityRecord prev,</span><br><span class="line">        ActivityOptions options) &#123;</span><br><span class="line">    final String reason = &quot;noMoreActivities&quot;;</span><br><span class="line"></span><br><span class="line">    if (!isActivityTypeHome()) &#123;</span><br><span class="line">        final ActivityStack nextFocusedStack = adjustFocusToNextFocusableTask(reason);</span><br><span class="line">        if (nextFocusedStack != null) &#123;</span><br><span class="line">            // Try to move focus to the next visible stack with a running activity if this</span><br><span class="line">            // stack is not covering the entire screen or is on a secondary display with no home</span><br><span class="line">            // stack.</span><br><span class="line">            return mRootWindowContainer.resumeFocusedStacksTopActivities(nextFocusedStack,</span><br><span class="line">                    prev, null /* targetOptions */);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the current stack is a home stack, or if focus didn&#x27;t switch to a different stack -</span><br><span class="line">    // just start up the Launcher...</span><br><span class="line">    ActivityOptions.abort(options);</span><br><span class="line">    if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">            &quot;resumeNextFocusableActivityWhenStackIsEmpty: &quot; + reason + &quot;, go home&quot;);</span><br><span class="line">    return mRootWindowContainer.resumeHomeActivity(prev, reason, getDisplayArea());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>init进程</title>
    <url>/2023/11/13/android_fw/00.init/</url>
    <content><![CDATA[<p>基于Android11重新梳理一下Android的启动流程。</p>
<ol>
<li>当按下电源时，引导芯片代码从预定义的地方(固化在ROM)开始执行，加载引导程序BootLoader到RAM，然后执行</li>
<li>BootLoader创建Android中的第一个进程idle(pid&#x3D;0);</li>
<li>idle进程创建后中做了初始化进程管理、内存管理、加载Binder Driver、Display、Camera Driver等相关工作，并创建了以下两个进程(线程)，干完这些工作之后idle进程就空闲下来了。<ul>
<li>创建kthread（pid&#x3D;2）线程，在其中创建kworker线程，软中断线程ksoftirqd，thermal守护线程（kernel中没有进程线程之分），内核线程鼻祖。</li>
<li>init（pid&#x3D;1）进程，它是用户空间的第一个进程，由此开始后面创建的进程都是由init或其子进程fork而来。</li>
</ul>
</li>
</ol>
<p>当kernel启动后会去启动init进程,在<code>kernel/msm-5.4/init/main.c</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int run_init_process(const char *init_filename)</span><br><span class="line">&#123;</span><br><span class="line">	argv_init[0] = init_filename;</span><br><span class="line">	pr_info(&quot;Run %s as init process\n&quot;, init_filename);</span><br><span class="line">	return do_execve(getname_kernel(init_filename),</span><br><span class="line">		(const char __user *const __user *)argv_init,</span><br><span class="line">		(const char __user *const __user *)envp_init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int try_to_run_init_process(const char *init_filename)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	ret = run_init_process(init_filename);</span><br><span class="line"></span><br><span class="line">	if (ret &amp;&amp; ret != -ENOENT) &#123;</span><br><span class="line">		pr_err(&quot;Starting init: %s exists but couldn&#x27;t execute it (error %d)\n&quot;,</span><br><span class="line">		       init_filename, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __ref kernel_init(void *unused)</span><br><span class="line">&#123;</span><br><span class="line">	//......</span><br><span class="line">    //去尝试各个路径下的init可执行文件</span><br><span class="line">	if (!try_to_run_init_process(&quot;/sbin/init&quot;) ||</span><br><span class="line">	    !try_to_run_init_process(&quot;/etc/init&quot;) ||</span><br><span class="line">	    !try_to_run_init_process(&quot;/bin/init&quot;) ||</span><br><span class="line">	    !try_to_run_init_process(&quot;/bin/sh&quot;))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	panic(&quot;No working init found.  Try passing init= option to kernel. &quot;</span><br><span class="line">	      &quot;See Linux Documentation/admin-guide/init.rst for guidance.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>init的源码在<code>system/core/init</code>下面,主要看一下init的main函数入口（main.cpp中），第一次运行init参数为空，<br>在init中有逻辑会再次传参调用init：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">#if __has_feature(address_sanitizer)</span><br><span class="line">    __asan_set_error_report_callback(AsanReportCallback);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) &#123;</span><br><span class="line">        return ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (argc &gt; 1) &#123;</span><br><span class="line">        if (!strcmp(argv[1], &quot;subcontext&quot;)) &#123;</span><br><span class="line">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class="line">            const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line"></span><br><span class="line">            return SubcontextMain(argc, argv, &amp;function_map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第二次进入</span><br><span class="line">        if (!strcmp(argv[1], &quot;selinux_setup&quot;)) &#123;</span><br><span class="line">            return SetupSelinux(argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第三次进入</span><br><span class="line">        if (!strcmp(argv[1], &quot;second_stage&quot;)) &#123;</span><br><span class="line">            return SecondStageMain(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 第一次进入 （参数为空）</span><br><span class="line">    return FirstStageMain(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>first_stage_init.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int FirstStageMain(int argc, char** argv) &#123;</span><br><span class="line">    if (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class="line">        InstallRebootSignalHandlers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boot_clock::time_point start_time = boot_clock::now();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;std::string, int&gt;&gt; errors;</span><br><span class="line">#define CHECKCALL(x) \</span><br><span class="line">    if ((x) != 0) errors.emplace_back(#x &quot; failed&quot;, errno);</span><br><span class="line"></span><br><span class="line">    // Clear the umask.</span><br><span class="line">    umask(0);</span><br><span class="line"></span><br><span class="line">    //清理环境变量，并重新设置</span><br><span class="line">    CHECKCALL(clearenv());</span><br><span class="line">    CHECKCALL(setenv(&quot;PATH&quot;, _PATH_DEFPATH, 1));</span><br><span class="line"></span><br><span class="line">    //挂载创建需要的目录</span><br><span class="line">    // Get the basic filesystem setup we need put together in the initramdisk</span><br><span class="line">    // on / and then we&#x27;ll let the rc file figure out the rest.</span><br><span class="line">    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;));</span><br><span class="line">    CHECKCALL(mkdir(&quot;/dev/pts&quot;, 0755));</span><br><span class="line">    CHECKCALL(mkdir(&quot;/dev/socket&quot;, 0755));</span><br><span class="line">    CHECKCALL(mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL));</span><br><span class="line">    //......</span><br><span class="line">#undef CHECKCALL</span><br><span class="line"></span><br><span class="line">    //将标准输入输出重定向到 /dev/null</span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    //初始化内核log</span><br><span class="line">    // Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually</span><br><span class="line">    // talk to the outside world...</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">    if (!errors.empty()) &#123;</span><br><span class="line">        for (const auto&amp; [error_string, error_errno] : errors) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; error_string &lt;&lt; &quot; &quot; &lt;&lt; strerror(error_errno);</span><br><span class="line">        &#125;</span><br><span class="line">        LOG(FATAL) &lt;&lt; &quot;Init encountered errors starting first stage, aborting&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里有个log表示 init 第一个阶段启动完成</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;init first stage started!&quot;;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    if (ForceNormalBoot(cmdline)) &#123;</span><br><span class="line">        mkdir(&quot;/first_stage_ramdisk&quot;, 0755);</span><br><span class="line">        // SwitchRoot() must be called with a mount point as the target, so we bind mount the</span><br><span class="line">        // target directory to itself here.</span><br><span class="line">        if (mount(&quot;/first_stage_ramdisk&quot;, &quot;/first_stage_ramdisk&quot;, nullptr, MS_BIND, nullptr) != 0) &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; &quot;Could not bind mount /first_stage_ramdisk to itself&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        SwitchRoot(&quot;/first_stage_ramdisk&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If this file is present, the second-stage init will use a userdebug sepolicy</span><br><span class="line">    // and load adb_debug.prop to allow adb root, if the device is unlocked.</span><br><span class="line">    if (access(&quot;/force_debuggable&quot;, F_OK) == 0) &#123;</span><br><span class="line">        std::error_code ec;  // to invoke the overloaded copy_file() that won&#x27;t throw.</span><br><span class="line">        if (!fs::copy_file(&quot;/adb_debug.prop&quot;, kDebugRamdiskProp, ec) ||</span><br><span class="line">            !fs::copy_file(&quot;/userdebug_plat_sepolicy.cil&quot;, kDebugRamdiskSEPolicy, ec)) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;Failed to setup debug ramdisk&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // setenv for second-stage init to read above kDebugRamdisk* files.</span><br><span class="line">            setenv(&quot;INIT_FORCE_DEBUGGABLE&quot;, &quot;true&quot;, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!DoFirstStageMount()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; &quot;Failed to mount required partitions early ...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct stat new_root_info;</span><br><span class="line">    if (stat(&quot;/&quot;, &amp;new_root_info) != 0) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;Could not stat(\&quot;/\&quot;), not freeing ramdisk&quot;;</span><br><span class="line">        old_root_dir.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (old_root_dir &amp;&amp; old_root_info.st_dev != new_root_info.st_dev) &#123;</span><br><span class="line">        FreeRamdisk(old_root_dir.get(), old_root_info.st_dev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetInitAvbVersionInRecovery();</span><br><span class="line"></span><br><span class="line">    setenv(kEnvFirstStageStartedAt, std::to_string(start_time.time_since_epoch().count()).c_str(),</span><br><span class="line">           1);</span><br><span class="line"></span><br><span class="line">    //这里会再次去执行init</span><br><span class="line">    const char* path = &quot;/system/bin/init&quot;;</span><br><span class="line">    const char* args[] = &#123;path, &quot;selinux_setup&quot;, nullptr&#125;;</span><br><span class="line">    auto fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line">    close(fd);</span><br><span class="line">    execv(path, const_cast&lt;char**&gt;(args));</span><br><span class="line"></span><br><span class="line">    // execv() only returns if an error happened, in which case we</span><br><span class="line">    // panic and never fall through this conditional.</span><br><span class="line">    PLOG(FATAL) &lt;&lt; &quot;execv(\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;) failed&quot;;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>selinux.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int SetupSelinux(char** argv) &#123;</span><br><span class="line">    //将标准输入输出重定向到 /dev/null</span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    //初始化内核log</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">    if (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class="line">        InstallRebootSignalHandlers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boot_clock::time_point start_time = boot_clock::now();</span><br><span class="line"></span><br><span class="line">    MountMissingSystemPartitions();</span><br><span class="line"></span><br><span class="line">    //初始化selinux的log</span><br><span class="line">    // Set up SELinux, loading the SELinux policy.</span><br><span class="line">    SelinuxSetupKernelLogging();</span><br><span class="line">    //加载Selinux策略 方法内有log “Loading SELinux policy”</span><br><span class="line">    SelinuxInitialize();</span><br><span class="line"></span><br><span class="line">    // We&#x27;re in the kernel domain and want to transition to the init domain.  File systems that</span><br><span class="line">    // store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here,</span><br><span class="line">    // but other file systems do.  In particular, this is needed for ramdisks such as the</span><br><span class="line">    // recovery image for A/B devices.</span><br><span class="line">    if (selinux_android_restorecon(&quot;/system/bin/init&quot;, 0) == -1) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; &quot;restorecon failed of /system/bin/init failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setenv(kEnvSelinuxStartedAt, std::to_string(start_time.time_since_epoch().count()).c_str(), 1);</span><br><span class="line"></span><br><span class="line">    //这里又去执行 init </span><br><span class="line">    const char* path = &quot;/system/bin/init&quot;;</span><br><span class="line">    const char* args[] = &#123;path, &quot;second_stage&quot;, nullptr&#125;;</span><br><span class="line">    execv(path, const_cast&lt;char**&gt;(args));</span><br><span class="line"></span><br><span class="line">    // execv() only returns if an error happened, in which case we</span><br><span class="line">    // panic and never return from this function.</span><br><span class="line">    PLOG(FATAL) &lt;&lt; &quot;execv(\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;) failed&quot;;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int SecondStageMain(int argc, char** argv) &#123;</span><br><span class="line">    if (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class="line">        InstallRebootSignalHandlers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boot_clock::time_point start_time = boot_clock::now();</span><br><span class="line"></span><br><span class="line">    trigger_shutdown = [](const std::string&amp; command) &#123; shutdown_state.TriggerShutdown(command); &#125;;</span><br><span class="line"></span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;init second stage started!&quot;;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    //初始化属性服务</span><br><span class="line">    PropertyInit();</span><br><span class="line"></span><br><span class="line">    // Umount the debug ramdisk after property service has read the .prop files when it means to.</span><br><span class="line">    if (load_debug_prop) &#123;</span><br><span class="line">        UmountDebugRamdisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Mount extra filesystems required during second stage init</span><br><span class="line">    MountExtraFilesystems();</span><br><span class="line"></span><br><span class="line">    // Now set up SELinux for second stage.</span><br><span class="line">    SelinuxSetupKernelLogging();</span><br><span class="line">    SelabelInitialize();</span><br><span class="line">    SelinuxRestoreContext();</span><br><span class="line"></span><br><span class="line">    Epoll epoll;</span><br><span class="line">    if (auto result = epoll.Open(); !result.ok()) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InstallSignalFdHandler(&amp;epoll);</span><br><span class="line">    InstallInitNotifier(&amp;epoll);</span><br><span class="line">    StartPropertyService(&amp;property_fd);</span><br><span class="line"></span><br><span class="line">    // Make the time that init stages started available for bootstat to log.</span><br><span class="line">    RecordStageBoottimes(start_time);</span><br><span class="line"></span><br><span class="line">    // Set libavb version for Framework-only OTA match in Treble build.</span><br><span class="line">    if (const char* avb_version = getenv(&quot;INIT_AVB_VERSION&quot;); avb_version != nullptr) &#123;</span><br><span class="line">        SetProperty(&quot;ro.boot.avb_version&quot;, avb_version);</span><br><span class="line">    &#125;</span><br><span class="line">    unsetenv(&quot;INIT_AVB_VERSION&quot;);</span><br><span class="line"></span><br><span class="line">    fs_mgr_vendor_overlay_mount_all();</span><br><span class="line">    export_oem_lock_status();</span><br><span class="line">    MountHandler mount_handler(&amp;epoll);</span><br><span class="line">    SetUsbController();</span><br><span class="line"></span><br><span class="line">    const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line"></span><br><span class="line">    if (!SetupMountNamespaces()) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; &quot;SetupMountNamespaces failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InitializeSubcontext();</span><br><span class="line"></span><br><span class="line">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class="line"></span><br><span class="line">    //这里就是去加载解析rc文件</span><br><span class="line">    LoadBootScripts(am, sm);</span><br><span class="line"></span><br><span class="line">    // Turning this on and letting the INFO logging be discarded adds 0.2s to</span><br><span class="line">    // Nexus 9 boot time, so it&#x27;s disabled by default.</span><br><span class="line">    if (false) DumpState();</span><br><span class="line"></span><br><span class="line">    // Make the GSI status available before scripts start running.</span><br><span class="line">    auto is_running = android::gsi::IsGsiRunning() ? &quot;1&quot; : &quot;0&quot;;</span><br><span class="line">    SetProperty(gsi::kGsiBootedProp, is_running);</span><br><span class="line">    auto is_installed = android::gsi::IsGsiInstalled() ? &quot;1&quot; : &quot;0&quot;;</span><br><span class="line">    SetProperty(gsi::kGsiInstalledProp, is_installed);</span><br><span class="line"></span><br><span class="line">    am.QueueBuiltinAction(SetupCgroupsAction, &quot;SetupCgroups&quot;);</span><br><span class="line">    am.QueueBuiltinAction(SetKptrRestrictAction, &quot;SetKptrRestrict&quot;);</span><br><span class="line">    am.QueueBuiltinAction(TestPerfEventSelinuxAction, &quot;TestPerfEventSelinux&quot;);</span><br><span class="line">    am.QueueEventTrigger(&quot;early-init&quot;);</span><br><span class="line"></span><br><span class="line">    // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span><br><span class="line">    am.QueueBuiltinAction(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;);</span><br><span class="line">    // ... so that we can start queuing up actions that require stuff from /dev.</span><br><span class="line">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, &quot;MixHwrngIntoLinuxRng&quot;);</span><br><span class="line">    am.QueueBuiltinAction(SetMmapRndBitsAction, &quot;SetMmapRndBits&quot;);</span><br><span class="line">    Keychords keychords;</span><br><span class="line">    am.QueueBuiltinAction(</span><br><span class="line">            [&amp;epoll, &amp;keychords](const BuiltinArguments&amp; args) -&gt; Result&lt;void&gt; &#123;</span><br><span class="line">                for (const auto&amp; svc : ServiceList::GetInstance()) &#123;</span><br><span class="line">                    keychords.Register(svc-&gt;keycodes());</span><br><span class="line">                &#125;</span><br><span class="line">                keychords.Start(&amp;epoll, HandleKeychord);</span><br><span class="line">                return &#123;&#125;;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;KeychordInit&quot;);</span><br><span class="line"></span><br><span class="line">    // Trigger all the boot actions to get us started.</span><br><span class="line">    am.QueueEventTrigger(&quot;init&quot;);</span><br><span class="line"></span><br><span class="line">    // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span><br><span class="line">    // wasn&#x27;t ready immediately after wait_for_coldboot_done</span><br><span class="line">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, &quot;MixHwrngIntoLinuxRng&quot;);</span><br><span class="line"></span><br><span class="line">    // Don&#x27;t mount filesystems or start core system services in charger mode.</span><br><span class="line">    std::string bootmode = GetProperty(&quot;ro.bootmode&quot;, &quot;&quot;);</span><br><span class="line">    if (bootmode == &quot;charger&quot;) &#123;</span><br><span class="line">        am.QueueEventTrigger(&quot;charger&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        am.QueueEventTrigger(&quot;late-init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Run all property triggers based on current state of the properties.</span><br><span class="line">    am.QueueBuiltinAction(queue_property_triggers_action, &quot;queue_property_triggers&quot;);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // By default, sleep until something happens.</span><br><span class="line">        auto epoll_timeout = std::optional&lt;std::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        auto shutdown_command = shutdown_state.CheckShutdown();</span><br><span class="line">        if (shutdown_command) &#123;</span><br><span class="line">            HandlePowerctlMessage(*shutdown_command);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!IsShuttingDown()) &#123;</span><br><span class="line">            auto next_process_action_time = HandleProcessActions();</span><br><span class="line"></span><br><span class="line">            // If there&#x27;s a process that needs restarting, wake up in time for that.</span><br><span class="line">            if (next_process_action_time) &#123;</span><br><span class="line">                epoll_timeout = std::chrono::ceil&lt;std::chrono::milliseconds&gt;(</span><br><span class="line">                        *next_process_action_time - boot_clock::now());</span><br><span class="line">                if (*epoll_timeout &lt; 0ms) epoll_timeout = 0ms;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            // If there&#x27;s more work to do, wake up again immediately.</span><br><span class="line">            if (am.HasMoreCommands()) epoll_timeout = 0ms;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        auto pending_functions = epoll.Wait(epoll_timeout);</span><br><span class="line">        if (!pending_functions.ok()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; pending_functions.error();</span><br><span class="line">        &#125; else if (!pending_functions-&gt;empty()) &#123;</span><br><span class="line">            // We always reap children before responding to the other pending functions. This is to</span><br><span class="line">            // prevent a race where other daemons see that a service has exited and ask init to</span><br><span class="line">            // start it again via ctl.start before init has reaped it.</span><br><span class="line">            ReapAnyOutstandingChildren();</span><br><span class="line">            for (const auto&amp; function : *pending_functions) &#123;</span><br><span class="line">                (*function)();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!IsShuttingDown()) &#123;</span><br><span class="line">            HandleControlMessages();</span><br><span class="line">            SetUsbController();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<p>参考 ： <a href="https://blog.csdn.net/qq_27246079/article/details/129995924">Android系统启动流程–init进程的启动流程</a></p>
<h2 id="关键log梳理"><a href="#关键log梳理" class="headerlink" title="关键log梳理"></a>关键log梳理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. init第一阶段启动完成（初始化了环境变量，挂载了一些必要的文件目录，初始化kernel日志）</span><br><span class="line">init    : init first stage started!</span><br><span class="line"></span><br><span class="line">2. init进程去初始化selinux policy</span><br><span class="line">init    : Loading SELinux policy</span><br><span class="line"></span><br><span class="line">3. init第二阶段启动完成（这个log点只是把kernel日志给初始化完成）</span><br><span class="line">init    : init second stage started!</span><br><span class="line"></span><br><span class="line">4.初始化设备节点</span><br><span class="line">ueventd : ueventd started!</span><br></pre></td></tr></table></figure>

<h2 id="对init-rc文件的解析"><a href="#对init-rc文件的解析" class="headerlink" title="对init.rc文件的解析"></a>对init.rc文件的解析</h2><p>在源码中可以找到一个init.rc文件，可以看到在 on late-init这个section中,有触发zygote-start，trigger关键字做的事情不清楚，但解析on关键字的是ActionParser，先去看看这个源码</p>
<p>对rc文件中on关键字开始的section进行解析时，section中支持的function在system&#x2F;core&#x2F;init&#x2F;builtins.cpp中的<a href="http://aospxref.com/android-11.0.0_r21/xref/system/core/init/builtins.cpp?fi=GetBuiltinFunctionMap#GetBuiltinFunctionMap">GetBuiltinFunctionMap</a>方法中有定义,在对action进行<a href="http://aospxref.com/android-11.0.0_r21/xref/system/core/init/action.cpp#111">AddCommand</a>时，会根据functionMap进行校验，不合法的会error</p>
<p>对rc文件中的service关键字开始的section进行解析时，service支持的option在system&#x2F;core&#x2F;init&#x2F;service_parser.cpp的<a href="http://aospxref.com/android-11.0.0_r21/xref/system/core/init/service_parser.cpp#502">GetParserMap</a>中有定义。</p>
<h2 id="StartPropertyService"><a href="#StartPropertyService" class="headerlink" title="StartPropertyService"></a>StartPropertyService</h2><p>在init第二阶段会去初始化属性服务，并启动，<br>初始化属性服务时，会去加载&#x2F;default.prop,&#x2F;system&#x2F;build.prop等目录下的属性值，后面的会覆盖前面的值<br>启动属性服务时，创建Socket进行监听，最终调用HandlePropertySet来处理property<br>“ctl.”开始的属性会去启动服务<br>sys.powerctl 是控制关机&#x2F;重启的<br>所有的property最终都是通过init进程设置的，init进程对各种property进行了权限把控</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int SecondStageMain(int argc, char** argv) &#123;</span><br><span class="line"></span><br><span class="line">    PropertyInit();</span><br><span class="line">    //....</span><br><span class="line">    StartPropertyService(&amp;property_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>property_service.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void StartPropertyService(int* epoll_socket) &#123;</span><br><span class="line">    InitPropertySet(&quot;ro.property_service.version&quot;, &quot;2&quot;);</span><br><span class="line"></span><br><span class="line">    int sockets[2];</span><br><span class="line">    if (socketpair(AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, sockets) != 0) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; &quot;Failed to socketpair() between property_service and init&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    *epoll_socket = from_init_socket = sockets[0];</span><br><span class="line">    init_socket = sockets[1];</span><br><span class="line">    StartSendingMessages();</span><br><span class="line"></span><br><span class="line">    //这里去创建了socket</span><br><span class="line">    if (auto result = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,</span><br><span class="line">                                   false, 0666, 0, 0, &#123;&#125;);</span><br><span class="line">        result.ok()) &#123;</span><br><span class="line">        property_set_fd = *result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; &quot;start_property_service socket creation failed: &quot; &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listen(property_set_fd, 8);</span><br><span class="line"></span><br><span class="line">    //开启线程处理</span><br><span class="line">    auto new_thread = std::thread&#123;PropertyServiceThread&#125;;</span><br><span class="line">    property_service_thread.swap(new_thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void PropertyServiceThread() &#123;</span><br><span class="line">    Epoll epoll;</span><br><span class="line">    if (auto result = epoll.Open(); !result.ok()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //监听socket对应fd的变化，通过handle_property_set_fd方法来处理</span><br><span class="line">    if (auto result = epoll.RegisterHandler(property_set_fd, handle_property_set_fd);</span><br><span class="line">        !result.ok()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (auto result = epoll.RegisterHandler(init_socket, HandleInitSocket); !result.ok()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        auto pending_functions = epoll.Wait(std::nullopt);</span><br><span class="line">        if (!pending_functions.ok()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; pending_functions.error();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (const auto&amp; function : *pending_functions) &#123;</span><br><span class="line">                (*function)();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void handle_property_set_fd() &#123;</span><br><span class="line">    static constexpr uint32_t kDefaultSocketTimeout = 2000; /* ms */</span><br><span class="line"></span><br><span class="line">    int s = accept4(property_set_fd, nullptr, nullptr, SOCK_CLOEXEC);</span><br><span class="line">    if (s == -1) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ucred cr;</span><br><span class="line">    socklen_t cr_size = sizeof(cr);</span><br><span class="line">    if (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; 0) &#123;</span><br><span class="line">        close(s);</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;sys_prop: unable to get SO_PEERCRED&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SocketConnection socket(s, cr);</span><br><span class="line">    uint32_t timeout_ms = kDefaultSocketTimeout;</span><br><span class="line"></span><br><span class="line">    uint32_t cmd = 0;</span><br><span class="line">    if (!socket.RecvUint32(&amp;cmd, &amp;timeout_ms)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;sys_prop: error while reading command from the socket&quot;;</span><br><span class="line">        socket.SendUint32(PROP_ERROR_READ_CMD);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (cmd) &#123;</span><br><span class="line">    case PROP_MSG_SETPROP: &#123;</span><br><span class="line">        char prop_name[PROP_NAME_MAX];</span><br><span class="line">        char prop_value[PROP_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">        if (!socket.RecvChars(prop_name, PROP_NAME_MAX, &amp;timeout_ms) ||</span><br><span class="line">            !socket.RecvChars(prop_value, PROP_VALUE_MAX, &amp;timeout_ms)) &#123;</span><br><span class="line">          PLOG(ERROR) &lt;&lt; &quot;sys_prop(PROP_MSG_SETPROP): error while reading name/value from the socket&quot;;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prop_name[PROP_NAME_MAX-1] = 0;</span><br><span class="line">        prop_value[PROP_VALUE_MAX-1] = 0;</span><br><span class="line"></span><br><span class="line">        std::string source_context;</span><br><span class="line">        if (!socket.GetSourceContext(&amp;source_context)) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; &quot;Unable to set property &#x27;&quot; &lt;&lt; prop_name &lt;&lt; &quot;&#x27;: getpeercon() failed&quot;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const auto&amp; cr = socket.cred();</span><br><span class="line">        std::string error;</span><br><span class="line">        uint32_t result =</span><br><span class="line">                HandlePropertySet(prop_name, prop_value, source_context, cr, nullptr, &amp;error);</span><br><span class="line">        if (result != PROP_SUCCESS) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;Unable to set property &#x27;&quot; &lt;&lt; prop_name &lt;&lt; &quot;&#x27; from uid:&quot; &lt;&lt; cr.uid</span><br><span class="line">                       &lt;&lt; &quot; gid:&quot; &lt;&lt; cr.gid &lt;&lt; &quot; pid:&quot; &lt;&lt; cr.pid &lt;&lt; &quot;: &quot; &lt;&lt; error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    case PROP_MSG_SETPROP2: &#123;</span><br><span class="line">        std::string name;</span><br><span class="line">        std::string value;</span><br><span class="line">        if (!socket.RecvString(&amp;name, &amp;timeout_ms) ||</span><br><span class="line">            !socket.RecvString(&amp;value, &amp;timeout_ms)) &#123;</span><br><span class="line">          PLOG(ERROR) &lt;&lt; &quot;sys_prop(PROP_MSG_SETPROP2): error while reading name/value from the socket&quot;;</span><br><span class="line">          socket.SendUint32(PROP_ERROR_READ_DATA);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string source_context;</span><br><span class="line">        if (!socket.GetSourceContext(&amp;source_context)) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; &quot;Unable to set property &#x27;&quot; &lt;&lt; name &lt;&lt; &quot;&#x27;: getpeercon() failed&quot;;</span><br><span class="line">            socket.SendUint32(PROP_ERROR_PERMISSION_DENIED);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const auto&amp; cr = socket.cred();</span><br><span class="line">        std::string error;</span><br><span class="line">        uint32_t result = HandlePropertySet(name, value, source_context, cr, &amp;socket, &amp;error);</span><br><span class="line">        if (result != PROP_SUCCESS) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;Unable to set property &#x27;&quot; &lt;&lt; name &lt;&lt; &quot;&#x27; from uid:&quot; &lt;&lt; cr.uid</span><br><span class="line">                       &lt;&lt; &quot; gid:&quot; &lt;&lt; cr.gid &lt;&lt; &quot; pid:&quot; &lt;&lt; cr.pid &lt;&lt; &quot;: &quot; &lt;&lt; error;</span><br><span class="line">        &#125;</span><br><span class="line">        socket.SendUint32(result);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;sys_prop: invalid command &quot; &lt;&lt; cmd;</span><br><span class="line">        socket.SendUint32(PROP_ERROR_INVALID_CMD);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// This returns one of the enum of PROP_SUCCESS or PROP_ERROR*.</span><br><span class="line">uint32_t HandlePropertySet(const std::string&amp; name, const std::string&amp; value,</span><br><span class="line">                           const std::string&amp; source_context, const ucred&amp; cr,</span><br><span class="line">                           SocketConnection* socket, std::string* error) &#123;</span><br><span class="line">    if (auto ret = CheckPermissions(name, value, source_context, cr, error); ret != PROP_SUCCESS) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //以ctl.开头的属性，会被解析成控制指令，会去根据指令来控制进程</span><br><span class="line">    if (StartsWith(name, &quot;ctl.&quot;)) &#123;</span><br><span class="line">        return SendControlMessage(name.c_str() + 4, value, cr.pid, socket, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // sys.powerctl is a special property that is used to make the device reboot.  We want to log</span><br><span class="line">    // any process that sets this property to be able to accurately blame the cause of a shutdown.</span><br><span class="line">    if (name == &quot;sys.powerctl&quot;) &#123;</span><br><span class="line">        std::string cmdline_path = StringPrintf(&quot;proc/%d/cmdline&quot;, cr.pid);</span><br><span class="line">        std::string process_cmdline;</span><br><span class="line">        std::string process_log_string;</span><br><span class="line">        if (ReadFileToString(cmdline_path, &amp;process_cmdline)) &#123;</span><br><span class="line">            // Since cmdline is null deliminated, .c_str() conveniently gives us just the process</span><br><span class="line">            // path.</span><br><span class="line">            process_log_string = StringPrintf(&quot; (%s)&quot;, process_cmdline.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;Received sys.powerctl=&#x27;&quot; &lt;&lt; value &lt;&lt; &quot;&#x27; from pid: &quot; &lt;&lt; cr.pid</span><br><span class="line">                  &lt;&lt; process_log_string;</span><br><span class="line">        if (value == &quot;reboot,userspace&quot; &amp;&amp; !is_userspace_reboot_supported().value_or(false)) &#123;</span><br><span class="line">            *error = &quot;Userspace reboot is not supported by this device&quot;;</span><br><span class="line">            return PROP_ERROR_INVALID_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If a process other than init is writing a non-empty value, it means that process is</span><br><span class="line">    // requesting that init performs a restorecon operation on the path specified by &#x27;value&#x27;.</span><br><span class="line">    // We use a thread to do this restorecon operation to prevent holding up init, as it may take</span><br><span class="line">    // a long time to complete.</span><br><span class="line">    if (name == kRestoreconProperty &amp;&amp; cr.pid != 1 &amp;&amp; !value.empty()) &#123;</span><br><span class="line">        static AsyncRestorecon async_restorecon;</span><br><span class="line">        async_restorecon.TriggerRestorecon(value);</span><br><span class="line">        return PROP_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return PropertySet(name, value, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过property进行进程重启"><a href="#通过property进行进程重启" class="headerlink" title="通过property进行进程重启"></a>通过property进行进程重启</h3><p>属性服务中会对ctl.开头的属性进行特殊处理,<br>会调用SendControlMessage将指令放在一个队列中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static uint32_t SendControlMessage(const std::string&amp; msg, const std::string&amp; name, pid_t pid,</span><br><span class="line">                                   SocketConnection* socket, std::string* error) &#123;</span><br><span class="line">    //......</span><br><span class="line">    //主要就是将指令包装成结构体，放到队列中</span><br><span class="line">    bool queue_success = QueueControlMessage(msg, name, pid, fd);</span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    return PROP_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">bool QueueControlMessage(const std::string&amp; message, const std::string&amp; name, pid_t pid, int fd) &#123;</span><br><span class="line">    auto lock = std::lock_guard&#123;pending_control_messages_lock&#125;;</span><br><span class="line">    if (pending_control_messages.size() &gt; 100) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;Too many pending control messages, dropped &#x27;&quot; &lt;&lt; message &lt;&lt; &quot;&#x27; for &#x27;&quot; &lt;&lt; name</span><br><span class="line">                   &lt;&lt; &quot;&#x27; from pid: &quot; &lt;&lt; pid;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    pending_control_messages.push(&#123;message, name, pid, fd&#125;);</span><br><span class="line">    WakeMainInitThread();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在init进程空闲的时候会去处理队列里的指令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int SecondStageMain(int argc, char** argv) &#123;</span><br><span class="line">    //......</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        //....</span><br><span class="line">        if (!IsShuttingDown()) &#123;</span><br><span class="line">            //每次都会去队列取一条指令来出俩</span><br><span class="line">            HandleControlMessages();</span><br><span class="line">            SetUsbController();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void HandleControlMessages() &#123;</span><br><span class="line">    auto lock = std::unique_lock&#123;pending_control_messages_lock&#125;;</span><br><span class="line">    // Init historically would only execute handle one property message, including control messages</span><br><span class="line">    // in each iteration of its main loop.  We retain this behavior here to prevent starvation of</span><br><span class="line">    // other actions in the main loop.</span><br><span class="line">    if (!pending_control_messages.empty()) &#123;</span><br><span class="line">        auto control_message = pending_control_messages.front();</span><br><span class="line">        pending_control_messages.pop();</span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">        bool success = HandleControlMessage(control_message.message, control_message.name,</span><br><span class="line">                                            control_message.pid);</span><br><span class="line"></span><br><span class="line">        uint32_t response = success ? PROP_SUCCESS : PROP_ERROR_HANDLE_CONTROL_MESSAGE;</span><br><span class="line">        if (control_message.fd != -1) &#123;</span><br><span class="line">            TEMP_FAILURE_RETRY(send(control_message.fd, &amp;response, sizeof(response), 0));</span><br><span class="line">            close(control_message.fd);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    // If we still have items to process, make sure we wake back up to do so.</span><br><span class="line">    if (!pending_control_messages.empty()) &#123;</span><br><span class="line">        WakeMainInitThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">static bool HandleControlMessage(std::string_view message, const std::string&amp; name,</span><br><span class="line">                                 pid_t from_pid) &#123;</span><br><span class="line">    std::string cmdline_path = StringPrintf(&quot;proc/%d/cmdline&quot;, from_pid);</span><br><span class="line">    std::string process_cmdline;</span><br><span class="line">    if (ReadFileToString(cmdline_path, &amp;process_cmdline)) &#123;</span><br><span class="line">        std::replace(process_cmdline.begin(), process_cmdline.end(), &#x27;\0&#x27;, &#x27; &#x27;);</span><br><span class="line">        process_cmdline = Trim(process_cmdline);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        process_cmdline = &quot;unknown process&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Service* service = nullptr;</span><br><span class="line">    auto action = message;</span><br><span class="line">    if (ConsumePrefix(&amp;action, &quot;interface_&quot;)) &#123;</span><br><span class="line">        service = ServiceList::GetInstance().FindInterface(name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        service = ServiceList::GetInstance().FindService(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (service == nullptr) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;Control message: Could not find &#x27;&quot; &lt;&lt; name &lt;&lt; &quot;&#x27; for ctl.&quot; &lt;&lt; message</span><br><span class="line">                   &lt;&lt; &quot; from pid: &quot; &lt;&lt; from_pid &lt;&lt; &quot; (&quot; &lt;&lt; process_cmdline &lt;&lt; &quot;)&quot;;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const auto&amp; map = GetControlMessageMap();</span><br><span class="line">    const auto it = map.find(action);</span><br><span class="line">    if (it == map.end()) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;Unknown control msg &#x27;&quot; &lt;&lt; message &lt;&lt; &quot;&#x27;&quot;;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const auto&amp; function = it-&gt;second;</span><br><span class="line"></span><br><span class="line">    if (auto result = function(service); !result.ok()) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;Control message: Could not ctl.&quot; &lt;&lt; message &lt;&lt; &quot; for &#x27;&quot; &lt;&lt; name</span><br><span class="line">                   &lt;&lt; &quot;&#x27; from pid: &quot; &lt;&lt; from_pid &lt;&lt; &quot; (&quot; &lt;&lt; process_cmdline</span><br><span class="line">                   &lt;&lt; &quot;): &quot; &lt;&lt; result.error();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Control message: Processed ctl.&quot; &lt;&lt; message &lt;&lt; &quot; for &#x27;&quot; &lt;&lt; name</span><br><span class="line">              &lt;&lt; &quot;&#x27; from pid: &quot; &lt;&lt; from_pid &lt;&lt; &quot; (&quot; &lt;&lt; process_cmdline &lt;&lt; &quot;)&quot;;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//支持的以ctl.开头的指令</span><br><span class="line">static const std::map&lt;std::string, ControlMessageFunction, std::less&lt;&gt;&gt;&amp; GetControlMessageMap() &#123;</span><br><span class="line">    // clang-format off</span><br><span class="line">    static const std::map&lt;std::string, ControlMessageFunction, std::less&lt;&gt;&gt; control_message_functions = &#123;</span><br><span class="line">        &#123;&quot;sigstop_on&quot;,        [](auto* service) &#123; service-&gt;set_sigstop(true); return Result&lt;void&gt;&#123;&#125;; &#125;&#125;,</span><br><span class="line">        &#123;&quot;sigstop_off&quot;,       [](auto* service) &#123; service-&gt;set_sigstop(false); return Result&lt;void&gt;&#123;&#125;; &#125;&#125;,</span><br><span class="line">        &#123;&quot;oneshot_on&quot;,        [](auto* service) &#123; service-&gt;set_oneshot(true); return Result&lt;void&gt;&#123;&#125;; &#125;&#125;,</span><br><span class="line">        &#123;&quot;oneshot_off&quot;,       [](auto* service) &#123; service-&gt;set_oneshot(false); return Result&lt;void&gt;&#123;&#125;; &#125;&#125;,</span><br><span class="line">        &#123;&quot;start&quot;,             DoControlStart&#125;,</span><br><span class="line">        &#123;&quot;stop&quot;,              DoControlStop&#125;,</span><br><span class="line">        &#123;&quot;restart&quot;,           DoControlRestart&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    // clang-format on</span><br><span class="line"></span><br><span class="line">    return control_message_functions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>ctl.start</code>和<code>ctl.stop</code>有进行指令封装,源码<code>system/core/toolbox/start.cpp</code><br>在shell中直接输入start&#x2F;stop 即可</p>
<h2 id="rc文件解析流程"><a href="#rc文件解析流程" class="headerlink" title="rc文件解析流程"></a>rc文件解析流程</h2><p>在SecondStageMain中开始解析rc的代码如下,<br>主要逻辑是先创建了3种SectionParser(ServiceParser对应关键字service,ActionParser对应关键字on,ImportParser对应关键字import),<br>将这3个保存在Parser的map对象中，<br>然后获取属性值<code>ro.boot.init_rc</code>，如果没有指定，那就读取默认的rc文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int SecondStageMain(int argc, char** argv) &#123;</span><br><span class="line">    //......</span><br><span class="line">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class="line"></span><br><span class="line">    LoadBootScripts(am, sm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void LoadBootScripts(ActionManager&amp; action_manager, ServiceList&amp; service_list) &#123;</span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class="line"></span><br><span class="line">    std::string bootscript = GetProperty(&quot;ro.boot.init_rc&quot;, &quot;&quot;);</span><br><span class="line">    if (bootscript.empty()) &#123;</span><br><span class="line">        parser.ParseConfig(&quot;/system/etc/init/hw/init.rc&quot;);</span><br><span class="line">        if (!parser.ParseConfig(&quot;/system/etc/init&quot;)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(&quot;/system/etc/init&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // late_import is available only in Q and earlier release. As we don&#x27;t</span><br><span class="line">        // have system_ext in those versions, skip late_import for system_ext.</span><br><span class="line">        parser.ParseConfig(&quot;/system_ext/etc/init&quot;);</span><br><span class="line">        if (!parser.ParseConfig(&quot;/product/etc/init&quot;)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(&quot;/product/etc/init&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!parser.ParseConfig(&quot;/odm/etc/init&quot;)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(&quot;/odm/etc/init&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!parser.ParseConfig(&quot;/vendor/etc/init&quot;)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(&quot;/vendor/etc/init&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        parser.ParseConfig(bootscript);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parser CreateParser(ActionManager&amp; action_manager, ServiceList&amp; service_list) &#123;</span><br><span class="line">    Parser parser;</span><br><span class="line"></span><br><span class="line">    parser.AddSectionParser(&quot;service&quot;, std::make_unique&lt;ServiceParser&gt;(</span><br><span class="line">                                               &amp;service_list, GetSubcontext(), std::nullopt));</span><br><span class="line">    parser.AddSectionParser(&quot;on&quot;, std::make_unique&lt;ActionParser&gt;(&amp;action_manager, GetSubcontext()));</span><br><span class="line">    parser.AddSectionParser(&quot;import&quot;, std::make_unique&lt;ImportParser&gt;(&amp;parser));</span><br><span class="line"></span><br><span class="line">    return parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在parser.cpp中看rc文件的解析细节，会去解析指定目录下的所有文件，最终调用ParseData来解析rc文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool Parser::ParseConfig(const std::string&amp; path) &#123;</span><br><span class="line">    if (is_dir(path.c_str())) &#123;</span><br><span class="line">        return ParseConfigDir(path);</span><br><span class="line">    &#125;</span><br><span class="line">    return ParseConfigFile(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Parser::ParseConfigFile(const std::string&amp; path) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Parsing file &quot; &lt;&lt; path &lt;&lt; &quot;...&quot;;</span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    auto config_contents = ReadFile(path);</span><br><span class="line">    if (!config_contents.ok()) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;Unable to read config file &#x27;&quot; &lt;&lt; path &lt;&lt; &quot;&#x27;: &quot; &lt;&lt; config_contents.error();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ParseData(path, &amp;config_contents.value());</span><br><span class="line"></span><br><span class="line">    LOG(VERBOSE) &lt;&lt; &quot;(Parsing &quot; &lt;&lt; path &lt;&lt; &quot; took &quot; &lt;&lt; t &lt;&lt; &quot;.)&quot;;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool Parser::ParseConfigFile(const std::string&amp; path) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Parsing file &quot; &lt;&lt; path &lt;&lt; &quot;...&quot;;</span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    auto config_contents = ReadFile(path);</span><br><span class="line">    if (!config_contents.ok()) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;Unable to read config file &#x27;&quot; &lt;&lt; path &lt;&lt; &quot;&#x27;: &quot; &lt;&lt; config_contents.error();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //这里去解析rc文件中具体内容</span><br><span class="line">    ParseData(path, &amp;config_contents.value());</span><br><span class="line"></span><br><span class="line">    LOG(VERBOSE) &lt;&lt; &quot;(Parsing &quot; &lt;&lt; path &lt;&lt; &quot; took &quot; &lt;&lt; t &lt;&lt; &quot;.)&quot;;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ParseData中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Parser::ParseData(const std::string&amp; filename, std::string* data) &#123;</span><br><span class="line">    data-&gt;push_back(&#x27;\n&#x27;);  // TODO: fix tokenizer</span><br><span class="line">    data-&gt;push_back(&#x27;\0&#x27;);</span><br><span class="line"></span><br><span class="line">    //用来保存解析状态（保存了当前行，rc文件中读取到的当前字符，下一个处理类型）</span><br><span class="line">    parse_state state;</span><br><span class="line">    state.line = 0;</span><br><span class="line">    state.ptr = data-&gt;data();</span><br><span class="line">    state.nexttoken = 0;</span><br><span class="line"></span><br><span class="line">    SectionParser* section_parser = nullptr;</span><br><span class="line">    int section_start_line = -1;</span><br><span class="line">    std::vector&lt;std::string&gt; args;</span><br><span class="line"></span><br><span class="line">    // If we encounter a bad section start, there is no valid parser object to parse the subsequent</span><br><span class="line">    // sections, so we must suppress errors until the next valid section is found.</span><br><span class="line">    bool bad_section_found = false;</span><br><span class="line"></span><br><span class="line">    auto end_section = [&amp;] &#123;</span><br><span class="line">        bad_section_found = false;</span><br><span class="line">        if (section_parser == nullptr) return;</span><br><span class="line"></span><br><span class="line">        if (auto result = section_parser-&gt;EndSection(); !result.ok()) &#123;</span><br><span class="line">            parse_error_count_++;</span><br><span class="line">            LOG(ERROR) &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; section_start_line &lt;&lt; &quot;: &quot; &lt;&lt; result.error();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        section_parser = nullptr;</span><br><span class="line">        section_start_line = -1;</span><br><span class="line">    &#125;;</span><br><span class="line">    //开始读取rc文件中的字符串</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //通过next_token来获取下一个处理类型</span><br><span class="line">        switch (next_token(&amp;state)) &#123;</span><br><span class="line">            //文件结尾</span><br><span class="line">            case T_EOF: </span><br><span class="line">                end_section();</span><br><span class="line"></span><br><span class="line">                for (const auto&amp; [section_name, section_parser] : section_parsers_) &#123;</span><br><span class="line">                    section_parser-&gt;EndFile();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return;</span><br><span class="line">            //新的一行</span><br><span class="line">            case T_NEWLINE: &#123;</span><br><span class="line">                state.line++;</span><br><span class="line">                if (args.empty()) break;</span><br><span class="line">                // If we have a line matching a prefix we recognize, call its callback and unset any</span><br><span class="line">                // current section parsers.  This is meant for /sys/ and /dev/ line entries for</span><br><span class="line">                // uevent.</span><br><span class="line">                //这里是解析的单行指令语法，用来解析ueventd.rc文件的</span><br><span class="line">                auto line_callback = std::find_if(</span><br><span class="line">                    line_callbacks_.begin(), line_callbacks_.end(),</span><br><span class="line">                    [&amp;args](const auto&amp; c) &#123; return android::base::StartsWith(args[0], c.first); &#125;);</span><br><span class="line">                if (line_callback != line_callbacks_.end()) &#123;</span><br><span class="line">                    end_section();</span><br><span class="line"></span><br><span class="line">                    if (auto result = line_callback-&gt;second(std::move(args)); !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; state.line &lt;&lt; &quot;: &quot; &lt;&lt; result.error();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (section_parsers_.count(args[0])) &#123;</span><br><span class="line">                    end_section();</span><br><span class="line">                    //这里才是根据第一个字符串，去取保存在map中的SectionParser</span><br><span class="line">                    section_parser = section_parsers_[args[0]].get();</span><br><span class="line">                    section_start_line = state.line;</span><br><span class="line">                    //解析这个Section</span><br><span class="line">                    if (auto result =</span><br><span class="line">                                section_parser-&gt;ParseSection(std::move(args), filename, state.line);</span><br><span class="line">                        !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; state.line &lt;&lt; &quot;: &quot; &lt;&lt; result.error();</span><br><span class="line">                        section_parser = nullptr;</span><br><span class="line">                        bad_section_found = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (section_parser) &#123;</span><br><span class="line">                    //继续用之前的SectionParser解析Section中的每一行</span><br><span class="line">                    if (auto result = section_parser-&gt;ParseLineSection(std::move(args), state.line);</span><br><span class="line">                        !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; state.line &lt;&lt; &quot;: &quot; &lt;&lt; result.error();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (!bad_section_found) &#123;</span><br><span class="line">                    parse_error_count_++;</span><br><span class="line">                    LOG(ERROR) &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; state.line</span><br><span class="line">                               &lt;&lt; &quot;: Invalid section keyword found&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                args.clear();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //读取到的是文本，保存到args中，在解析下一行的时候对文本解析</span><br><span class="line">            case T_TEXT:</span><br><span class="line">                args.emplace_back(state.text);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rc语法解析逻辑"><a href="#rc语法解析逻辑" class="headerlink" title="rc语法解析逻辑"></a>rc语法解析逻辑</h2><p>在system&#x2F;core&#x2F;init&#x2F;builtins.cpp中的<a href="http://aospxref.com/android-11.0.0_r21/xref/system/core/init/builtins.cpp?fi=GetBuiltinFunctionMap#GetBuiltinFunctionMap">GetBuiltinFunctionMap</a>方法中有定义</p>
<p>对rc文件中的service关键字开始的section进行解析时，service支持的option在system&#x2F;core&#x2F;init&#x2F;service_parser.cpp的<a href="http://aospxref.com/android-11.0.0_r21/xref/system/core/init/service_parser.cpp#502">GetParserMap</a>中有定义。</p>
<h2 id="rc语法笔记"><a href="#rc语法笔记" class="headerlink" title="rc语法笔记"></a>rc语法笔记</h2><p>在service.cpp的MakeTemporaryOneshotService有对exec指令的解析注释<br>exec [SECLABEL [UID [GID]*] –] COMMAND ARGS…<br>SECLABEL can be a - to denote default</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 以默认seclabel，system uid, system gid 执行 /system/bin/vdc checkpoint markBootAttempt</span><br><span class="line">exec - system system -- /system/bin/vdc checkpoint markBootAttempt</span><br><span class="line"># 以vendor_qti_init_shell身份运行/vendor/bin/init.qti.qcv.sh</span><br><span class="line">exec u:r:vendor_qti_init_shell:s0 -- /vendor/bin/init.qti.qcv.sh</span><br></pre></td></tr></table></figure>

<p>通过init去启动service，会有log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">starting service xxx ...</span><br></pre></td></tr></table></figure>

<p>通过ctrl.属性来进行控制时会有log</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Control message:</span><br></pre></td></tr></table></figure>

<h3 id="action相关逻辑"><a href="#action相关逻辑" class="headerlink" title="action相关逻辑"></a>action相关逻辑</h3><p>在加载rc文件之前，先通过Action::set_function_map静态方法设置了关键字和函数映射表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line">    //......</span><br><span class="line">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class="line"></span><br><span class="line">    LoadBootScripts(am, sm);</span><br><span class="line">    //......</span><br><span class="line">    am.QueueBuiltinAction(SetupCgroupsAction, &quot;SetupCgroups&quot;);</span><br><span class="line">    am.QueueBuiltinAction(SetKptrRestrictAction, &quot;SetKptrRestrict&quot;);</span><br><span class="line">    am.QueueBuiltinAction(TestPerfEventSelinuxAction, &quot;TestPerfEventSelinux&quot;);</span><br><span class="line">    am.QueueEventTrigger(&quot;early-init&quot;);</span><br><span class="line">    //......</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        //......</span><br><span class="line">        am.ExecuteOneCommand();</span><br><span class="line">        //......</span><br><span class="line">    &#125;    </span><br><span class="line">~~~   </span><br><span class="line">在action_parser中对on开头的section解析时，</span><br><span class="line">ParseSection中先构造action_，</span><br><span class="line">ParseLineSection中对action_的commands_向量进行赋值（AddCommand这个函数中会根据function_map进行校验，不合法的error）</span><br><span class="line">EndSection中会将解析好的action_添加到ActionManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### service常用关键字</span><br><span class="line">以adbd服务为例，</span><br><span class="line">在init进程去解析rc文件时，解析到service开头的一行，在Parser::ParseData中通过map找service关键字对应的ServiceParser，</span><br><span class="line">调用ServiceParser::ParseSection，args[1]是服务名称，后面的保存在args_字符串向量中，会在调用Service::Start()时进行解析</span><br></pre></td></tr></table></figure>
<p>service adbd &#x2F;system&#x2F;bin&#x2F;adbd –root_seclabel&#x3D;u:r:su:s0<br>    class core<br>    socket adbd seqpacket 660 system system<br>    disabled<br>    updatable<br>    seclabel u:r:adbd:s0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关于service的启动，</span><br><span class="line">一种通过action中的关键字start，可以在builtins.cpp的GetBuiltinFunctionMap中看到对应的action关键字-函数映射表，</span><br><span class="line">start关键字对应的函数就是去调用service的Start函数</span><br><span class="line"></span><br><span class="line">另一种通过指定class来启动，在init进程中会去触发class_start的action，class_start对应的函数逻辑就是遍历所有的service，</span><br><span class="line">如果service的class和class_start这个action指定的参数一致，会调用service的StartIfNotDisabled()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## rc文件中设置环境变量</span><br><span class="line">在 ```system/core/rootdir/init.environ.rc.in```中初始化了环境变量</span><br></pre></td></tr></table></figure>
<h1 id="set-up-the-global-environment"><a href="#set-up-the-global-environment" class="headerlink" title="set up the global environment"></a>set up the global environment</h1><p>on early-init<br>    export ANDROID_BOOTLOGO 1<br>    export ANDROID_ROOT &#x2F;system<br>    export ANDROID_ASSETS &#x2F;system&#x2F;app<br>    export ANDROID_DATA &#x2F;data<br>    export ANDROID_STORAGE &#x2F;storage<br>    export ANDROID_ART_ROOT &#x2F;apex&#x2F;com.android.art<br>    export ANDROID_I18N_ROOT &#x2F;apex&#x2F;com.android.i18n<br>    export ANDROID_TZDATA_ROOT &#x2F;apex&#x2F;com.android.tzdata<br>    export EXTERNAL_STORAGE &#x2F;sdcard<br>    export ASEC_MOUNTPOINT &#x2F;mnt&#x2F;asec<br>    export BOOTCLASSPATH %BOOTCLASSPATH%<br>    export DEX2OATBOOTCLASSPATH %DEX2OATBOOTCLASSPATH%<br>    export SYSTEMSERVERCLASSPATH %SYSTEMSERVERCLASSPATH%<br>    %EXPORT_GLOBAL_ASAN_OPTIONS%<br>    %EXPORT_GLOBAL_GCOV_OPTIONS%<br>    %EXPORT_GLOBAL_CLANG_COVERAGE_OPTIONS%<br>    %EXPORT_GLOBAL_HWASAN_OPTIONS%</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找 ```%BOOTCLASSPATH%```可以在```system/core/rootdir/Android.mk```中找到文本替换的逻辑</span><br></pre></td></tr></table></figure>
<p>$(LOCAL_BUILT_MODULE): $(LOCAL_PATH)&#x2F;init.environ.rc.in<br>    @echo “Generate: $&lt; -&gt; $@”<br>    @mkdir -p $(dir $@)<br>    $(hide) sed -e ‘s?%BOOTCLASSPATH%?$(PRODUCT_BOOTCLASSPATH)?g’ $&lt; &gt;$@<br>    $(hide) sed -i -e ‘s?%DEX2OATBOOTCLASSPATH%?$(PRODUCT_DEX2OAT_BOOTCLASSPATH)?g’ $@<br>    $(hide) sed -i -e ‘s?%SYSTEMSERVERCLASSPATH%?$(PRODUCT_SYSTEM_SERVER_CLASSPATH)?g’ $@<br>    $(hide) sed -i -e ‘s?%EXPORT_GLOBAL_ASAN_OPTIONS%?$(EXPORT_GLOBAL_ASAN_OPTIONS)?g’ $@<br>    $(hide) sed -i -e ‘s?%EXPORT_GLOBAL_GCOV_OPTIONS%?$(EXPORT_GLOBAL_GCOV_OPTIONS)?g’ $@<br>    $(hide) sed -i -e ‘s?%EXPORT_GLOBAL_CLANG_COVERAGE_OPTIONS%?$(EXPORT_GLOBAL_CLANG_COVERAGE_OPTIONS)?g’ $@<br>    $(hide) sed -i -e ‘s?%EXPORT_GLOBAL_HWASAN_OPTIONS%?$(EXPORT_GLOBAL_HWASAN_OPTIONS)?g’ $@</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">也就是说可以通过</span><br><span class="line">* 修改```PRODUCT_BOOTCLASSPATH```来修改环境变量```BOOTCLASSPATH```</span><br><span class="line">* 修改```PRODUCT_SYSTEM_SERVER_CLASSPATH```来修改环境变量```SYSTEMSERVERCLASSPATH```</span><br><span class="line"></span><br><span class="line">## zygote的启动</span><br><span class="line">1. init 进程将事件放进了ActionManager的事件队列里（early-init，init，[late-init](http://aospxref.com/android-11.0.0_r21/xref/system/core/init/init.cpp#837)）,交给ActionManager去[执行指令](http://aospxref.com/android-11.0.0_r21/xref/system/core/init/action_manager.cpp#67)；</span><br><span class="line"></span><br><span class="line">2. 在rc文件中定义的[late-init](http://aospxref.com/android-11.0.0_r21/xref/system/core/rootdir/init.rc#415)，去trigger zygote-start，在[zygote-start](http://aospxref.com/android-11.0.0_r21/xref/system/core/rootdir/init.rc#812)中去start zygote；</span><br></pre></td></tr></table></figure>
<p>on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted<br>    # A&#x2F;B update verifier that marks a successful boot.<br>    exec_start update_verifier_nonencrypted<br>    start statsd<br>    start netd<br>    start zygote<br>    start zygote_secondary</p>
<p>service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin –zygote –start-system-server –socket-name&#x3D;zygote<br>    class main<br>    priority -20<br>    user root<br>    group root readproc reserved_disk<br>    #……</p>
<p>service zygote_secondary &#x2F;system&#x2F;bin&#x2F;app_process32 -Xzygote &#x2F;system&#x2F;bin –zygote –socket-name&#x3D;zygote_secondary –enable-lazy-preload<br>    class main<br>    priority -20<br>    user root<br>    group root readproc reserved_disk<br>    #……</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 根据action启动zygote服务([start](http://aospxref.com/android-11.0.0_r21/xref/system/core/init/builtins.cpp?fi=GetBuiltinFunctionMap#do_start) zygote)，调用Service的[Start方法](http://aospxref.com/android-11.0.0_r21/xref/system/core/init/service.cpp#392)，Start方法中去fork了一个进程，fork() 在父进程中返回子进程的 PID，而在子进程中返回 0。并通过execv去运行在zygote.rc中指定的service的可执行文件，也就是build出来的app_process这个bin文件</span><br></pre></td></tr></table></figure>
<p>Result<void> Service::Start() {<br>    &#x2F;&#x2F;……<br>    pid_t pid &#x3D; -1;<br>    if (namespaces_.flags) {<br>        pid &#x3D; clone(nullptr, nullptr, namespaces_.flags | SIGCHLD, nullptr);<br>    } else {<br>        pid &#x3D; fork();<br>    }</p>
<pre><code>if (pid == 0) &#123;
    umask(077);

    if (auto result = EnterNamespaces(namespaces_, name_, pre_apexd_); !result.ok()) &#123;
        LOG(FATAL) &lt;&lt; &quot;Service &#39;&quot; &lt;&lt; name_
                   &lt;&lt; &quot;&#39; failed to set up namespaces: &quot; &lt;&lt; result.error();
    &#125;

    for (const auto&amp; [key, value] : environment_vars_) &#123;
        setenv(key.c_str(), value.c_str(), 1);
    &#125;

    for (const auto&amp; descriptor : descriptors) &#123;
        descriptor.Publish();
    &#125;

    if (auto result = WritePidToFiles(&amp;writepid_files_); !result.ok()) &#123;
        LOG(ERROR) &lt;&lt; &quot;failed to write pid to files: &quot; &lt;&lt; result.error();
    &#125;

    if (task_profiles_.size() &gt; 0 &amp;&amp; !SetTaskProfiles(getpid(), task_profiles_)) &#123;
        LOG(ERROR) &lt;&lt; &quot;failed to set task profiles&quot;;
    &#125;

    // As requested, set our gid, supplemental gids, uid, context, and
    // priority. Aborts on failure.
    SetProcessAttributesAndCaps();

    if (!ExpandArgsAndExecv(args_, sigstop_)) &#123;
        PLOG(ERROR) &lt;&lt; &quot;cannot execv(&#39;&quot; &lt;&lt; args_[0]
                    &lt;&lt; &quot;&#39;). See the &#39;Debugging init&#39; section of init&#39;s README.md for tips&quot;;
    &#125;

    _exit(127);
&#125;     
</code></pre>
<p>}</p>
<p>static bool ExpandArgsAndExecv(const std::vector<a href="std::string">std::string</a>&amp; args, bool sigstop) {<br>    std::vector<a href="std::string">std::string</a> expanded_args;<br>    std::vector&lt;char*&gt; c_strings;</p>
<pre><code>expanded_args.resize(args.size());
c_strings.push_back(const_cast&lt;char*&gt;(args[0].data()));
for (std::size_t i = 1; i &lt; args.size(); ++i) &#123;
    auto expanded_arg = ExpandProps(args[i]);
    if (!expanded_arg.ok()) &#123;
        LOG(FATAL) &lt;&lt; args[0] &lt;&lt; &quot;: cannot expand arguments&#39;: &quot; &lt;&lt; expanded_arg.error();
    &#125;
    expanded_args[i] = *expanded_arg;
    c_strings.push_back(expanded_args[i].data());
&#125;
c_strings.push_back(nullptr);

if (sigstop) &#123;
    kill(getpid(), SIGSTOP);
&#125;

return execv(c_strings[0], c_strings.data()) == 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">所以zygote是由app_process来启动的,主要就是看app_process的源码，看它是如何启动zygote的,</span><br><span class="line">AppRuntime继承自AndroidRuntime，在启动zygote的时候是去调用的AndroidRuntime的start,</span><br><span class="line">最终去调用ZygoteInit的main方法</span><br></pre></td></tr></table></figure>
<p>class AppRuntime : public AndroidRuntime {<br>    &#x2F;&#x2F;……<br>}</p>
<p>int main(int argc, char* const argv[])<br>{<br>    &#x2F;&#x2F;……<br>    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));<br>    &#x2F;&#x2F;……</p>
<pre><code>if (zygote) &#123;
    //app_process 带了--zygote参数
    runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);
&#125; else if (className) &#123;
    runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);
&#125; else &#123;
    fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);
    app_usage();
    LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);
&#125;
</code></pre>
<p>}</p>
<p>&#x2F;*</p>
<ul>
<li><p>Start the Android runtime.  This involves starting the virtual machine</p>
</li>
<li><p>and calling the “static void main(String[] args)” method in the class</p>
</li>
<li><p>named by “className”.</p>
</li>
<li></li>
<li><p>Passes the main function two arguments, the class name and the specified</p>
</li>
<li><p>options string.<br> <em>&#x2F;<br>void AndroidRuntime::start(const char</em> className, const Vector<String8>&amp; options, bool zygote)<br>{<br> ALOGD(“&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n”,<br>     className !&#x3D; NULL ? className : “(unknown)”, getuid());<br> &#x2F;&#x2F;……</p>
<p> &#x2F;* start the virtual machine <em>&#x2F;<br> JniInvocation jni_invocation;<br> jni_invocation.Init(NULL);<br> JNIEnv</em> env;<br> &#x2F;&#x2F;启动虚拟机<br> if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) !&#x3D; 0) {<br> return;<br> }<br> onVmCreated(env);</p>
<p> &#x2F;*</p>
<ul>
<li>Register android functions.<br>  *&#x2F;<br> if (startReg(env) &lt; 0) {<br> ALOGE(“Unable to register all android natives\n”);<br> return;<br> }</li>
</ul>
<p> &#x2F;*</p>
<ul>
<li>We want to call main() with a String array with arguments in it.</li>
<li>At present we have two arguments, the class name and an option string.</li>
<li>Create an array to hold them.<br>  *&#x2F;<br> jclass stringClass;<br> jobjectArray strArray;<br> jstring classNameStr;</li>
</ul>
<p> stringClass &#x3D; env-&gt;FindClass(“java&#x2F;lang&#x2F;String”);<br> assert(stringClass !&#x3D; NULL);<br> strArray &#x3D; env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);<br> assert(strArray !&#x3D; NULL);<br> classNameStr &#x3D; env-&gt;NewStringUTF(className);<br> assert(classNameStr !&#x3D; NULL);<br> env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);</p>
<p> for (size_t i &#x3D; 0; i &lt; options.size(); ++i) {<br>     jstring optionsStr &#x3D; env-&gt;NewStringUTF(options.itemAt(i).string());<br>     assert(optionsStr !&#x3D; NULL);<br>     env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);<br> }</p>
<p> &#x2F;*</p>
<ul>
<li>Start VM.  This thread becomes the main thread of the VM, and will</li>
<li>not return until the VM exits.<br>  <em>&#x2F;<br> char</em> slashClassName &#x3D; toSlashClassName(className !&#x3D; NULL ? className : “”);<br> &#x2F;&#x2F;去找对应的类，zygote对应 com.android.internal.os.ZygoteInit 这个类<br> jclass startClass &#x3D; env-&gt;FindClass(slashClassName);<br> if (startClass &#x3D;&#x3D; NULL) {<br> ALOGE(“JavaVM unable to locate class ‘%s’\n”, slashClassName);<br> &#x2F;* keep going <em>&#x2F;<br> } else {<br> &#x2F;&#x2F;找到ZygoteInit的main方法<br> jmethodID startMeth &#x3D; env-&gt;GetStaticMethodID(startClass, “main”,<br> “([Ljava&#x2F;lang&#x2F;String;)V”);<br> if (startMeth &#x3D;&#x3D; NULL) {<br> ALOGE(“JavaVM unable to find main() in ‘%s’\n”, className);<br> &#x2F;</em> keep going *&#x2F;<br> } else {<br> &#x2F;&#x2F;调用ZygoteInit的main方法<br> env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</li>
</ul>
</li>
</ul>
<p>#if 0<br>            if (env-&gt;ExceptionCheck())<br>                threadExitUncaughtException(env);<br>#endif<br>        }<br>    }<br>    free(slashClassName);</p>
<pre><code>ALOGD(&quot;Shutting down VM\n&quot;);
if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)
    ALOGW(&quot;Warning: unable to detach main thread\n&quot;);
if (mJavaVM-&gt;DestroyJavaVM() != 0)
    ALOGW(&quot;Warning: VM did not shut down cleanly\n&quot;);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">zygote此时已经运行起来了，接下来就看ZygoteInit的main方法中做了什么：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>public static void main(String argv[]) &#123;
    //......
    Runnable caller;
    try &#123;
        // Store now for StatsLogging later.
        final long startTime = SystemClock.elapsedRealtime();
        final boolean isRuntimeRestarted = &quot;1&quot;.equals(
                SystemProperties.get(&quot;sys.boot_completed&quot;));

        String bootTimeTag = Process.is64Bit() ? &quot;Zygote64Timing&quot; : &quot;Zygote32Timing&quot;;
        TimingsTraceLog bootTimingsTraceLog = new TimingsTraceLog(bootTimeTag,
                Trace.TRACE_TAG_DALVIK);
        //开始ZygoteInit，在结束时会打印log
        bootTimingsTraceLog.traceBegin(&quot;ZygoteInit&quot;);
        RuntimeInit.preForkInit();

        //......

        // In some configurations, we avoid preloading resources and classes eagerly.
        // In such cases, we will preload things prior to our first fork.
        if (!enableLazyPreload) &#123;
            bootTimingsTraceLog.traceBegin(&quot;ZygotePreload&quot;);
            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,
                    SystemClock.uptimeMillis());
            preload(bootTimingsTraceLog);
            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,
                    SystemClock.uptimeMillis());
            bootTimingsTraceLog.traceEnd(); // ZygotePreload
        &#125;

        // Do an initial gc to clean up after startup
        bootTimingsTraceLog.traceBegin(&quot;PostZygoteInitGC&quot;);
        gcAndFinalize();
        bootTimingsTraceLog.traceEnd(); // PostZygoteInitGC

        //这里ZygoteInit结束
        bootTimingsTraceLog.traceEnd(); // ZygoteInit

        Zygote.initNativeState(isPrimaryZygote);

        ZygoteHooks.stopZygoteNoThreadCreation();

        zygoteServer = new ZygoteServer(isPrimaryZygote);

        if (startSystemServer) &#123;
            //fork一个子进程用来跑SystemServer
            Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);

            // &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the
            // child (system_server) process.
            if (r != null) &#123;
                r.run();
                return;
            &#125;
        &#125;

        //Zygote进程开启一个Socket接收处理消息
        Log.i(TAG, &quot;Accepting command socket connections&quot;);

        // The select loop returns early in the child process after a fork and
        // loops forever in the zygote.
        caller = zygoteServer.runSelectLoop(abiList);
    &#125; catch (Throwable ex) &#123;
        Log.e(TAG, &quot;System zygote died with exception&quot;, ex);
        throw ex;
    &#125; finally &#123;
        if (zygoteServer != null) &#123;
            zygoteServer.closeServerSocket();
        &#125;
    &#125;

    // We&#39;re in the child process and have exited the select loop. Proceed to execute the
    // command.
    if (caller != null) &#123;
        caller.run();
    &#125;

&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以看到Zygote进程主要负责预加载资源，然后fork SystemServer和监听处理socket消息，</span><br><span class="line">SystemServer挂了之后Zygote进程也会自杀，这样init进程会重新拉起Zygote，Zygote再重新fork出SystemServer</span><br><span class="line"></span><br><span class="line">## SystemServer的启动</span><br><span class="line">SystemServer是再ZygoteInit的main方法中fork出来的：</span><br></pre></td></tr></table></figure>
<pre><code>@UnsupportedAppUsage
public static void main(String argv[]) &#123;
    //......
        if (startSystemServer) &#123;
            //调用forkSystemServer返回一个Runnable对象，fork出来的子进程（SystemServer）才会返回
            Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);

            // &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the
            // child (system_server) process.
            if (r != null) &#123;
                r.run();
                return;
            &#125;
        &#125;
    //......
&#125;

private static Runnable forkSystemServer(String abiList, String socketName,
        ZygoteServer zygoteServer) &#123;
    //......
    /* Hardcoded command line to start the system server */
    String args[] = &#123;
            &quot;--setuid=1000&quot;,
            &quot;--setgid=1000&quot;,
            &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,&quot;
                    + &quot;1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011&quot;,
            &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,
            &quot;--nice-name=system_server&quot;,
            &quot;--runtime-args&quot;,
            &quot;--target-sdk-version=&quot; + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,
            &quot;com.android.server.SystemServer&quot;,
    &#125;;
    ZygoteArguments parsedArgs = null;

    int pid;

    try &#123;
        //将参数放在ZygoteArguments这个类的构造方法中进行解析
        parsedArgs = new ZygoteArguments(args);
        Zygote.applyDebuggerSystemProperty(parsedArgs);
        Zygote.applyInvokeWithSystemProperty(parsedArgs);

        if (Zygote.nativeSupportsTaggedPointers()) &#123;
            /* Enable pointer tagging in the system server. Hardware support for this is present
             * in all ARMv8 CPUs. */
            parsedArgs.mRuntimeFlags |= Zygote.MEMORY_TAG_LEVEL_TBI;
        &#125;

        /* Enable gwp-asan on the system server with a small probability. This is the same
         * policy as applied to native processes and system apps. */
        parsedArgs.mRuntimeFlags |= Zygote.GWP_ASAN_LEVEL_LOTTERY;

        if (shouldProfileSystemServer()) &#123;
            parsedArgs.mRuntimeFlags |= Zygote.PROFILE_SYSTEM_SERVER;
        &#125;

        /* Request to fork the system server process */
        pid = Zygote.forkSystemServer(
                parsedArgs.mUid, parsedArgs.mGid,
                parsedArgs.mGids,
                parsedArgs.mRuntimeFlags,
                null,
                parsedArgs.mPermittedCapabilities,
                parsedArgs.mEffectiveCapabilities);
    &#125; catch (IllegalArgumentException ex) &#123;
        throw new RuntimeException(ex);
    &#125;

    /* For child process */
    if (pid == 0) &#123;
        if (hasSecondZygote(abiList)) &#123;
            waitForSecondaryZygote(socketName);
        &#125;

        //fork出来的SystemServer会关闭socket的监听
        zygoteServer.closeServerSocket();
        //这里才是去走SystemServer的逻辑
        return handleSystemServerProcess(parsedArgs);
    &#125;
    return null;
&#125;    
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Zygote.forkSystemServer:</span><br></pre></td></tr></table></figure>
<pre><code>static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags,
        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123;
    ZygoteHooks.preFork();

    int pid = nativeForkSystemServer(
            uid, gid, gids, runtimeFlags, rlimits,
            permittedCapabilities, effectiveCapabilities);

    // Set the Java Language thread priority to the default value for new apps.
    Thread.currentThread().setPriority(Thread.NORM_PRIORITY);

    //内部是去做一些art中jit相关的操作
    ZygoteHooks.postForkCommon();
    return pid;
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com_android_internal_os_Zygote.cpp</span><br></pre></td></tr></table></figure>
<p>static jint com_android_internal_os_Zygote_nativeForkSystemServer(<br>        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,<br>        jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities,<br>        jlong effective_capabilities) {<br>  &#x2F;&#x2F;……<br>  &#x2F;&#x2F;ForkCommon是所有APP都会走的逻辑，内部实际就是去调用fork()，还做了一些通用逻辑<br>  pid_t pid &#x3D; ForkCommon(env, true,<br>                         fds_to_close,<br>                         fds_to_ignore,<br>                         true);<br>  if (pid &#x3D;&#x3D; 0) {<br>      &#x2F;&#x2F; System server prcoess does not need data isolation so no need to<br>      &#x2F;&#x2F; know pkg_data_info_list.<br>      &#x2F;&#x2F;SpecializeCommon会根据fork的子进程是否是SystemServer进行逻辑处理<br>      SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits,<br>                       permitted_capabilities, effective_capabilities,<br>                       MOUNT_EXTERNAL_DEFAULT, nullptr, nullptr, true,<br>                       false, nullptr, nullptr, &#x2F;* is_top_app&#x3D; <em>&#x2F; false,<br>                       &#x2F;</em> pkg_data_info_list <em>&#x2F; nullptr,<br>                       &#x2F;</em> whitelisted_data_info_list *&#x2F; nullptr, false, false);<br>  } else if (pid &gt; 0) {<br>      &#x2F;&#x2F; The zygote process checks whether the child process has died or not.<br>      ALOGI(“System server process %d has been created”, pid);<br>      gSystemServerPid &#x3D; pid;<br>      &#x2F;&#x2F; There is a slight window that the system server process has crashed<br>      &#x2F;&#x2F; but it went unnoticed because we haven’t published its pid yet. So<br>      &#x2F;&#x2F; we recheck here just to make sure that all is well.<br>      int status;<br>      if (waitpid(pid, &amp;status, WNOHANG) &#x3D;&#x3D; pid) {<br>          ALOGE(“System server process %d has died. Restarting Zygote!”, pid);<br>          RuntimeAbort(env, <strong>LINE</strong>, “System server process has died. Restarting Zygote!”);<br>      }</p>
<pre><code>  if (UsePerAppMemcg()) &#123;
      // Assign system_server to the correct memory cgroup.
      // Not all devices mount memcg so check if it is mounted first
      // to avoid unnecessarily printing errors and denials in the logs.
      if (!SetTaskProfiles(pid, std::vector&lt;std::string&gt;&#123;&quot;SystemMemoryProcess&quot;&#125;)) &#123;
          ALOGE(&quot;couldn&#39;t add process %d into system memcg group&quot;, pid);
      &#125;
  &#125;
</code></pre>
<p>  }<br>  return pid;<br>}</p>
<p>&#x2F;&#x2F; Utility routine to fork a process from the zygote.<br>static pid_t ForkCommon(JNIEnv* env, bool is_system_server,<br>                        const std::vector<int>&amp; fds_to_close,<br>                        const std::vector<int>&amp; fds_to_ignore,<br>                        bool is_priority_fork) {<br>  &#x2F;&#x2F;……</p>
<p>  &#x2F;&#x2F;fork一个子进程<br>  pid_t pid &#x3D; fork();</p>
<p>  if (pid &#x3D;&#x3D; 0) {<br>    if (is_priority_fork) {<br>      setpriority(PRIO_PROCESS, 0, PROCESS_PRIORITY_MAX);<br>    } else {<br>      setpriority(PRIO_PROCESS, 0, PROCESS_PRIORITY_MIN);<br>    }</p>
<pre><code>// The child process.
PreApplicationInit();

// Clean up any descriptors which must be closed immediately
DetachDescriptors(env, fds_to_close, fail_fn);

// Invalidate the entries in the USAP table.
ClearUsapTable();

// Re-open all remaining open file descriptors so that they aren&#39;t shared
// with the zygote across a fork.
gOpenFdTable-&gt;ReopenOrDetach(fail_fn);

// Turn fdsan back on.
android_fdsan_set_error_level(fdsan_error_level);

// Reset the fd to the unsolicited zygote socket
gSystemServerSocketFd = -1;
</code></pre>
<p>  } else {<br>    ALOGD(“Forked child process %d”, pid);<br>  }</p>
<p>  &#x2F;&#x2F; We blocked SIGCHLD prior to a fork, we unblock it here.<br>  UnblockSignal(SIGCHLD, fail_fn);</p>
<p>  return pid;<br>}</p>
<p>static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids,<br>                             jint runtime_flags, jobjectArray rlimits,<br>                             jlong permitted_capabilities, jlong effective_capabilities,<br>                             jint mount_external, jstring managed_se_info,<br>                             jstring managed_nice_name, bool is_system_server,<br>                             bool is_child_zygote, jstring managed_instruction_set,<br>                             jstring managed_app_data_dir, bool is_top_app,<br>                             jobjectArray pkg_data_info_list,<br>                             jobjectArray whitelisted_data_info_list,<br>                             bool mount_data_dirs, bool mount_storage_dirs) {<br>  &#x2F;&#x2F;……<br>  &#x2F;&#x2F;gZygoteClass是Zygote.java<br>  if (is_system_server) {<br>    &#x2F;&#x2F;调用java层的方法Zygote.callPostForkSystemServerHooks(int runtimeFlags)<br>    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkSystemServerHooks, runtime_flags);<br>    if (env-&gt;ExceptionCheck()) {<br>      fail_fn(“Error calling post fork system server hooks.”);<br>    }</p>
<pre><code>// TODO(oth): Remove hardcoded label here (b/117874058).
static const char* kSystemServerLabel = &quot;u:r:system_server:s0&quot;;
//这里是去改SystemServer的seclabel
if (selinux_android_setcon(kSystemServerLabel) != 0) &#123;
  fail_fn(CREATE_ERROR(&quot;selinux_android_setcon(%s)&quot;, kSystemServerLabel));
&#125;
</code></pre>
<p>  }</p>
<p>  &#x2F;&#x2F;……<br>  &#x2F;&#x2F;调用java层的方法Zygote.callPostForkChildHooks()<br>  env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,<br>                            is_system_server, is_child_zygote, managed_instruction_set);</p>
<p>  &#x2F;&#x2F;……<br>}                                </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在fork的过程中做了很多逻辑，应该和android的运行优化有关，继续看SystemServer进程fork出来之后的逻辑,</span><br><span class="line">ZygoteInit中的handleSystemServerProcess:</span><br></pre></td></tr></table></figure>
<pre><code>/**
 * Finish remaining work for the newly forked system server process.
 */
private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) &#123;
    // set umask to 0077 so new files and directories will default to owner-only permissions.
    Os.umask(S_IRWXG | S_IRWXO);

    //......

        /*
         * Pass the remaining arguments to SystemServer.
         */
        return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,
                parsedArgs.mDisabledCompatChanges,
                parsedArgs.mRemainingArgs, cl);
    //......

    /* should never reach here */
&#125;

public static final Runnable zygoteInit(int targetSdkVersion, long[] disabledCompatChanges,
        String[] argv, ClassLoader classLoader) &#123;
    if (RuntimeInit.DEBUG) &#123;
        Slog.d(RuntimeInit.TAG, &quot;RuntimeInit: Starting application from zygote&quot;);
    &#125;

    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ZygoteInit&quot;);
    RuntimeInit.redirectLogStreams();

    RuntimeInit.commonInit();
    ZygoteInit.nativeZygoteInit();
    return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,
            classLoader);
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RuntimeInit:</span><br></pre></td></tr></table></figure>
<pre><code>protected static Runnable applicationInit(int targetSdkVersion, long[] disabledCompatChanges,
        String[] argv, ClassLoader classLoader) &#123;
    // If the application calls System.exit(), terminate the process
    // immediately without running any shutdown hooks.  It is not possible to
    // shutdown an Android application gracefully.  Among other things, the
    // Android runtime shutdown hooks close the Binder driver, which can cause
    // leftover running threads to crash before the process actually exits.
    nativeSetExitWithoutCleanup(true);

    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);
    VMRuntime.getRuntime().setDisabledCompatChanges(disabledCompatChanges);

    //这里是去解析fork system server时传进来剩余的参数(ZygoteArguments.mRemainingArgs)
    //其实就是&quot;com.android.server.SystemServer&quot;，会再次被解析成startClass
    final Arguments args = new Arguments(argv);

    // The end of of the RuntimeInit event (see #zygoteInit).
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);

    // Remaining arguments are passed to the start class&#39;s static main
    return findStaticMain(args.startClass, args.startArgs, classLoader);
&#125;

protected static Runnable findStaticMain(String className, String[] argv,
        ClassLoader classLoader) &#123;
    Class&lt;?&gt; cl;

    try &#123;
        cl = Class.forName(className, true, classLoader);
    &#125; catch (ClassNotFoundException ex) &#123;
        throw new RuntimeException(
                &quot;Missing class when invoking static main &quot; + className,
                ex);
    &#125;

    Method m;
    try &#123;
        //这里通过反射到SystemServer的main方法
        m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);
    &#125; catch (NoSuchMethodException ex) &#123;
        throw new RuntimeException(
                &quot;Missing static main on &quot; + className, ex);
    &#125; catch (SecurityException ex) &#123;
        throw new RuntimeException(
                &quot;Problem getting static main on &quot; + className, ex);
    &#125;

    int modifiers = m.getModifiers();
    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;
        throw new RuntimeException(
                &quot;Main method is not public and static on &quot; + className);
    &#125;

    /*
     * This throw gets caught in ZygoteInit.main(), which responds
     * by invoking the exception&#39;s run() method. This arrangement
     * clears up all the stack frames that were required in setting
     * up the process.
     */
    //返回一个run方法中调用SystemServer的main方法的Runnable对象，会在ZygoteInit中被调用，至此SystemServer成功运行
    return new MethodAndArgsCaller(m, argv);
&#125;    
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## app的启动</span><br><span class="line">每个app都是是通过Zygote fork出来的，是通过SystemServer向Zygote进程发送socket消息，Zygote进行处理后，返回对应的pid给SystemServer</span><br><span class="line"></span><br><span class="line">主要切入点,ProcessList.java:</span><br></pre></td></tr></table></figure>
<pre><code>boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord,
        int zygotePolicyFlags, boolean disableHiddenApiChecks, boolean disableTestApiChecks,
        boolean mountExtStorageFull, String abiOverride) &#123;
        
        //......

        //指定通过ActivityThread启动
        final String entryPoint = &quot;android.app.ActivityThread&quot;;

        return startProcessLocked(hostingRecord, entryPoint, app, uid, gids,
                runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi,
                instructionSet, invokeWith, startTime);    
&#125;

boolean startProcessLocked(HostingRecord hostingRecord, String entryPoint, ProcessRecord app,
        int uid, int[] gids, int runtimeFlags, int zygotePolicyFlags, int mountExternal,
        String seInfo, String requiredAbi, String instructionSet, String invokeWith,
        long startTime) &#123;
    //......
    //默认值是异步启动的
    if (mService.mConstants.FLAG_PROCESS_START_ASYNC) &#123;
        if (DEBUG_PROCESSES) Slog.i(TAG_PROCESSES,
                &quot;Posting procStart msg for &quot; + app.toShortString());
        mService.mProcStartHandler.post(() -&gt; handleProcessStart(
                app, entryPoint, gids, runtimeFlags, zygotePolicyFlags, mountExternal,
                requiredAbi, instructionSet, invokeWith, startSeq));
        return true;
    &#125; else &#123;
        try &#123;
            final Process.ProcessStartResult startResult = startProcess(hostingRecord,
                    entryPoint, app,
                    uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo,
                    requiredAbi, instructionSet, invokeWith, startTime);
            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,
                    startSeq, false);
        &#125; catch (RuntimeException e) &#123;
            Slog.e(ActivityManagerService.TAG, &quot;Failure starting process &quot;
                    + app.processName, e);
            app.pendingStart = false;
            mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),
                    false, false, true, false, false, app.userId, &quot;start failure&quot;);
        &#125;
        return app.pid &gt; 0;
    &#125;    
&#125;    

private void handleProcessStart(final ProcessRecord app, final String entryPoint,
        final int[] gids, final int runtimeFlags, int zygotePolicyFlags,
        final int mountExternal, final String requiredAbi, final String instructionSet,
        final String invokeWith, final long startSeq) &#123;
    //......

    try &#123;
        final Process.ProcessStartResult startResult = startProcess(app.hostingRecord,
                entryPoint, app, app.startUid, gids, runtimeFlags, zygotePolicyFlags,
                mountExternal, app.seInfo, requiredAbi, instructionSet, invokeWith,
                app.startTime);

        synchronized (mService) &#123;
            handleProcessStartedLocked(app, startResult, startSeq);
        &#125;
    &#125; catch (RuntimeException e) &#123;
        synchronized (mService) &#123;
            Slog.e(ActivityManagerService.TAG, &quot;Failure starting process &quot;
                    + app.processName, e);
            mPendingStarts.remove(startSeq);
            app.pendingStart = false;
            mService.forceStopPackageLocked(app.info.packageName,
                    UserHandle.getAppId(app.uid),
                    false, false, true, false, false, app.userId, &quot;start failure&quot;);
        &#125;
    &#125;
&#125;  

private Process.ProcessStartResult startProcess(HostingRecord hostingRecord, String entryPoint,
        ProcessRecord app, int uid, int[] gids, int runtimeFlags, int zygotePolicyFlags,
        int mountExternal, String seInfo, String requiredAbi, String instructionSet,
        String invokeWith, long startTime) &#123;

    //......
        &#125; else &#123;
            startResult = Process.start(entryPoint,
                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                    app.info.dataDir, invokeWith, app.info.packageName, zygotePolicyFlags,
                    isTopApp, app.mDisabledCompatChanges, pkgDataInfoMap,
                    whitelistedAppDataInfoMap, bindMountAppsData, bindMountAppStorageDirs,
                    new String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);
        &#125;
    //......
&#125;                      
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Process:</span><br></pre></td></tr></table></figure>
<pre><code>public static final ZygoteProcess ZYGOTE_PROCESS = new ZygoteProcess();
public static ProcessStartResult start(@NonNull final String processClass,
                                       @Nullable final String niceName,
                                       int uid, int gid, @Nullable int[] gids,
                                       int runtimeFlags,
                                       int mountExternal,
                                       int targetSdkVersion,
                                       @Nullable String seInfo,
                                       @NonNull String abi,
                                       @Nullable String instructionSet,
                                       @Nullable String appDataDir,
                                       @Nullable String invokeWith,
                                       @Nullable String packageName,
                                       int zygotePolicyFlags,
                                       boolean isTopApp,
                                       @Nullable long[] disabledCompatChanges,
                                       @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt;
                                               pkgDataInfoMap,
                                       @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt;
                                               whitelistedDataInfoMap,
                                       boolean bindMountAppsData,
                                       boolean bindMountAppStorageDirs,
                                       @Nullable String[] zygoteArgs) &#123;
    return ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids,
                runtimeFlags, mountExternal, targetSdkVersion, seInfo,
                abi, instructionSet, appDataDir, invokeWith, packageName,
                zygotePolicyFlags, isTopApp, disabledCompatChanges,
                pkgDataInfoMap, whitelistedDataInfoMap, bindMountAppsData,
                bindMountAppStorageDirs, zygoteArgs);
&#125;    
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ZygoteProcess:</span><br></pre></td></tr></table></figure>
<pre><code>public final Process.ProcessStartResult start(...)&#123;
    //......
    try &#123;
        return startViaZygote(processClass, niceName, uid, gid, gids,
                runtimeFlags, mountExternal, targetSdkVersion, seInfo,
                abi, instructionSet, appDataDir, invokeWith, /*startChildZygote=*/ false,
                packageName, zygotePolicyFlags, isTopApp, disabledCompatChanges,
                pkgDataInfoMap, whitelistedDataInfoMap, bindMountAppsData,
                bindMountAppStorageDirs, zygoteArgs);
    &#125; catch (ZygoteStartFailedEx ex) &#123;
        Log.e(LOG_TAG,
                &quot;Starting VM process through Zygote failed&quot;);
        throw new RuntimeException(
                &quot;Starting VM process through Zygote failed&quot;, ex);
    &#125;        
&#125;

private Process.ProcessStartResult startViaZygote(...)&#123;
    //......
    synchronized(mLock) &#123;
        // The USAP pool can not be used if the application will not use the systems graphics
        // driver.  If that driver is requested use the Zygote application start path.
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),
                                          zygotePolicyFlags,
                                          argsForZygote);
    &#125;        
&#125; 

private Process.ProcessStartResult zygoteSendArgsAndGetResult(...)&#123;
    //......
    return attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);        
&#125;

private Process.ProcessStartResult attemptZygoteSendArgsAndGetResult(
        ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx &#123;
    try &#123;
        final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;
        final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;

        zygoteWriter.write(msgStr);
        zygoteWriter.flush();

        // Always read the entire result from the input stream to avoid leaving
        // bytes in the stream for future process starts to accidentally stumble
        // upon.
        Process.ProcessStartResult result = new Process.ProcessStartResult();
        result.pid = zygoteInputStream.readInt();
        result.usingWrapper = zygoteInputStream.readBoolean();

        if (result.pid &lt; 0) &#123;
            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);
        &#125;

        return result;
    &#125; catch (IOException ex) &#123;
        zygoteState.close();
        Log.e(LOG_TAG, &quot;IO Exception while communicating with Zygote - &quot;
                + ex.toString());
        throw new ZygoteStartFailedEx(ex);
    &#125;
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">到这里SystemServer完成了通过socket发送消息给Zygote的过程，接下来看Zygote中的处理逻辑：</span><br><span class="line">ZygoteConnection.java</span><br></pre></td></tr></table></figure>
<pre><code>Runnable processOneCommand(ZygoteServer zygoteServer) &#123;
    String[] args;

    try &#123;
        args = Zygote.readArgumentList(mSocketReader);
    &#125; catch (IOException ex) &#123;
        throw new IllegalStateException(&quot;IOException on command socket&quot;, ex);
    &#125;
    //......
    //Zygote收到消息后，根据参数去fork一个子进程
    pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids,
            parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo,
            parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote,
            parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mIsTopApp,
            parsedArgs.mPkgDataInfoList, parsedArgs.mWhitelistedDataInfoList,
            parsedArgs.mBindMountAppDataDirs, parsedArgs.mBindMountAppStorageDirs);

    try &#123;
        if (pid == 0) &#123;
            // in child
            zygoteServer.setForkChild();

            zygoteServer.closeServerSocket();
            IoUtils.closeQuietly(serverPipeFd);
            serverPipeFd = null;
            //处理fork出来的app进程
            return handleChildProc(parsedArgs, childPipeFd, parsedArgs.mStartChildZygote);
        &#125; else &#123;
            // In the parent. A pid &lt; 0 indicates a failure and will be handled in
            // handleParentProc.
            IoUtils.closeQuietly(childPipeFd);
            childPipeFd = null;
            handleParentProc(pid, serverPipeFd);
            return null;
        &#125;
    &#125; finally &#123;
        IoUtils.closeQuietly(childPipeFd);
        IoUtils.closeQuietly(serverPipeFd);
    &#125;                
&#125;

private Runnable handleChildProc(ZygoteArguments parsedArgs,
        FileDescriptor pipeFd, boolean isZygote) &#123;
    //......
    if (parsedArgs.mInvokeWith != null) &#123;
        //.....
    &#125; else &#123;
        if (!isZygote) &#123;
            //调用和处理SystemServer一样的方法，不过这里的参数变了mRemainingArgs中指定的是ActivityThread
            //最终会执行ActivityThread中的main方法
            return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,
                    parsedArgs.mDisabledCompatChanges,
                    parsedArgs.mRemainingArgs, null /* classLoader */);
        &#125; else &#123;    
            return ZygoteInit.childZygoteInit(parsedArgs.mTargetSdkVersion,
                    parsedArgs.mRemainingArgs, null /* classLoader */);
        &#125;
    &#125;                
&#125;    
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## android启动相关的event tag</span><br><span class="line">| tag | 对应代码 | 说明 |</span><br><span class="line">|:----|----|----|</span><br><span class="line">| boot_progress_start           | LOG_BOOT_PROGRESS_START           | 在AndroidRuntime.cpp中的start函数中调用，就是app_process去启动zygote的时候</span><br><span class="line">| boot_progress_preload_start   | LOG_BOOT_PROGRESS_PRELOAD_START   | 在ZygoteInit中去开始预加载资源</span><br><span class="line">| boot_progress_preload_end     | LOG_BOOT_PROGRESS_PRELOAD_END     | 在ZygoteInit中预加载资源结束</span><br><span class="line">| boot_progress_system_run      | BOOT_PROGRESS_SYSTEM_RUN          | 刚进入SystemServer的Run方法中</span><br><span class="line">| boot_progress_pms_start       | BOOT_PROGRESS_PMS_START           | PKMS构造方法中，刚进入构造方法，会去读取一些配置文件</span><br><span class="line">| boot_progress_pms_system_scan_start   | BOOT_PROGRESS_PMS_SYSTEM_SCAN_START   | PKMS构造方法中，要开始进行system分区的文件扫描</span><br><span class="line">| boot_progress_pms_data_scan_start     | BOOT_PROGRESS_PMS_DATA_SCAN_START     | PKMS构造方法中，要开始进行data分区的文件扫描</span><br><span class="line">| boot_progress_pms_scan_end            | BOOT_PROGRESS_PMS_SCAN_END            | PKMS构造方法中，app扫描完成</span><br><span class="line">| boot_progress_pms_ready               | BOOT_PROGRESS_PMS_READY               | PKMS构造方法中，要缓存的settings也已经写入本地</span><br><span class="line">| boot_progress_ams_ready               | writeBootProgressAmsReady             | AMS的systemReady中，system server内部服务已经准备完成</span><br><span class="line">| boot_progress_enable_screen           | writeBootProgressEnableScreen         | ATMS的enableScreenAfterBoot中，一般在finishBooting之后</span><br><span class="line">| system_server_start            | SYSTEM_SERVER_START              | 刚进入SystemServer的Run方法中</span><br><span class="line"></span><br><span class="line">在SystemServer启动过程中，会有相关的trace和打印相关的log，tag是```SystemServerTiming```</span><br><span class="line">在非user版本的ROM上，每个打log的地方都会打印耗时``` took to complete: ```可以排查耗时较长的部分</span><br></pre></td></tr></table></figure>
<pre><code>private static final boolean DEBUG_BOOT_TIME = !Build.IS_USER;
public void traceEnd() &#123;
    assertSameThread();
    Trace.traceEnd(mTraceTag);
    //如果是user版本会return
    if (!DEBUG_BOOT_TIME) return;

    if (mCurrentLevel &lt; 0) &#123;
        Slog.w(mTag, &quot;traceEnd called more times than traceBegin&quot;);
        return;
    &#125;

    final String name = mStartNames[mCurrentLevel];
    final long duration = SystemClock.elapsedRealtime() - mStartTimes[mCurrentLevel];
    mCurrentLevel--;

    logDuration(name, duration);
&#125;
</code></pre>
<pre><code>
init的SecondStageMain
am.QueueEventTrigger(&quot;early-init&quot;);
am.QueueEventTrigger(&quot;init&quot;);
am.QueueEventTrigger(&quot;late-init&quot;);
</code></pre>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
</search>
